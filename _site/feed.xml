<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.5">Jekyll</generator><link href="http://localhost:4000/blog/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/blog/" rel="alternate" type="text/html" /><updated>2020-04-04T11:06:54+08:00</updated><id>http://localhost:4000/blog/feed.xml</id><title type="html">Authing 官方博客</title><subtitle>Authing 为个人和企业提供安全的云端身份认证服务，是行业领先的身份认证云。</subtitle><entry><title type="html">AWS KMS 科普: What Why and How?</title><link href="http://localhost:4000/blog/AWS-KMS-%E7%A7%91%E6%99%AE-What-Why-and-How/" rel="alternate" type="text/html" title="AWS KMS 科普: What Why and How?" /><published>2020-04-03T00:00:00+08:00</published><updated>2020-04-03T00:00:00+08:00</updated><id>http://localhost:4000/blog/AWS%20KMS%20%E7%A7%91%E6%99%AE:%20What%20Why%20and%20How</id><content type="html" xml:base="http://localhost:4000/blog/AWS-KMS-%E7%A7%91%E6%99%AE-What-Why-and-How/">&lt;h1 id=&quot;aws-kms-科普-what-why-and-how&quot;&gt;AWS KMS 科普: What Why and How?&lt;/h1&gt;

&lt;h2 id=&quot;what-密钥管理--加密并不难难的是密钥管理&quot;&gt;What: 密钥管理 —— 加密并不难，难的是密钥管理&lt;/h2&gt;

&lt;p&gt;AWS  KMS 全称为 Key Management Service，中文直译过来为密钥管理服务 —— 这一点很重要，它提供的核心服务是&lt;strong&gt;密钥管理&lt;/strong&gt;，帮助企业、开发者方便安全地管理密钥。很多刚接触 KMS 的同学经常搞不清 KMS 到底做是做什么的，很大原因也是没仔细注意到 Key Management 这两个词。&lt;/p&gt;

&lt;p&gt;所以我们的第一个问题「What」就已经回答了，KMS 就是一个管理密钥的服务，它并不是某种 super super magic 的高超加密方法。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;我希望本文的读者通过阅读能意识到一个观念：加密是简单的，难的是管理密钥本身。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;why-kms-能确保你密钥的安全性&quot;&gt;Why: KMS 能确保你密钥的安全性&lt;/h2&gt;

&lt;p&gt;接着来看第二个问题：Why ？为什么我需要把我的密钥给你管理，我自己保存不行了吗？事实上你完全可以自己管理，就像你完全可以自建机房一样，only if 你清楚各种最佳实践并愿意花时间自己去维护。&lt;strong&gt;服务之所以叫服务，是服务提供商为你做了各种各样麻烦的事情&lt;/strong&gt;（They deal with those heavy lifting），从而让你把更多的时间精力花在更有价值的事情上。&lt;/p&gt;

&lt;p&gt;那么 AWS KMS 为用户做了哪些麻烦的工作呢？&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;完全托管：你不需要额外的服务器，不需要额外的维护人员。&lt;/li&gt;
  &lt;li&gt;简化加密过程：你不需要去在意繁琐的加密细节过程，只需要调用相关接口就行了。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;安全审计功能&lt;/strong&gt;：关能够确保安全是不够的，你还需要知道谁具备这个密钥的使用权限，谁在什么时候用了这个密钥，谁又在什么时候删了这个密钥。这一点对大型企业以及提供平台服务的公司非常重要。而这些能够精确到非常细颗粒度的审计功能，已经被 AWS 通过 AWS Cloud Trail Service 完全内置在整个 AWS 生态内了。（It’s not enough to be secure, you have to demonstrate to somebody, whether that’s internal audit, your boss, or maybe your customers .  ）&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;确保你的密钥是安全的&lt;/strong&gt;：你不需要费劲脑汁想办法把你的密钥保存在某个机密的、不对外网暴露的地方。事实上  AWS KMS 的密钥（确切来说是 Matser Key）是完全保存在内存中的，没有任何人（包括  AWS 自己）能够获取到密钥的原始内容，下文会介绍为什么。&lt;/li&gt;
  &lt;li&gt;密钥 rotate 流程：AWS 会定时或手动刷新密钥内容，这也是密钥管理的一个最佳实践。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;how-its-complicated-but-they-do-it-for-you&quot;&gt;How: It’s complicated but they do it for you&lt;/h2&gt;

&lt;p&gt;知道了为什么使用 AWS KMS，接下来也是本文重点内容，了解一下 How: KMS 内部实现原理。&lt;/p&gt;

&lt;p&gt;首先了解一下对称加密与非对称加密：简要来说，对称加密指的是加密、解密用的是同一个密钥；非对称加密指的是加密、解密使用一对密钥：公钥和私钥，你可以使用公钥加密私钥解密，也可以反过来。如 HTTPS 用的就是非对称加密。&lt;/p&gt;

&lt;p&gt;接下来看看 KMS 内部是如何保存你的密钥的：假设我们有一个用于加密数据的密钥，叫做 Data Key，将 Data 加密过后得到 Encrypted Data，这个过程很简单。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.authing.cn/blog/20200403143826.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;但是问题来了，该怎么处理 Data Key 呢，要是攻击者获取到了 Data Key，那不相当于数据也就被破解了？正确的选择是把 Data Key 也用某种密钥（这里把它叫做 Matser Key）加密一下（术语叫做 Wrapping），得到 Encrypted Data Key 。接着我们把 Encrypted Data 和 Encrypted Data Key 保存在一起，如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.authing.cn/blog/20200403143843.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;可是问题又来了：Master Key 怎么加密？相信你已经察觉出来了，&lt;del&gt;这很像一个俄罗斯套娃（划掉）&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.authing.cn/blog/20200403145809.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;你没有看错，AWS KMS  还真就是这么做的，他们这样一层一层加密密钥（专业名词叫做 KMS Key Hierarchy），到最终的那个 Key 的时候，它的确是一个明文，但是：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;它完完全全保存在内存里面，永远不会在物理介质里面保存下来。&lt;/li&gt;
  &lt;li&gt;它永远不会在公网传输。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;以至于连 AWS 员工都没有办法获取到原始内容。&lt;/p&gt;

&lt;p&gt;那么其他的 Data Key 呢？我真正加密的数据的数据用的是 Data Key，要是 Data  Key 泄漏了怎么办？这个问题很重要。那么 KMS 是如何解决的呢？&lt;/p&gt;

&lt;p&gt;KMS 的 Data Key 是在内存中动态生成的，用于加密数据过后，它就在内存中被删掉了，只有加密过后的 Encrypted Data Key 保留了下来。&lt;/p&gt;

&lt;p&gt;借用 AWS re:Invent 2019 上 AWS Solution Architect Peter M.O’Donnell  的话：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;KMS is a very serious service, built by very serious people for very serious customers .&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;总结一下：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Data 是用 Data Key 加密的，得到 Encrypted Data。&lt;/li&gt;
  &lt;li&gt;Encrypted Data 和 Encrypted Data Key 保存在了一起。&lt;/li&gt;
  &lt;li&gt;你就算得到了 Encrypted Data 和 Encrypted Data Key 也没用，你还得得到上一层加密此 Encrypted Data Key 的 Matser Key，一层一层往上，你得知道最终那个在 Top Level 的 Master Key。&lt;/li&gt;
  &lt;li&gt;KMS 在根本上通过设计，确保了没有任何人能够获取到 Top Level Master Key。&lt;/li&gt;
  &lt;li&gt;所以你的数据是安全的。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这篇文章介绍了 AWS KMS 是什么、为什么要用 KMS 以及 KMS 是如何保护你的密钥从而保护你的数据的，下一篇我们从实际应用的角度，来看看该怎么将 KMS  具体应用到你的系统中。&lt;/p&gt;

&lt;p&gt;相关阅读：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://amazonaws-china.com/kms/&quot;&gt;https://amazonaws-china.com/kms/&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=hxWvbNvj2lg&quot;&gt;AWS re:Invent 2019: Using AWS KMS for data protection, access control, and audit&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=SOnJyqwGn1I&quot;&gt;AWS Security Basics - AWS KMS&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</content><author><name>cj</name></author><category term="KMS" /><category term="AWS" /><category term="网络安全" /><summary type="html">AWS KMS 科普: What Why and How?</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://cdn.authing.cn/blog/20200403150535.png" /></entry><entry><title type="html">张小龙看了想点赞 —— 用企业微信登录阿里云 ¿</title><link href="http://localhost:4000/blog/%E5%BC%A0%E5%B0%8F%E9%BE%99%E7%9C%8B%E4%BA%86%E6%83%B3%E7%82%B9%E8%B5%9E-%E7%94%A8%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E7%99%BB%E5%BD%95%E9%98%BF%E9%87%8C%E4%BA%91/" rel="alternate" type="text/html" title="张小龙看了想点赞 —— 用企业微信登录阿里云 ¿" /><published>2020-04-02T00:00:00+08:00</published><updated>2020-04-02T00:00:00+08:00</updated><id>http://localhost:4000/blog/%E5%BC%A0%E5%B0%8F%E9%BE%99%E7%9C%8B%E4%BA%86%E6%83%B3%E7%82%B9%E8%B5%9E%20%E2%80%94%E2%80%94%20%E7%94%A8%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E7%99%BB%E5%BD%95%E9%98%BF%E9%87%8C%E4%BA%91</id><content type="html" xml:base="http://localhost:4000/blog/%E5%BC%A0%E5%B0%8F%E9%BE%99%E7%9C%8B%E4%BA%86%E6%83%B3%E7%82%B9%E8%B5%9E-%E7%94%A8%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E7%99%BB%E5%BD%95%E9%98%BF%E9%87%8C%E4%BA%91/">&lt;p&gt;&lt;img src=&quot;/blog/assets/images/wechatwork/1.gif&quot; alt=&quot;assets/images/pipeline/4.gif&quot; /&gt;&lt;/p&gt;

&lt;p&gt;很多企业都在使用企业微信进行组织机构管理，同时又使用了阿里云的服务，我们不希望单独为每个员工创建一个阿里云子账号，要是能够直接使用企业微信登录就好了。这时候如何统一用户目录和实现单点登录就成了一个我们需要思考的问题。&lt;/p&gt;

&lt;p&gt;阿里云在自己的单点登录管理（SSO）中介绍到，可以使用 SAML 协议提供单点登录管理，流程图如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.authing.cn/blog/20200403144540.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;阿里云与企业进行用户 SSO 时，阿里云是服务提供商（SP），而企业自有的身份管理系统则是身份提供商（IdP）。通过用户SSO，企业员工在登录后，将以 RAM 用户身份访问阿里云。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;暂时先不用管 SAML 是什么，下文会详细讲到，这里简单理解为一种用户身份问答协议就行了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;当管理员在完成用户 SSO 的相关配置后，企业员工 Alice 可以通过上图所示的方法登录到阿里云。&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Alice 使用浏览器登录阿里云，阿里云将 SAML 认证请求返回给浏览器。&lt;/li&gt;
  &lt;li&gt;浏览器向 IdP 转发 SAML 认证请求。&lt;/li&gt;
  &lt;li&gt;IdP 提示 Alice 登录，并在Alice登录成功后生成 SAML 响应返回给浏览器。&lt;/li&gt;
  &lt;li&gt;浏览器将 SAML 响应转发给 SSO 服务。&lt;/li&gt;
  &lt;li&gt;SSO 服务通过SAML互信配置，验证 SAML 响应的数字签名来判断 SAML 断言的真伪，并通过 SAML断言的 NameID 元素值，匹配到对应阿里云账号中的 RAM 用户身份。&lt;/li&gt;
  &lt;li&gt;SSO服务向浏览器返回控制台的URL。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;总结一下重要的点：IdP （身份提供商），也即企业用户，有一套自己的用户目录，至于这个用户目录具体是怎样的，你是用数据库存还是 Excel 存，你是用账号密码登录还是支持第三方社会化登录，阿里云并不操心。重要的是你的用户目录需要和阿里云 RAM 用户身份建立一对一关系。具体到 SAML 协议，你需要把你的用户目录的用户唯一字段作为 NameID 传给阿里云，这样阿里云就能够知道该以哪个 RAM 用户身份登录阿里云了。&lt;/p&gt;

&lt;p&gt;于是我们的问题就 Break Down 为下面几步：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;为你的用户目录支持 SAML 协议&lt;/li&gt;
  &lt;li&gt;为你的用户目录支持企业微信登录&lt;/li&gt;
  &lt;li&gt;将你的用户目录和阿里云用户角色之间建立一对一关系。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;如果你对其中某一部分很了解，可以跳过对应章节。&lt;/p&gt;

&lt;h2 id=&quot;支持-saml-协议&quot;&gt;支持 SAML 协议&lt;/h2&gt;

&lt;p&gt;首先科普一下 SAML 是什么：SAML 全称是 Security Assertion Markup Language （中文直译为「安全断言标记语言」），从字面意义我们还看不出什么头绪。&lt;/p&gt;

&lt;p&gt;我们从协议交互角度切入：SAML 认证流程一般都会牵涉到两方：服务提供方（SP）和身份提供方（IdP），典型的 SP 有阿里云、腾讯云以及很多很多的 SaaS 服务；IdP 其实就是我们企业自己，因为用户目录在我们这里。访问 SP 服务的时候，SP 会向 IdP 发送一个 SAML Request（具体是什么我们暂时不关心），请求 IdP 判断用户身份。IdP 收到 SAML Request 后，可以通过某种手段对用户身份进行认证，如果已登录，可以直接返回用户身份信息给 SP；如果未登录，可以弹出一个登录框，用户登录之后再将用户身份返回给 SP。SP 收到用户信息之后，再在自己的数据库里面找出对应的用户，然后以这个用户的身份访问 SP 服务。&lt;/p&gt;

&lt;p&gt;SAML 协议的具体实现过于复杂，不建议自己从零实现，可以借助已有开源库实现，比如：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;NodeJS 的 &lt;a href=&quot;https://github.com/tngan/samlify&quot;&gt;samlify&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Python 的 &lt;a href=&quot;https://github.com/onelogin/python-saml&quot;&gt;python-saml&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Java 的 &lt;a href=&quot;https://github.com/onelogin/java-saml&quot;&gt;java-saml&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一般来说，如果你作为 IdP ，需要将自己内部用户目录数据库的字段和 SAML 字段对齐，并实现 metadata 、 SingleSignOnService 和  SingleLogoutService 接口，分别实现获取  IdP 元信息、单点登录和单点登出。具体代码实现这里就不详细讲了，感兴趣的可以用开源库实现一下，或者你也可以考虑使用&lt;a href=&quot;https://docs.authing.cn/authing/authentication/use-saml&quot;&gt;我们的 SAML 服务&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&quot;支持企业微信登录&quot;&gt;支持企业微信登录&lt;/h2&gt;

&lt;p&gt;企业微信支持两种身份认证方式：&lt;a href=&quot;https://work.weixin.qq.com/api/doc/90000/90135/91020&quot;&gt;网页授权登录&lt;/a&gt;（指在企业微信 APP  内打开的网页，不适用于普通的浏览器网页）和&lt;a href=&quot;https://work.weixin.qq.com/api/doc/90000/90135/90988&quot;&gt;扫码登录&lt;/a&gt;，这里我们主要讲如何接入扫码登录。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;BTW: 如果你对扫码登录原理感兴趣，可以看看我们之前写的如何从零&lt;a href=&quot;https://juejin.im/post/5e083565e51d45581308a3e5&quot;&gt;实现扫码登录系列文章&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;企业微信扫码登录流程如下：用户进入第三方网站，且这个网站支持使用企业微信登录，用户使用企业微信扫码登录之后，企业微信会将登录授权码返回给你，接着你就可以使用这个授权码换取用户信息了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.authing.cn/blog/20200403144934.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;首先你需要拼接一个微信扫码登录链接，如下图所示：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;https://open.work.weixin.qq.com/wwopen/sso/3rd_qrConnect?appid=ww100000a5f2191&amp;amp;redirect_uri=http%3A%2F%2Fwww.oa.com&amp;amp;state=web_login@gyoss9&amp;amp;usertype=member
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;appid 为服务商的CorpID&lt;/li&gt;
  &lt;li&gt;redirect_uri 为用户授权之后企业微信服务器转发授权码的地址。&lt;/li&gt;
  &lt;li&gt;usertype 为支持登录的类型。admin代表管理员登录（使用微信扫码）,member代表成员登录（使用企业微信扫码），默认为admin。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;用户同意授权之后，会转发登录授权码给上面填写的 redirect_uri，你可以用它来换取用户信息：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;POST https://qyapi.weixin.qq.com/cgi-bin/service/get_login_info?access_token=PROVIDER_ACCESS_TOKEN
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;POST 请求 body 为：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{
  &quot;auth_code&quot;:&quot;xxxxx&quot;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;其中 auth_code 就是登录授权码，PROVIDER_ACCESS_TOKEN 是服务商凭证，你可以在这里看到如何&lt;a href=&quot;https://work.weixin.qq.com/api/doc/90001/90142/90593#%e6%9c%8d%e5%8a%a1%e5%95%86%e7%9a%84token&quot;&gt;获取服务商凭证&lt;/a&gt;。换取用户信息之后，你可以将其保持至自己的数据库。&lt;/p&gt;

&lt;p&gt;具体的细节就不多说了，还牵涉到配置 IP 白名单，添加可信任域名等，如果你感兴趣，可以看企业微信的&lt;a href=&quot;https://work.weixin.qq.com/api/doc/90001/90143/91123&quot;&gt;开发文档&lt;/a&gt;。当然，如果你不想自己实现，我们也提供这个&lt;a href=&quot;https://docs.authing.cn/authing/social-login/web/wechatwork-qrconnect&quot;&gt;服务&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&quot;用户目录和阿里云用户角色对齐&quot;&gt;用户目录和阿里云用户角色对齐&lt;/h2&gt;

&lt;p&gt;如果你实现好了 SAML 协议，你有个有一个接口可以用于下载  IdP Metadata，需要将其上传给阿里云。&lt;/p&gt;

&lt;h3 id=&quot;在阿里云添加用户&quot;&gt;在阿里云添加用户&lt;/h3&gt;

&lt;p&gt;使用你的阿里云账号登录阿里云的&lt;a href=&quot;https://www.aliyun.com/&quot;&gt;控制台&lt;/a&gt;。在你的用户头像上悬停鼠标，出现下拉菜单，点击「访问控制」。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.authing.cn/blog/20200403145330.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;进入左侧菜单 -&amp;gt; 人员管理 -&amp;gt; 用户，点击「新建用户」。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.authing.cn/blog/20200403145342.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;输入用户名称、显示名称，勾选控制台密码登录并点击「确认」。本教程中输入的登录名称是 authing，显示名称也是 authing。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.authing.cn/blog/20200403145351.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;点击左侧菜单 -&amp;gt; 人员管理 -&amp;gt; 用户，在右侧页面的列表中可以看到刚刚添加的用户，记录下用户登录名称（xxx@xxx.onaliyun.com），随后会用到。点击对应用户条目右侧的「添加权限」。&lt;/p&gt;

&lt;p&gt;在权限列表中选择需要赋予该账户的权限，本教程选择「AdministratorAccess」最高权限。点击「确定」。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.authing.cn/blog/20200403145412.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;进入左侧菜单 -&amp;gt; SSO 管理，右侧页面点击「用户 SSO」选项卡，在下方 SSO 登录设置处点击「编辑」。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.authing.cn/blog/20200403145421.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;SSO 功能状态选择「开启」。点击「上传文件」，上传你的 SAML IdP Metadata。点击「确认」。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.authing.cn/blog/20200403145433.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;在你的用户目录进行对齐&quot;&gt;在你的用户目录进行对齐&lt;/h3&gt;

&lt;p&gt;上一步在阿里云配置好了账号，用户名为 xxx@xxx.onaliyun.com ，接下来需要将其映射到你的用户目录。方法很简单，你只需要将对应企业微信登录用户的 NameID 设置成 xxx@xxx.onaliyun.com 即可。&lt;/p&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;这篇文章，我们介绍了如何利用 SAML 协议将企业微信和阿里云建立起联系。总结一下，我们一共实现了三件事情：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;接入 SAML 协议&lt;/li&gt;
  &lt;li&gt;接入企业微信登录&lt;/li&gt;
  &lt;li&gt;将阿里云 RAM 用户和自己的用户目录打通&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;事实上，企业微信登录只是&lt;strong&gt;某种&lt;/strong&gt;登录手段，你也完全可以支持 GitHub 登录、微博登录、手机号验证码登录、生物指纹登录 ….. 任何你能想到的登录方式都可以。&lt;/p&gt;

&lt;p&gt;而上述这些东西，Authing 都支持，我们有非常丰富的社会化登录手段，除了企业微信，我们还支持 GitHub、微信、微博、钉钉、QQ、支付宝、小程序等。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.authing.cn/blog/20200403145514.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们还封装了简单易用的 SAML 协议，让你可以只需要填写自己简单的配置文件，就拥有一个完整的 SAML 协议实现以及一个美观易用的登录表单：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.authing.cn/blog/20200403145524.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如果你不想关心具体的技术细节，完全可以直接使用 Authing 开箱即用的服务，将更多的精力集中到核心业务上。&lt;/p&gt;

&lt;p&gt;欢迎体验：&lt;a href=&quot;https://authing.cn&quot;&gt;https://authing.cn&lt;/a&gt;&lt;/p&gt;</content><author><name>cj</name></author><category term="SSO" /><category term="SAML" /><summary type="html"></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://cdn.authing.cn/blog/20200403144431.png" /></entry><entry><title type="html">五分钟理解什么是 OIDC</title><link href="http://localhost:4000/blog/%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87OIDC%E5%8D%8F%E8%AE%AE%E5%AE%9E%E7%8E%B0%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/" rel="alternate" type="text/html" title="五分钟理解什么是 OIDC" /><published>2020-03-27T00:00:00+08:00</published><updated>2020-03-27T00:00:00+08:00</updated><id>http://localhost:4000/blog/%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87OIDC%E5%8D%8F%E8%AE%AE%E5%AE%9E%E7%8E%B0%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95</id><content type="html" xml:base="http://localhost:4000/blog/%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87OIDC%E5%8D%8F%E8%AE%AE%E5%AE%9E%E7%8E%B0%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/">&lt;h1 id=&quot;如何通过oidc协议实现单点登录&quot;&gt;如何通过OIDC协议实现单点登录&lt;/h1&gt;

&lt;h1 id=&quot;什么是单点登录&quot;&gt;什么是单点登录&lt;/h1&gt;

&lt;p&gt;我们通过一个例子来说明，假设有一所大学，内部有两个系统，一个是邮箱系统，一个是课表查询系统。现在想实现这样的效果：在邮箱系统中登录一遍，然后此时进入课表系统的网站，无需再次登录，课表网站系统直接跳转到个人课表页面，反之亦然。比较专业的定义如下：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;单点登录&lt;/strong&gt;（Single Sign On），简称为 &lt;strong&gt;SSO&lt;/strong&gt;，是目前比较流行的企业业务整合的解决方案之一。 SSO 的定义是在多个应用系统中，&lt;strong&gt;用户只需要登录一次&lt;/strong&gt;就可以&lt;strong&gt;访问所有&lt;/strong&gt;相互信任的应用系统。&lt;/p&gt;

&lt;h1 id=&quot;为什么要实现单点登录&quot;&gt;为什么要实现单点登录&lt;/h1&gt;

&lt;p&gt;单点登录的意义在于能够在不同的系统中统一账号、统一登录。用户不必在每个系统中都进行注册、登录，只需要使用一个统一的账号，登录一次，就可以访问所有系统。&lt;/p&gt;

&lt;h1 id=&quot;通过-oidc-协议实现单点登录&quot;&gt;通过 OIDC 协议实现单点登录&lt;/h1&gt;

&lt;h2 id=&quot;创建自己的用户目录&quot;&gt;创建自己的用户目录&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;用户目录&lt;/strong&gt;这个词很贴切，你的系统的总用户表就像一本书一样，书的封皮上写着“所有用户”四个字。打开第一页，就是目录，里面列满了用户的名字，翻到对应的页码就能看到这个人的邮箱，手机号，生日信息等等。无论你开发多少个应用，要确保你有一份这些应用所有用户信息的 truth source。所有的注册、认证、注销都要到你的用户目录中进行增加、查询、删除操作。你要做的就是&lt;strong&gt;创建一个中央数据表，专门用于存储用户信息&lt;/strong&gt;，不论这个用户是来自 A 应用、B 应用还是 C 应用。&lt;/p&gt;

&lt;h2 id=&quot;什么是-oidc-协议&quot;&gt;什么是 OIDC 协议&lt;/h2&gt;

&lt;p&gt;OIDC 的全称是 OpenID Connect，是一个基于 OAuth 2.0 的轻量级认证 + 授权协议，是 OAuth 2.0 的超集。它规定了其他应用，例如你开发的应用 A（XX 邮件系统），应用 B（XX 聊天系统），应用 C（XX 文档系统），如何到你的&lt;strong&gt;中央数据表&lt;/strong&gt;中取出用户数据，约定了交互方式、安全规范等，确保了你的用户能够在访问所有应用时，只需登录一遍，而不是反反复复地输入密码，而且遵循这些规范，你的用户认证环节会很安全。&lt;/p&gt;

&lt;h2 id=&quot;架设自己的-oidc-provider&quot;&gt;架设自己的 OIDC Provider&lt;/h2&gt;

&lt;p&gt;什么是 OIDC Provider 呢？我来举一个例子：你经常见到一些网站的登录页面上有「使用 Github 登录」、「使用 Google 登录」这样的按钮。要想集成这样的功能，你&lt;strong&gt;要先去 Github 那里注册一个 OAuth App，填写一些资料，然后 Github 分配给你一对 id 和 key。&lt;/strong&gt; 此时 Github 扮演的角色就是 OIDC Provider，你要做的就是把 Github 的这种角色的行为，搬到你自己的服务器来。&lt;/p&gt;

&lt;p&gt;在 Github 上面搜索 OIDC Provider 会有很多结果：&lt;/p&gt;

&lt;p&gt;JS：&lt;a href=&quot;https://github.com/panva/node-oidc-provider&quot;&gt;https://github.com/panva/node-oidc-provider&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Golang：&lt;a href=&quot;https://github.com/dexidp/dex&quot;&gt;https://github.com/dexidp/dex&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Python：&lt;a href=&quot;https://github.com/juanifioren/django-oidc-provider&quot;&gt;https://github.com/juanifioren/django-oidc-provider&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;…&lt;/p&gt;

&lt;p&gt;不再一一列举，你需要选择适合你的编程语言的 OIDC Provider 包，然后让它在你的服务器上运行起来。本文使用 JS 语言的 node-oidc-provider。&lt;/p&gt;

&lt;h3 id=&quot;示例代码-github&quot;&gt;示例代码 Github&lt;/h3&gt;
&lt;p&gt;可以在 Github 找到本文示例代码：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/Authing/implement-oidc-sso-demo.git&quot;&gt;https://github.com/Authing/implement-oidc-sso-demo.git&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;创建文件夹&quot;&gt;创建文件夹&lt;/h3&gt;

&lt;p&gt;我们首先创建一个文件夹，用于存放代码：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;mkdir &lt;/span&gt;demo
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cd &lt;/span&gt;demo
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;克隆仓库&quot;&gt;克隆仓库&lt;/h3&gt;

&lt;p&gt;然后我们将 &lt;a href=&quot;https://github.com/panva/node-oidc-provider.git&quot;&gt;https://github.com/panva/node-oidc-provider.git&lt;/a&gt; 仓库 clone 到本地&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git clone https://github.com/panva/node-oidc-provider.git
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;安装依赖&quot;&gt;安装依赖&lt;/h3&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cd &lt;/span&gt;node-oidc-provider
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;npm &lt;span class=&quot;nb&quot;&gt;install&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;在-oidc-provider-申请一个-client&quot;&gt;在 OIDC Provider 申请一个 Client&lt;/h3&gt;

&lt;p&gt;上一步讲到，Github 会分配给你一对 id 和 key，这一步其实就是你在 Github 申请了一个 Client。那么如何向我们自己的服务器上的 OIDC Provider 申请一对这样的 id 和 key 呢？&lt;/p&gt;

&lt;p&gt;以 &lt;a href=&quot;https://github.com/panva/node-oidc-provider/tree/master/example&quot;&gt;node-oidc-provider&lt;/a&gt; 举例，最快的获得一个 Client 的方法就是将 OIDC Client 所需的元数据直接写入 node-oidc-provider 的配置文件里面。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://usercontents.authing.cn/how-to-implement-sso/Untitled.png&quot; alt=&quot;https://usercontents.authing.cn/how-to-implement-sso/Untitled.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Wait wait wait，跨度有些大，这两者之间有什么关系？首先我们看，在 Github 上填写应用信息，然后提交，会发送一个 HTTP 请求到 Github 服务器。Github 服务器会生成一对 id 和 key，还会把它们与你的应用信息存储到 Github 自己的数据库里。所以，我们将 OIDC Client 所需的元数据直接写入到配置文件，可以理解成，我们在自己的数据库里手动插入了一条数据，为自己指定了一对 id 和 key 还有其他的一些 OIDC Client 信息。&lt;/p&gt;

&lt;h3 id=&quot;修改配置文件&quot;&gt;修改配置文件&lt;/h3&gt;

&lt;p&gt;进入 node-oidc-provider 项目下的 example 文件夹：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt; ./example
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;编辑 &lt;code class=&quot;highlighter-rouge&quot;&gt;./support/configuration.js&lt;/code&gt; ，更改第 16 行的 clients 配置，我们为自己指定了一个 client_id 和一个 client_secret，其中的 grant_types 为授权模式，authorization_code 即授权码模式，redirect_uris 数组是允许的业务回调地址，需要填写 Web App 应用的地址，OIDC Provider 会将临时授权码发送到这个地址，以便后续换取 token。&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;module&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;exports&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;clients&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;client_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'1'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;client_secret&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'1'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;grant_types&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'refresh_token'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'authorization_code'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;redirect_uris&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'http://localhost:8080/app1.html'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'http://localhost:8080/app2.html'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;启动-node-oidc-provider&quot;&gt;启动 node-oidc-provider&lt;/h3&gt;

&lt;p&gt;在 node-oidc-provider/example 文件夹下，运行以下命令来启动我们的 OP：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;node express.js
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;到现在，我们的准备工作已经完成了，在讲如何在 Web App 中进行单点登录之前，我们先了解一下 OIDC 授权码模式。刚刚提到的许多术语：&lt;strong&gt;授权码模式&lt;/strong&gt;、&lt;strong&gt;业务回调地址&lt;/strong&gt;、&lt;strong&gt;临时授权码&lt;/strong&gt;，可能这些概念你会感到陌生，下文会详细介绍。&lt;/p&gt;

&lt;h2 id=&quot;oidc-授权码模式&quot;&gt;OIDC 授权码模式&lt;/h2&gt;

&lt;p&gt;以下是 OIDC 授权码模式的交互模式，你的应用和 OP 之间要通过这样的交互方式来获取用户信息。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://usercontents.authing.cn/how-to-implement-sso/Untitled%201.png&quot; alt=&quot;https://usercontents.authing.cn/how-to-implement-sso/Untitled%201.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们的 OIDC Provider 对外暴露一些接口&lt;/p&gt;

&lt;h3 id=&quot;授权接口&quot;&gt;授权接口&lt;/h3&gt;

&lt;p&gt;每次调用这个接口，就像是对 OIDC Provider 喊话：我要登录，如第一步所示。&lt;/p&gt;

&lt;p&gt;然后 OIDC Provider 会&lt;strong&gt;检查当前用户在 OIDC Provider 的登录状态&lt;/strong&gt;，如果是未登录状态，OIDC Provider 会弹出一个登录框，与终端用户确认身份，登录成功后会将一个&lt;strong&gt;临时授权码&lt;/strong&gt;（一个随机字符串）发到你的应用（&lt;strong&gt;业务回调地址&lt;/strong&gt;）；如果是已登录状态，OIDC Provider 会将浏览器直接重定向到你的应用（&lt;strong&gt;业务回调地址&lt;/strong&gt;），并携带&lt;strong&gt;临时授权码&lt;/strong&gt;（一个随机字符串）。如第二、三步所示。&lt;/p&gt;

&lt;h3 id=&quot;token-接口&quot;&gt;token 接口&lt;/h3&gt;

&lt;p&gt;每次调用这个接口，就像是对 OIDC Provider 说：这是我的授权码，给我换一个 access_token。如第四、五步所示。&lt;/p&gt;

&lt;h3 id=&quot;用户信息接口&quot;&gt;用户信息接口&lt;/h3&gt;

&lt;p&gt;每次调用这个接口，就像是对 OIDC Provider 说：这是我的 access_token，给我换一下用户信息。到此用户信息获取完毕。&lt;/p&gt;

&lt;p&gt;为什么这么麻烦？直接返回用户信息不行吗？&lt;/p&gt;

&lt;p&gt;因为安全，关于 OIDC 协议的安全性，又可以展开很大的篇幅，现在简单解释一下：code 的有效期一般只有十分钟，而且一次使用过后作废。OIDC 协议授权码模式中，只有 code 的传输经过了用户的浏览器，一旦泄露，攻击者很难抢在应用服务器拿这个 code 换 token 之前，先去 OP 使用这个 code 换掉 token。而如果 access_token 的传输经过浏览器，一般 access_token 的有效期都是一个小时左右，攻击者可以利用 access_token 获取用户的信息，而应用服务器和 OP 也很难察觉到，更不必说去手动撤退了。如果直接传输用户信息，那安全性就更低了。一句话：避免让攻击者偷走用户信息。&lt;/p&gt;

&lt;h2 id=&quot;编写第一个应用&quot;&gt;编写第一个应用&lt;/h2&gt;

&lt;p&gt;我们创建一个 app1.html 文件来编写第一个应用 demo，在 demo/app 目录下创建：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;touch &lt;/span&gt;app1.html
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;并写入以下内容：&lt;/p&gt;

&lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;html&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;lang=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;en&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;head&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;meta&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;charset=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;UTF-8&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;meta&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;viewport&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;content=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;width=device-width, initial-scale=1.0&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;title&amp;gt;&lt;/span&gt;第一个应用&lt;span class=&quot;nt&quot;&gt;&amp;lt;/title&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;/head&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;body&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;a&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;href=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://localhost:3000/auth?client_id=1&amp;amp;redirect_uri=http://localhost:8080/app1.html&amp;amp;scope=openid profile&amp;amp;response_type=code&amp;amp;state=455356436&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;登录&lt;span class=&quot;nt&quot;&gt;&amp;lt;/a&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;/body&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/html&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;编写第二个应用&quot;&gt;编写第二个应用&lt;/h2&gt;

&lt;p&gt;我们创建一个 app2.html 文件来编写第二个应用 demo，注意 redirect_uri 的变化，在 demo/app 目录下创建：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;touch &lt;/span&gt;app2.html
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;并写入以下内容：&lt;/p&gt;

&lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;html&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;lang=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;en&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;head&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;meta&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;charset=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;UTF-8&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;meta&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;viewport&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;content=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;width=device-width, initial-scale=1.0&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;title&amp;gt;&lt;/span&gt;第二个应用&lt;span class=&quot;nt&quot;&gt;&amp;lt;/title&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;/head&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;body&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;a&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;href=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://localhost:3000/auth?client_id=1&amp;amp;redirect_uri=http://localhost:8080/app2.html&amp;amp;scope=openid profile&amp;amp;response_type=code&amp;amp;state=455356436&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;登录&lt;span class=&quot;nt&quot;&gt;&amp;lt;/a&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;/body&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/html&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;向-oidc-provider-发起登录请求&quot;&gt;向 OIDC Provider 发起登录请求&lt;/h2&gt;

&lt;p&gt;现在我们启动一个 web 服务器，推荐使用 http-server&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;npm &lt;span class=&quot;nb&quot;&gt;install&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-g&lt;/span&gt; http-server &lt;span class=&quot;c&quot;&gt;# 安装 http-server&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cd &lt;/span&gt;demo/app
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;http-server &lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我们访问第一个应用：&lt;a href=&quot;http://localhost:8080/app1.html&quot;&gt;http://localhost:8080/app1.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://usercontents.authing.cn/how-to-implement-sso/Untitled%202.png&quot; alt=&quot;https://usercontents.authing.cn/how-to-implement-sso/Untitled%202.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;然后点击「登录」，也就是访问 OIDC Provider 的&lt;strong&gt;授权接口&lt;/strong&gt;。然后我们来到了 OIDC Provider 交互环节，OIDC Provider 发现用户没有登录，要求用户先登录。node-oidc-provider demo 会放通任意用户名 + 密码，但是你在真正实施单点登录时，你必须使用你的&lt;strong&gt;用户目录&lt;/strong&gt;即&lt;strong&gt;中央数据表中的用户数据&lt;/strong&gt;来鉴权用户，相关的代码可能会涉及到&lt;a href=&quot;https://github.com/panva/node-oidc-provider/tree/master/docs#adapter&quot;&gt;数据库适配器&lt;/a&gt;，自定义&lt;a href=&quot;https://github.com/panva/node-oidc-provider/tree/master/docs#accounts&quot;&gt;用户查询逻辑&lt;/a&gt;，这些在 node-oidc-provider 包的相关配置中需要自行插入。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://usercontents.authing.cn/how-to-implement-sso/Untitled%203.png&quot; alt=&quot;https://usercontents.authing.cn/how-to-implement-sso/Untitled%203.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;现在点击「登录」，转到确权页面，这个页面会显示你的应用需要获取那些用户权限，本例中请求用户授权获取他的基础资料。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://usercontents.authing.cn/how-to-implement-sso/Untitled%204.png&quot; alt=&quot;https://usercontents.authing.cn/how-to-implement-sso/Untitled%204.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;点击「继续」，完成在 OP 的登录，之后 OP 会将浏览器重定向到预先设置的业务回调地址，所以我们又回到了 app1.html。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://usercontents.authing.cn/how-to-implement-sso/Untitled%205.png&quot; alt=&quot;https://usercontents.authing.cn/how-to-implement-sso/Untitled%205.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在 url query 中有一个 code 参数，这个参数就是临时授权码。code 最终对应一条用户信息，接下来看我们如何获取用户信息。&lt;/p&gt;

&lt;h2 id=&quot;web-app-从-oidc-provider-获取用户信息&quot;&gt;Web App 从 OIDC Provider 获取用户信息&lt;/h2&gt;

&lt;p&gt;事实上，code 可以直接发送到后端，然后在后端使用 code 换取 access_token。这里我使用 postman 演示如何通过 code 换取 access_token。&lt;/p&gt;

&lt;p&gt;你可以使用 curl 命令来发送 HTTP 请求：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;curl &lt;span class=&quot;nt&quot;&gt;--location&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--request&lt;/span&gt; POST &lt;span class=&quot;s1&quot;&gt;'http://localhost:3000/token'&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;--header&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'Content-Type: application/x-www-form-urlencoded'&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;--data-urlencode&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'client_id=1'&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;--data-urlencode&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'client_secret=1'&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;--data-urlencode&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'redirect_uri=http://localhost:8080/app2.html'&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;--data-urlencode&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'code=QL10pBYMjVSw5B3Ir3_KdmgVPCLFOMfQHOcclKd2tj1'&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;--data-urlencode&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'grant_type=authorization_code'&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://usercontents.authing.cn/how-to-implement-sso/Untitled%206.png&quot; alt=&quot;https://usercontents.authing.cn/how-to-implement-sso/Untitled%206.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;获取到 access_token 之后，我们可以使用 access_token 访问 OP 上面的资源，主要用于获取用户信息，即&lt;strong&gt;你的应用&lt;/strong&gt;从你的&lt;strong&gt;用户目录&lt;/strong&gt;中读取一条用户信息。&lt;/p&gt;

&lt;p&gt;你可以使用 curl 来发送 HTTP 请求：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;curl &lt;span class=&quot;nt&quot;&gt;--location&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--request&lt;/span&gt; POST &lt;span class=&quot;s1&quot;&gt;'http://localhost:3000/me'&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;--header&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'Content-Type: application/x-www-form-urlencoded'&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;--data-urlencode&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'access_token=I6WB2g0Rq9G307pPVTDhN5vKuyC9eWjrGjxsO2j6jm-'&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://usercontents.authing.cn/how-to-implement-sso/Untitled%207.png&quot; alt=&quot;https://usercontents.authing.cn/how-to-implement-sso/Untitled%207.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;到此，App 1 的登录已经完成，接下来，让我们看进入 App 2 是怎样的情形。&lt;/p&gt;

&lt;h2 id=&quot;登录第二个-web-app&quot;&gt;登录第二个 Web App&lt;/h2&gt;

&lt;p&gt;我们打开第二个应用，&lt;a href=&quot;http://localhost:8080/app2.html&quot;&gt;http://localhost:8080/app2.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;然后点击「登录」。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://usercontents.authing.cn/how-to-implement-sso/Untitled%208.png&quot; alt=&quot;https://usercontents.authing.cn/how-to-implement-sso/Untitled%208.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;用户已经在 App 1 登录时与 OP 建立了会话，User ←→ OP 已经是登录状态，所以 OP 检查到之后，没有再让用户输入登录凭证，而是直接将用户重定向回业务地址，并返回了授权码 code。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://usercontents.authing.cn/how-to-implement-sso/Untitled%209.png&quot; alt=&quot;https://usercontents.authing.cn/how-to-implement-sso/Untitled%209.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;同样，App 2 使用 code 换 access_token&lt;/p&gt;

&lt;p&gt;curl 命令代码：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;curl &lt;span class=&quot;nt&quot;&gt;--location&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--request&lt;/span&gt; POST &lt;span class=&quot;s1&quot;&gt;'http://localhost:3000/token'&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;--header&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'Content-Type: application/x-www-form-urlencoded'&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;--data-urlencode&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'client_id=1'&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;--data-urlencode&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'client_secret=1'&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;--data-urlencode&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'redirect_uri=http://localhost:8080/app2.html'&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;--data-urlencode&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'code=QL10pBYMjVSw5B3Ir3_KdmgVPCLFOMfQHOcclKd2tj1'&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;--data-urlencode&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'grant_type=authorization_code'&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://usercontents.authing.cn/how-to-implement-sso/Untitled%2010.png&quot; alt=&quot;https://usercontents.authing.cn/how-to-implement-sso/Untitled%2010.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;再使用 access_token 换用户信息，可以看到，是同一个用户。&lt;/p&gt;

&lt;p&gt;curl 命令代码：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;curl &lt;span class=&quot;nt&quot;&gt;--location&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--request&lt;/span&gt; POST &lt;span class=&quot;s1&quot;&gt;'http://localhost:3000/me'&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;--header&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'Content-Type: application/x-www-form-urlencoded'&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;--data-urlencode&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'access_token=I6WB2g0Rq9G307pPVTDhN5vKuyC9eWjrGjxsO2j6jm-'&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://usercontents.authing.cn/how-to-implement-sso/Untitled%2011.png&quot; alt=&quot;https://usercontents.authing.cn/how-to-implement-sso/Untitled%2011.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;到此，我们实现了 App 1 与 App 2 之间的账号打通与单点登录。&lt;/p&gt;

&lt;h2 id=&quot;登录态管理&quot;&gt;登录态管理&lt;/h2&gt;

&lt;p&gt;到目前为止，看起来还不错，我们已经实现了两个应用之间账号的统一，而且在 App 1 中登录时输入一次密码，在 App 2 中登录，无需再次让用户输入密码进行登录，可以直接返回授权码到业务地址然后完成后续的用户信息获取。&lt;/p&gt;

&lt;p&gt;现在我们来考虑一下退出问题&lt;/p&gt;

&lt;h3 id=&quot;只退出-app-1-而不退出-app-2&quot;&gt;只退出 App 1 而不退出 App 2&lt;/h3&gt;

&lt;p&gt;这个问题实质上是&lt;strong&gt;登录态的管理问题&lt;/strong&gt;。我们应该管理&lt;strong&gt;三个会话&lt;/strong&gt;：User ←→ App 1、User ←→ App 2、User ←→ OP。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://usercontents.authing.cn/how-to-implement-sso/Untitled%2012.png&quot; alt=&quot;https://usercontents.authing.cn/how-to-implement-sso/Untitled%2012.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;当 OP 给 App 1 返回 code 时，App 1 的后端在完成用户信息获取后，应该与浏览器建立会话，也就是说 App 1 与用户需要自己保持一套自己的登录状态，方式上可以通过 App 1 自签的 JWT Token 或 App 1 的 cookie-session。对于 App 2，也是同样的做法。&lt;/p&gt;

&lt;p&gt;当用户在 App 1 退出时，App 1 只需清理掉自己的登录状态就完成了退出，而用户访问 App 2 时，仍然和 App 2 存在会话，因此用户在 App 2 是登录状态。&lt;/p&gt;

&lt;h3 id=&quot;同时退出-app-1-和-app-2&quot;&gt;同时退出 App 1 和 App 2&lt;/h3&gt;

&lt;p&gt;刚才说到&lt;strong&gt;单点登录&lt;/strong&gt;，与之相对的就是&lt;strong&gt;单点登出&lt;/strong&gt;，即用户只需退出一次，就能在所有的应用中退出，变成未登录状态。&lt;/p&gt;

&lt;p&gt;最先想到的是这种方式，我们在 OIDC Provider 进行登出。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://usercontents.authing.cn/how-to-implement-sso/Untitled%2013.png&quot; alt=&quot;https://usercontents.authing.cn/how-to-implement-sso/Untitled%2013.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;之后我们的状态是这样的：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://usercontents.authing.cn/how-to-implement-sso/Untitled%2014.png&quot; alt=&quot;https://usercontents.authing.cn/how-to-implement-sso/Untitled%2014.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;好吧，其实没有任何效果，因为用户和 App 1 之间的会话依然保持，用户和 App 2 之间的会话同样依然保持，所以用户在 App 1 和 App 2 的状态仍然是登录态。&lt;/p&gt;

&lt;p&gt;所以，有没有什么办法在用户从 OIDC Provider 登出之后，App 1 和 App 2 的会话也被切断呢？我们可以通过 OIDC Session Mangement 来解决这个问题。&lt;/p&gt;

&lt;p&gt;简单来说，App 1 的前端需要轮询 OP，不断询问 OP：用户在你那还登录着吗？如果答案是否定的，App 1 主动将用户踢下线，并将会话释放掉，让用户重新登录，App 2 也是同样的操作。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://usercontents.authing.cn/how-to-implement-sso/Untitled%2015.png&quot; alt=&quot;https://usercontents.authing.cn/how-to-implement-sso/Untitled%2015.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;当用户在 OP 登出后，App 1、App 2 轮询 OP 时会收到用户已经从 OP 登出的响应，接下来，应该释放掉自己的会话状态，并将用户踢出系统，重新登录。&lt;/p&gt;

&lt;p&gt;刚刚我们提到 OIDC Session Management，这部分的核心就是两个 iframe，一个是我们自己应用中写的（以下叫做 RP iframe），用于不断发送 PostMessage 给 OP iframe，OP iframe 负责查询用户登录状态，并返回给 RP iframe。&lt;/p&gt;

&lt;p&gt;让我们把这部分的代码加上：&lt;/p&gt;

&lt;p&gt;首先打开 node-oidc-provider 的 sessionManangement 功能，编辑 &lt;code class=&quot;highlighter-rouge&quot;&gt;./support/configuration.js&lt;/code&gt; 文件，在 42 行附近，进行以下修改：&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;features&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;sessionManagement&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nl&quot;&gt;enabled&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;keepHeaders&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;然后和 app1.html、app2.html 平级新建一个 rp.html 文件，并加入以下内容：&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;script&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;stat&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'unchanged'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;url&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;URL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;window&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;location&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// 这里的 '1' 是我们的 client_id，之前在 node-oidc-provider 中填写的&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;mes&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'1'&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;' '&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;searchParams&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'session_state'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'mes: '&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;mes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;check_session&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;targetOrigin&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'http://localhost:3000'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;win&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;window&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;document&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;getElementById&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'op'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;contentWindow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;win&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;postMessage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;mes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;targetOrigin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;setTimer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;check_session&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;timerID&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;setInterval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'check_session()'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;nb&quot;&gt;window&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;addEventListener&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'message'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;receiveMessage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;setTimer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;receiveMessage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;targetOrigin&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'http://localhost:3000'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;origin&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;targetOrigin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;stat&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;stat&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'changed'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'should log out now!!'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/script&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在 app1.html 和 app2.html 中加入两个 iframe 标签：&lt;/p&gt;

&lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;iframe&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;src=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;rp.html&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;hidden&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&amp;lt;/iframe&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;iframe&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;src=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://localhost:3000/session/check&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;op&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;hidden&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&amp;lt;/iframe&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;使用 Ctrl + C 关闭我们的 node-oidc-provider 和 http-server，然后再次启动。访问 app1.html，打开浏览器控制台，会得到以下信息，这意味着，用户当前处于未登录状态，应该进行 App 自身会话的销毁等操作&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://usercontents.authing.cn/how-to-implement-sso/Untitled%2016.png&quot; alt=&quot;https://usercontents.authing.cn/how-to-implement-sso/Untitled%2016.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;然后我们点击「登录」，在 OP 完成登录之后，回调到 app1.html，此时用户变成了登录状态，注意地址栏多了一个参数：session_state，这个参数就是我们上文用于在代码中向 OP iframe 轮询时需要携带的参数。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://usercontents.authing.cn/how-to-implement-sso/Untitled%2017.png&quot; alt=&quot;https://usercontents.authing.cn/how-to-implement-sso/Untitled%2017.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;现在我们试一试单点登出，对于 node-oidc-provider 包提供的 OIDC Provider，只需要前端访问 &lt;a href=&quot;http://localhost:3000/session/end&quot;&gt;localhost:3000/session/end&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://usercontents.authing.cn/how-to-implement-sso/Untitled%2018.png&quot; alt=&quot;https://usercontents.authing.cn/how-to-implement-sso/Untitled%2018.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;收到来自 OP 的登出成功信息&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://usercontents.authing.cn/how-to-implement-sso/Untitled%2019.png&quot; alt=&quot;https://usercontents.authing.cn/how-to-implement-sso/Untitled%2019.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们转到 app1.html 看一下，此时控制台输出，用户已经登出，现在要执行会话销毁等操作了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://usercontents.authing.cn/how-to-implement-sso/Untitled%2020.png&quot; alt=&quot;https://usercontents.authing.cn/how-to-implement-sso/Untitled%2020.png&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;不想维护-app-1-与用户的登录状态app-2-与用户的登录状态&quot;&gt;不想维护 App 1 与用户的登录状态、App 2 与用户的登录状态&lt;/h3&gt;

&lt;p&gt;如果不各自维护 App 1、App 2 与用户的登录状态，那么无法实现只退出 App 1 而不退出 App 2 这样的需求。所有的登录状态将会完全依赖用户与 OP 之间的登录状态，在效果上是：用户在 OP 一次登录，之后访问所有的应用，都不必再输入密码，实现单点登录；用户在 OP 登出，则在所有应用登出，实现单点登出。&lt;/p&gt;

&lt;h1 id=&quot;使用-authing-解决单点登录&quot;&gt;使用 Authing 解决单点登录&lt;/h1&gt;

&lt;p&gt;以上就是一个完整的单点登录系统的轮廓，我们需要维护一份全体用户目录，进行用户注册、登录；我们需要自己搭建一个 OIDC Provider，并申请一个 OIDC Client；我们需要使用 code 换 token，token 换用户信息；我们需要在自己的应用中不断轮询 OP 的登录状态。&lt;/p&gt;

&lt;p&gt;读到这里，你可能会觉得实现一套完整的单点登录系统十分繁琐，不仅要对 OIDC 协议非常熟悉，还要自己架设 OIDC Provider，并且需要自行处理应用、用户、OP 之间登录状态。有没有开箱即用的登录服务呢？Authing 能够提供云上的 OP，云上的用户目录和直观的控制台，能够轻松管理所有用户、完成对 OP 的配置。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://usercontents.authing.cn/how-to-implement-sso/Untitled%2021.png&quot; alt=&quot;dashboard&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://usercontents.authing.cn/how-to-implement-sso/Untitled%2022.png&quot; alt=&quot;op&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Authing 对开发者十分友好，提供丰富的 SDK，进行快速集成。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://usercontents.authing.cn/how-to-implement-sso/Untitled%2023.png&quot; alt=&quot;sdk&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如果你不想关心登录的细节，将 Authing 集成到你的系统必定能够大幅提升开发效率，能够将更多的精力集中到核心业务上。&lt;/p&gt;

&lt;p&gt;欢迎体验：&lt;a href=&quot;https://authing.cn&quot;&gt;https://authing.cn&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;实现单点登录：&lt;a href=&quot;https://docs.authing.cn/authing/quickstart/implement-sso-with-authing&quot;&gt;https://docs.authing.cn/authing/quickstart/implement-sso-with-authing&lt;/a&gt;&lt;/p&gt;</content><author><name>叶祖伟</name></author><category term="OIDC" /><category term="SSO" /><category term="单点登录" /><summary type="html">如何通过OIDC协议实现单点登录</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://cdn.authing.cn/blog/20200403150326.png" /></entry><entry><title type="html">Authing 移动端登录方式, 10 行代码实现 App 扫码登录</title><link href="http://localhost:4000/blog/Authing%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%99%BB%E5%BD%95%E6%96%B9%E5%BC%8F/" rel="alternate" type="text/html" title="Authing 移动端登录方式, 10 行代码实现 App 扫码登录" /><published>2020-03-01T00:00:00+08:00</published><updated>2020-03-01T00:00:00+08:00</updated><id>http://localhost:4000/blog/Authing%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%99%BB%E5%BD%95%E6%96%B9%E5%BC%8F</id><content type="html" xml:base="http://localhost:4000/blog/Authing%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%99%BB%E5%BD%95%E6%96%B9%E5%BC%8F/">&lt;p&gt;Authing 新增四种移动端登录方式：移动应用微信登录、移动应用支付宝登录、App 拉起小程序登录、App 扫码登录。&lt;/p&gt;

&lt;p&gt;Authing 新增了对四种移动端登录方式的支持，可以让开发者在 Web 端、移动端、小程序端同时接入 Authing:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;移动应用微信登录&lt;/li&gt;
  &lt;li&gt;移动应用支付宝登录&lt;/li&gt;
  &lt;li&gt;App 拉起小程序登录&lt;/li&gt;
  &lt;li&gt;App 扫码登录&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/Authing/AuthingIOSDemo&quot;&gt;&lt;img src=&quot;https://cdn.authing.cn/blog/20200302110009.png&quot; height=&quot;600px&quot; style=&quot;align:center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;点击上图跳转到 GitHub Demo 页面。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;其中，「App 拉起小程序登录」指的是在 App 中，借助微信开放能力，唤起微信小程序「小登录」，获取用户微信授权进行登录。此方法可以获取到用户手机号。&lt;/p&gt;

&lt;p&gt;下面分别介绍一下如何快速接入这四种登录方式。&lt;/p&gt;

&lt;h1 id=&quot;app-拉起小程序登录&quot;&gt;App 拉起小程序登录&lt;/h1&gt;

&lt;p&gt;接入 App 拉起小程序登录，你需要做如下准备工作：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.authing.cn/authing/quickstart/create-authing-account&quot;&gt;注册 Authing 开发者账号&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://open.weixin.qq.com/cgi-bin/frame?t=home/app_tmpl&amp;amp;lang=zh_CN&quot;&gt;申请微信移动应用&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;私有化部署用户，需要在 Authing 控制台填入你的小程序信息。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.authing.cn/blog/20200302104816.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.authing.cn/blog/20200302104826.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;非私有化部署用户，需要将你的移动应用关联小登录。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;可在微信开放平台 “管理中心-移动应用-应用详情-关联小程序信息”，为通过审核的移动应用发起关联小程序操作。小登录的 AppID 为 &lt;code class=&quot;highlighter-rouge&quot;&gt;wxa0435021fd7a3af2&lt;/code&gt; .&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.authing.cn/blog/20200302104734.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在你做好这些准备工作之后，先使用微信 SDK 拉起小程序(具体的接入流程请见&lt;a href=&quot;https://developers.weixin.qq.com/doc/oplatform/Mobile_App/Launching_a_Mini_Program/Launching_a_Mini_Program.html&quot;&gt;微信官方文档&lt;/a&gt;):&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;小程序 userName 为 gh_a781a791e29e&lt;/li&gt;
  &lt;li&gt;path 为 &lt;code class=&quot;highlighter-rouge&quot;&gt;/routers/explore&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;path query 参数为：
    &lt;ul&gt;
      &lt;li&gt;userPoolId: 你的用户池 ID&lt;/li&gt;
      &lt;li&gt;getPhone: 是否需要获取用户手机号，1 表示需要，不填或者其他表示不需要&lt;/li&gt;
      &lt;li&gt;fromApp: 1，此参数必填。&lt;/li&gt;
      &lt;li&gt;useSelfWxapp: 此参数必填。私有化用户填 1，非私有化用户填 0.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下面是 Swift 代码示例：&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;userPoolId&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;5e4cdd055df3df65dc58b97d&quot;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;req&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;WXLaunchMiniProgramReq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;req&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;userName&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;gh_a781a791e29e&quot;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;req&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;path&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;/routes/explore?userPoolId=&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;userPoolId&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;amp;getPhone=1&amp;amp;fromApp=1&amp;amp;useSelfWxapp=0&quot;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;req&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;miniProgramType&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;WXMiniProgramType&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;release&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;WXApi&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;send&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;req&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;用户同意授权之后，会携带 &lt;code class=&quot;highlighter-rouge&quot;&gt;ticket&lt;/code&gt; 跳回你的 App，之后你可以使用此 ticket 换取用户信息：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;POST https://oauth.authing.cn/oauth/app2wxapp/auth/:userPoolId&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Path 参数 userPoolId: 你的 Authing 用户池 ID。&lt;/li&gt;
  &lt;li&gt;Post Body 参数:
    &lt;ul&gt;
      &lt;li&gt;ticket: 得到的 ticket&lt;/li&gt;
      &lt;li&gt;secret: 用户池密钥。默认情况下，出于安全考虑，ticket 换取用户信息需要提供用户池密钥，这意味着不能直接在 App 内直接换取用户信息。开发者可以在用户池基础配置页面修改此选项：&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.authing.cn/blog/20200302105735.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;下面是演示示例：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.authing.cn/blog/app2wxapp.gif&quot; height=&quot;600px&quot; style=&quot;align:center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;此方式可以获取用户手机号。你可以扫描下方的小程序二维码体验一下「小登录」：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.authing.cn/blog/20200302103133.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;如果你想私有化部署自己的小程序，可以联系我们。手机号：18616699123。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;详细接入流程请见：&lt;a href=&quot;https://docs.authing.cn/authing/social-login/miniprogram/app2wxapp&quot;&gt;接入APP 拉起小程序登录&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;app-扫码登录&quot;&gt;App 扫码登录&lt;/h1&gt;

&lt;p&gt;和其他三种登录方式不同，你不需要做任何准备工作。同时，我们提供 Web 端的 SDK，可以让你在 Web 端使用 10 行代码实现一个完整的扫码登录表单：&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Authing&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'authing-js-sdk'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 初始化 Authing SDK for JavaScript&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;authing&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Authing&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;userPoolId&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'YOUR_USERPOOL_ID'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 调用 APP 扫码登录的方法，此方法将生成一个用于扫码登录的图片和相关提示信息&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;authing&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;qrlogin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;startScanning&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;onSuccess&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;ticket&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;userInfo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 存储 token 到 localStorage 中&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;localStorage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;setItem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'token'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;userInfo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;token&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.authing.cn/blog/扫码登录.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;That’s it! 就这么简单!&lt;/p&gt;

&lt;p&gt;下面是 startScanning 支持的完整参数，你可以掌控扫码登录的所有流程，实现高度自定义：&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;authing&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;qrlogin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;startScanning&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;mount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;''&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 可选，二维码挂载点，如不写则默认漂浮在文档中间&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;interval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 可选，轮询间隔时间，默认为 800 ms &lt;/span&gt;

    &lt;span class=&quot;na&quot;&gt;onPollingStart&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;intervalNum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{},&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;onResult&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{},&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;onScanned&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;userInfo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{},&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;onSuccess&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;ticket&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;userInfo&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;onCancel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{},&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;onExpired&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{},&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;onError&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{},&lt;/span&gt;

    &lt;span class=&quot;na&quot;&gt;onQRCodeShow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;qrcode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{},&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;onQRCodeLoad&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;qrcode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{},&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;onQRCodeLoadFaild&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{},&lt;/span&gt;
    
    &lt;span class=&quot;na&quot;&gt;tips&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'使用 &amp;lt;strong&amp;gt; APP &amp;lt;/strong&amp;gt; 扫码登录'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;scannedTips&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'用户已扫码，等待确认'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;canceledTips&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'用户取消授权'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;expiredTips&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'二维码已过期'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;successTips&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'扫码成功'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;retryTips&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'重试'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;failedTips&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'网络出错，请重试'&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;参数&lt;/th&gt;
      &lt;th&gt;可选/必选&lt;/th&gt;
      &lt;th&gt;说明&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;mount&lt;/td&gt;
      &lt;td&gt;可选&lt;/td&gt;
      &lt;td&gt;挂载点 Dom ID，如不写则默认漂浮在文档中间。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;interval&lt;/td&gt;
      &lt;td&gt;可选&lt;/td&gt;
      &lt;td&gt;轮询时间间隔，单位为 ms，默认为 800 ms。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;onPollingStart&lt;/td&gt;
      &lt;td&gt;可选&lt;/td&gt;
      &lt;td&gt;轮询开始时会被回调，只会回调一次。回调参数 intervalNum 为 setInterval 返回的数值，可使用 clearInterval 停止轮询。如：clearInterval(intervalNum)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;onResult&lt;/td&gt;
      &lt;td&gt;可选&lt;/td&gt;
      &lt;td&gt;每次查询获取到数据都会回调&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;onScanned&lt;/td&gt;
      &lt;td&gt;可选&lt;/td&gt;
      &lt;td&gt;用户扫码时会被回调，只会回调一次。回调参数 userInfo 只包含了用户昵称和头像，开发者可以将其展示在扫码框中。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;onSuccess&lt;/td&gt;
      &lt;td&gt;可选&lt;/td&gt;
      &lt;td&gt;用户同意授权之后将会被回调，只会回调一次，之后轮询结束。参数 data 是一个字典，包含两个字段：ticket 和 userInfo。出于安全性考虑，默认情况下，userInfo 只会包含昵称（nickname）和头像（photo）两个字段，开发者也可以在后台配置使其返回完整用户信息，详情见自定义配置。 ticket 可以用来换取完整的用户信息，相关接口见下文。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;onCancel&lt;/td&gt;
      &lt;td&gt;可选&lt;/td&gt;
      &lt;td&gt;用户取消授权只会会被回调，只回调一次，之后轮询结束。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;onExpired&lt;/td&gt;
      &lt;td&gt;可选&lt;/td&gt;
      &lt;td&gt;二维码失效时被回调，只回调一次，之后轮询结束。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;onError&lt;/td&gt;
      &lt;td&gt;可选&lt;/td&gt;
      &lt;td&gt;每次查询失败时都会回调。回调参数 data 示例如 {“code”: 2241,”message”: “二维码不存在”,”data”: null}。完整错误代码请见完整错误代码页。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;onQRCodeLoad&lt;/td&gt;
      &lt;td&gt;可选&lt;/td&gt;
      &lt;td&gt;二维码首次成功加载时回调。回调参数 qrcode 是一个字典，包含两个字段：qrcodeId、qrcodeUrl。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;onQRCodeShow&lt;/td&gt;
      &lt;td&gt;可选&lt;/td&gt;
      &lt;td&gt;二维码首次出现在页面上时回调。回调参数 qrcode 同上。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;onQRCodeLoadFaild&lt;/td&gt;
      &lt;td&gt;可选&lt;/td&gt;
      &lt;td&gt;二维码加载失败时会被回调。&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;在移动端，开发者可以调用 iOS/Android 相关接口解析二维码，二维码包含原始数据如下：&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;s2&quot;&gt;&quot;scene&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;APP_AUTH&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;s2&quot;&gt;&quot;qrcodeId&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;5e05f0c57fde537d950f7da5&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;s2&quot;&gt;&quot;userPoolId&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;5e04ae0d5f3cee22fb37612b&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;s2&quot;&gt;&quot;createdAt&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;2019-12-27T11:53:41.260Z&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;s2&quot;&gt;&quot;expireAt&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;2019-12-27T11:55:41.260Z&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;s2&quot;&gt;&quot;userDefinedData&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;hello&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;world&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;scene: 二维码场景值，APP_AUTH 表示 APP 扫码登录。&lt;/li&gt;
  &lt;li&gt;qrcodeId: 二维码 ID。&lt;/li&gt;
  &lt;li&gt;qrcodeId: 用户池 ID。&lt;/li&gt;
  &lt;li&gt;userDefinedData: 用户自定义数据。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;接着可以调用 Authing API，进行标记已扫码、同意授权、取消授权操作，如同意授权的 API 如下：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;POST https://oauth.authing.cn/oauth/scan-qrcode/confirm&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;请求头 Authorization: 已登录用户的 token&lt;/li&gt;
  &lt;li&gt;Body 参数 qrcodeId: 二维码 ID。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以下是一个对应的 Swift 代码示例：&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Alamofire&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;confirmQRLogin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;qrcodeId&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;api&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;https://oauth.authing.cn/oauth/scan-qrcode/confirm&quot;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;headers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;HTTPHeaders&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot;Authorization&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;&amp;lt;USER_TOKEN&amp;gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot;Accept&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;application/json&quot;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Body&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Encodable&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;qrcodeId&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;body&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Body&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;qrcodeId&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;qrcodeId&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;AF&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;api&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;nv&quot;&gt;method&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;post&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;nv&quot;&gt;parameters&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;body&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;nv&quot;&gt;headers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;headers&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;responseString&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;response&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt;
        
        &lt;span class=&quot;c1&quot;&gt;// 将 response.value 转化成字符串，示例如下：&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// [&quot;code&quot;: 200, &quot;message&quot;: &quot;二维码扫描确认成功&quot;, data: &quot;&quot; ]&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;resp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;convertToDictionary&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;text&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;response&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;code&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;resp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;code&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as!&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;code&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;200&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;nf&quot;&gt;debugPrint&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;确认授权失败: &quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;resp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;详细接入方式请见：&lt;a href=&quot;https://docs.authing.cn/authing/scan-qrcode/app-qrcode&quot;&gt;接入 App 扫码登录&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;微信登录与支付宝登录&quot;&gt;微信登录与支付宝登录&lt;/h1&gt;

&lt;p&gt;接入移动应用微信登录和支付宝登录，你需要做如下准备工作：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.authing.cn/authing/quickstart/create-authing-account&quot;&gt;注册 Authing 开发者账号&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;申请微信、支付宝移动应用&lt;/li&gt;
  &lt;li&gt;在 Authing 控制台填入微信、支付宝移动应用信息&lt;/li&gt;
  &lt;li&gt;接入微信、支付宝移动端 SDK&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在你做好这些准备工作之后，先使用微信/支付宝 SDK 拉起微信/支付宝，用户同意授权之后，你会得到一个 code。此 code 可通过 Authing 的接口换取用户信息。&lt;/p&gt;

&lt;p&gt;以微信登录 API 为例：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;GET https://oauth.authing.cn/oauth/wechatmobile/auth/:userPoolId?code=&amp;lt;YOUR_CODE&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;path 参数 userPoolId: 你的用户池 ID。&lt;/li&gt;
  &lt;li&gt;query 参数 code: 拉起微信得到的 code。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下面是 Swift 示例代码：&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Alamofire&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;url&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;https://oauth.authing.cn/oauth/wechatmobile/auth/&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;UserPoolId&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;?code=&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;code&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;AF&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;responseString&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;response&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;debugPrint&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Response: &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;response&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;详细的接入流程请见：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.authing.cn/authing/social-login/mobile/wechat&quot;&gt;接入移动应用微信登录&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.authing.cn/authing/social-login/mobile/alipay&quot;&gt;接入移动应用支付宝登录&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;获取用户信息之后&quot;&gt;获取用户信息之后&lt;/h1&gt;

&lt;p&gt;获取到用户信息之后，你可以得到登录凭证 token，你可以在后续的 API 请求中携带上此 token, 然后在后端接口中根据此 token 区分不同用户。&lt;/p&gt;

&lt;p&gt;设置 Authorization 请求头为 “Bearer “ + token, 例如：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Authorization: &quot;Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJkYXRhIjp7InVuaW9uaWQiOiJvaVBiRHVHNFM3bXNyS0hQS0RjOE1FQ1NlOGpNIiwiaWQiOiI1ZGMxMGJjYjZmOTRjMTc4YzZmZmZmYjkiLCJjbGllbnRJZCI6IjVkYTdlZGFiNTAzOTZjMWFkOTYyMzc4YSJ9LCJpYXQiOjE1NzI5NTY0MjUsImV4cCI6MTU3NDI1MjQyNX0.OTgl72WZS8So3R5DbWCJ7I_Bd0LaZa4S0TAVMg9qaYQ&quot;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;如果你使用的是 Swift 的 Alamofire, 可以这样写：&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;api&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;YOUR_SERVICE_URL&quot;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;headers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;HTTPHeaders&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&quot;Authorization&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;&amp;lt;USER_TOKEN&amp;gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&quot;Accept&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;application/json&quot;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;body&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Body&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;qrcodeId&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;qrcodeId&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;AF&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;api&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;nv&quot;&gt;method&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;post&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;nv&quot;&gt;headers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;headers&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;responseString&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;response&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt;
  &lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;response&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;你可以在后端调用 Authing 的 API 验证通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;Authorization&lt;/code&gt; 判断该用户是否具备相关权限。&lt;/p&gt;

&lt;p&gt;详情请见&lt;a href=&quot;https://docs.authing.cn/authing/advanced/verify-jwt-token&quot;&gt;验证 token&lt;/a&gt;。&lt;/p&gt;

&lt;h1 id=&quot;总结&quot;&gt;总结&lt;/h1&gt;

&lt;p&gt;你可以在这个 GitHub 项目找到完整的示例代码：&lt;a href=&quot;https://github.com/Authing/AuthingIOSDemo&quot;&gt;https://github.com/Authing/AuthingIOSDemo&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;以下是 Authing 目前支持的社会化登录方式，国内主流的第三方身份提供商目前都已经支持了:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.authing.cn/blog/20200302112935.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;同时我们接下来会继续不断完善，让有身份认证的地方就有 Authing !&lt;/p&gt;</content><author><name>cj</name></author><category term="移动端" /><category term="社会化登录" /><summary type="html">Authing 新增四种移动端登录方式：移动应用微信登录、移动应用支付宝登录、App 拉起小程序登录、App 扫码登录。</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://cdn.authing.cn/blog/20200302113736.png" /></entry><entry><title type="html">#ShapeIdentity 001 期：国产 Serverless Identity 开源组件工作坊</title><link href="http://localhost:4000/blog/%E5%9B%BD%E4%BA%A7-Serverless-Identity-%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6%E5%B7%A5%E4%BD%9C%E5%9D%8A/" rel="alternate" type="text/html" title="#ShapeIdentity 001 期：国产 Serverless Identity 开源组件工作坊" /><published>2020-02-27T00:00:00+08:00</published><updated>2020-02-27T00:00:00+08:00</updated><id>http://localhost:4000/blog/%E5%9B%BD%E4%BA%A7-Serverless-Identity-%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6%E5%B7%A5%E4%BD%9C%E5%9D%8A</id><content type="html" xml:base="http://localhost:4000/blog/%E5%9B%BD%E4%BA%A7-Serverless-Identity-%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6%E5%B7%A5%E4%BD%9C%E5%9D%8A/">&lt;p&gt;我们发起 &lt;strong&gt;# Shape Identity 系列线上技术公开课，旨在倡议：在阻击物理世界「新冠」病毒的同时，不要忽视数字空间的安全。&lt;/strong&gt;我们将定期邀请业界 Identity 专家一起探讨 Identity 技术的发展！主题涵盖：IDaaS/IAM、Serverless、ZeroTrust、Cloud Native 等开源技术。第一期本周六，2月29日，四年独一无二的日子，本次线上直播 Authing 联合腾讯云、Serverless Framework中文社区，与大家共同探讨：Serverless Framework 组件的开发及应用。&lt;/p&gt;

&lt;p&gt;疫情肆虐，不仅对老百姓生命健康造成重大威胁，对各行各业的发展也造成重大影响。同时，开学、复工在即，疫情防控进入了关键阶段，「居家隔离、远程办公」是当下遏制疫情扩散的最佳防控措施。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.authing.cn/blog/flu.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;1918年的西班牙流感席卷全球的模拟&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;2019 新型冠状病毒（2019-nCoV）使得中国一夜之间成了「全球最大的远程办公数字社会」，但是如此大规模的，敦刻尔克式的“数字化转型”，对「企业协同」、「企业 VPN 性能及安全性」、网络信息安全迎来重要考验， 也难免会出现大量次生安全问题，尤其在春节假期延长，大量企事业单位启动「远程办公」，原本在防火墙内，使用公司设备办公的员工，使用家用 PC 开始办公，并通过公共 WiFi 访问企业内部的数据和应用时，&lt;strong&gt;企业网络安全部门面临着空前的安全威胁，其中，「身份安全」是至关重要的一环。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;于是，我们发起 &lt;strong&gt;# Shape Identity 系列线上技术公开课，旨在倡议：在阻击物理世界「新冠」病毒的同时，不要忽视数字空间的安全。&lt;/strong&gt;我们将定期邀请业界 Identity 专家一起探讨 Identity 技术的发展！主题涵盖：IDaaS/IAM、Serverless、ZeroTrust、Cloud Native 等开源技术。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;第 001 期，定在本周六，2月29日，四年独一无二的日子，也是 2020年的第60天。&lt;/strong&gt;
本次线上直播 Authing 联合腾讯云、Serverless Framework中文社区，与大家共同探讨：Serverless Framework 组件的开发及应用。本周六（2020-02-29 ）13:00——17:00，&lt;strong&gt;通过「腾讯会议」 300人在线分享及 Q&amp;amp;A 视频互动、B站直播弹幕互动，&lt;/strong&gt; 参与互动将送出「腾讯云」赞助纪念品。&lt;/p&gt;

&lt;p&gt;近些年 Serverless 风起云涌，它正在深刻的改变未来软件开发的模式和流程，对于大多数应用而言，借助 Serverless 服务，开发者可以将绝大多数精力投入在业务逻辑的开发整合上，大大缩短开发周期，降低运维成本。Serverless Framework 当属时下最火热的开源框架。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.authing.cn/blog/20200225160838.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;主持人：晋剑  Authing 联合创始人兼COO&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;一如何开发自己的第一个-serverless-component&quot;&gt;一、如何开发自己的第一个 Serverless Component？&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.authing.cn/blog/20200225160933.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;陈涛：Serverless Framework 社区专家&lt;/strong&gt;
参与 Serverless 社区及开源的相关研发工作。拥有丰富前端、JavaScript 技术经验，以及网站及小程序等项目开发经验，腾讯云 Serverless 系列课程特约讲师。
&lt;strong&gt;内容简介：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Serverless Component 运行机制&lt;/li&gt;
  &lt;li&gt;Serverless Component 开发步骤（功能需求，组建配置）&lt;/li&gt;
  &lt;li&gt;Serverless Component 组件开发（default 函数，remove 函数）&lt;/li&gt;
  &lt;li&gt;Serverless Component 运行，调试与发布&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;二authing-是如何开发-serverless-oidc-组件&quot;&gt;二、Authing 是如何开发 Serverless-OIDC 组件？&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.authing.cn/blog/20200225161143.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;高鹏洋：Authing 全栈工程师&lt;/strong&gt;
曾就职于中科红旗，负责容器云研发。曾参与中国移动 HA 系统研发，CNCF 贡献者，郑州 TFUG 组织者。热爱创造，喜欢探索未知，乐于与人交流，是一名 Acmer 。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;内容简介：&lt;/strong&gt;
OIDC 是 OAuth 2.0 的超集，同时是 Authing 推荐的身份认证最佳实践。在没有 Serverless 的情况下，开发者需要架设一个服务器用来在后端处理 OIDC code 换 Token 和 Token 换用户信息的流程，有了 Serverless 之后，开发者不需要编写任何路由就可以获取用户信息。本次主题将分享如何通过使用腾讯提供的 SCF 和 API 网关 Serverless Component 来快速创造一个 由多个原生 SCF 组成的  Serverless Component：https://github.com/Authing/serverless-oidc &lt;/p&gt;

&lt;h3 id=&quot;三基于serverless-framework和oidc-组件设计一个图床应用&quot;&gt;三、基于Serverless Framework和OIDC 组件设计一个图床应用&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.authing.cn/blog/20200225162249.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;谢扬：Authing 创始人，SoLiD 中文社区（learnsolid.cn）发起人&lt;/strong&gt;
曾任职字节跳动 LarkCloud 云服务部门核心 Hacker，负责⽇活过亿 Serverless 平台产品设计和技术研发，该平台支撑来头条系全产品矩阵：今日头条、抖音、西瓜视频、飞书等。 ⻓期关注生产⼒科技，以提⾼社会生产⼒为个⼈使命。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;内容简介：&lt;/strong&gt;
基于 Serverless Framework 和 Authing 完成一个可以共享和配置访问权限的图床管理应用。&lt;/p&gt;

&lt;h3 id=&quot;四线上自由-q--a-环节&quot;&gt;四、线上自由 Q &amp;amp; A 环节&lt;/h3&gt;

&lt;h3 id=&quot;火速扫码报名&quot;&gt;火速扫码报名&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.authing.cn/blog/20200225162025.png&quot; style=&quot;zoom: 30%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;火速扫码，回复 “ID”入群
抢占「腾讯会议」 席位，仅300席
&lt;code class=&quot;highlighter-rouge&quot;&gt;提示：尽量提前下载安装「腾讯会议」客户端，群内获取会议链接&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;其他朋友们也可通过B站直播链接参与互动&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.authing.cn/blog/20200225161910.png&quot; style=&quot;zoom: 50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Authing Live 直播间（https://live.bilibili.com/4850077 ）&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.authing.cn/blog/tencent.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;相关阅读&quot;&gt;相关阅读&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/qVlqwA2ZhZeKsl0RdVsojQ&quot;&gt;Authing 的故事：我为什么开发 Authing？&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/WGL7n9D1L0UG71276Wn6Iw&quot;&gt;如何在远程办公中保持高效的&lt;/a&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/WGL7n9D1L0UG71276Wn6Iw&quot;&gt;研发效率？&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/KkUhNuXnrsWa5Q-ucmIlqA&quot;&gt;一份普通人能理解的关于 Authing 的介绍&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/TlYmDRg1q_glJ7Icsj0arw&quot;&gt;Authing 是什么以及为什么需要 Authing？&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/TlYmDRg1q_glJ7Icsj0arw&quot;&gt;为什么身份认证值得上云？&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/6SsGcgoesVGaLT19auK7yg&quot;&gt;Authing &lt;/a&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/6SsGcgoesVGaLT19auK7yg&quot;&gt;@ 2019 总结&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/Xd3SR2WaB15a250RxEZWpg&quot;&gt;Authing 开发资源最全合集&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;重磅：Authing 将于2020 Q1 开源，欢迎&lt;/strong&gt;  &lt;a href=&quot;https://github.com/Authing/authing&quot;&gt;Star 关注&lt;/a&gt;&lt;/p&gt;</content><author><name>jackjin</name></author><category term="ShapeIdentity" /><category term="Serverless" /><category term="OIDC" /><summary type="html">我们发起 # Shape Identity 系列线上技术公开课，旨在倡议：在阻击物理世界「新冠」病毒的同时，不要忽视数字空间的安全。我们将定期邀请业界 Identity 专家一起探讨 Identity 技术的发展！主题涵盖：IDaaS/IAM、Serverless、ZeroTrust、Cloud Native 等开源技术。第一期本周六，2月29日，四年独一无二的日子，本次线上直播 Authing 联合腾讯云、Serverless Framework中文社区，与大家共同探讨：Serverless Framework 组件的开发及应用。</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://cdn.authing.cn/blog/tencent.jpeg" /></entry><entry><title type="html">Introduce Pipeline: Authing 的可扩展性达到了新高度</title><link href="http://localhost:4000/blog/Introduce-Authing-Pipeline/" rel="alternate" type="text/html" title="Introduce Pipeline: Authing 的可扩展性达到了新高度" /><published>2020-02-20T00:00:00+08:00</published><updated>2020-02-20T00:00:00+08:00</updated><id>http://localhost:4000/blog/Introduce-Authing-Pipeline</id><content type="html" xml:base="http://localhost:4000/blog/Introduce-Authing-Pipeline/">&lt;p&gt;Authing Pipeline 是一组运行在云端的用户自定义 JavaScript 代码，属于 Authing 扩展能力的重要部分，可以让开发者无限制扩展、自定义 Authing 的能力。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.authing.cn/blog/20200220202545.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;演示&quot;&gt;演示&lt;/h2&gt;

&lt;p&gt;开始具体介绍之前，我们先看一下 Pipeline 的使用效果。&lt;/p&gt;

&lt;h3 id=&quot;使用-pipeline-开启注册白名单&quot;&gt;使用 Pipeline 开启注册白名单&lt;/h3&gt;

&lt;p&gt;此示例我们创建了一个 Pipeline 函数，此函数只允许邮箱后缀为 &lt;code class=&quot;highlighter-rouge&quot;&gt;@authing.cn&lt;/code&gt; 的用户注册。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog/assets/images/pipeline/1.gif&quot; alt=&quot;assets/images/pipeline/1.gif&quot; /&gt;&lt;/p&gt;

&lt;p&gt;再由下图可得：邮箱 test@qq.com 注册失败，并且返回了 Access Denied! 提示，而 test@authing.cn 邮箱注册成功。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog/assets/images/pipeline/2.gif&quot; alt=&quot;assets/images/pipeline/2.gif&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;使用-pipline-推送飞书群通知&quot;&gt;使用 Pipline 推送飞书群通知&lt;/h3&gt;

&lt;p&gt;此示例创建了一个用户注册之后发送飞书群通知的 Pipeline 函数，飞书群 webhook 通过环境变量读取。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog/assets/images/pipeline/3.gif&quot; alt=&quot;assets/images/pipeline/3.gif&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog/assets/images/pipeline/4.gif&quot; alt=&quot;assets/images/pipeline/4.gif&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;使用-pipeline-自定义-token&quot;&gt;使用 Pipeline 自定义 Token&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/blog/assets/images/pipeline/5.gif&quot; alt=&quot;assets/images/pipeline/5.gif&quot; /&gt;&lt;/p&gt;

&lt;p&gt;使用 authing-js-sdk 验证效果，可以看到用户的  token 中有了对应的字段和值。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog/assets/images/pipeline/6.gif&quot; alt=&quot;assets/images/pipeline/6.gif&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Pipeline 的运行架构图如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.authing.cn/blog/20200220203521.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如上可知，Pipeline 作为一组函数，整个流程中的函数数据可以相互传递，实现工业流水线一样的效果。这种设计模式，可以使得开发者的自定义函数更加模块化，便于管理。&lt;/p&gt;

&lt;p&gt;同时我们还提供了&lt;a href=&quot;https://github.com/authing/pipeline&quot;&gt;丰富的函数模版&lt;/a&gt;，帮助开发者快速上手开发。&lt;/p&gt;

&lt;p&gt;Authing Pipeline 后端使用  Serverless 架构，所有的用户自定义代码均运行在云端，保证不同租户之间的隔离性，同时能弹性伸缩，既保证了安全性，又提升了运行效率。&lt;/p&gt;

&lt;h2 id=&quot;应用场景&quot;&gt;应用场景&lt;/h2&gt;

&lt;p&gt;借助 Authing Pipeline，开发者可以实现以下功能：
‌&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;白名单机制&lt;/strong&gt;：如注册邮箱域名白名单、注册 IP 白名单、手机号白名单等。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;事件通知&lt;/strong&gt;：如用户注册之后发送通知到钉钉、飞书或 Slack 中。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;权限控制&lt;/strong&gt;：如用户登录之后根据邮箱将其加入某用户组等。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;扩展用户字段&lt;/strong&gt;：如往修改默认头像、添加自定义 metadata、加入身份证号等。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;自定义 token&lt;/strong&gt;：如往 token 中加入自定义字段、删除自定义字段等。&lt;/li&gt;
  &lt;li&gt;… 还有更多，想象空间是无穷的。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;接下来，我们一起看看如何创建一个 Pipeline 函数。&lt;/p&gt;

&lt;h2 id=&quot;创建第一个-pipeline-函数&quot;&gt;创建第一个 Pipeline 函数&lt;/h2&gt;

&lt;p&gt;创建 Pipeline 函数之前，你需要拥有一个 &lt;a href=&quot;https://authing.cn/&quot;&gt;Authing 开发者账号&lt;/a&gt;，注册之后在控制台中依次点击 &lt;strong&gt;用户池&lt;/strong&gt; -&amp;gt; &lt;strong&gt;扩展能力&lt;/strong&gt; -&amp;gt; &lt;strong&gt;自定义 Pipeline&lt;/strong&gt; 页面，你会看到如下提示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.authing.cn/blog/20200220203747.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;点击右上角 “创建 Pipeline 函数“，选择一个函数模版用来开发：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.authing.cn/blog/20200220203802.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在本示例中，我们选择访问控制模版中的「注册邮箱域名白名单」。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;P.S. 示例中设置的域名白名单是 「example.com」，你也可以改成自己的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.authing.cn/blog/20200220203824.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;点击左下角的“保存“按钮，我们会将此函数部署到云端，需要一定时间，请耐心等待。&lt;/p&gt;

&lt;p&gt;回到  Pipeline 函数列表页面，可以看到我们刚刚添加的那个函数。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.authing.cn/blog/20200220203841.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;接下来我们验证一下此注册白名单是否有效：&lt;/p&gt;

&lt;p&gt;这里我们使用 Authing 提供的表单进行登录，进入&lt;strong&gt;用户池&lt;/strong&gt; -&amp;gt; &lt;strong&gt;社会化登录&lt;/strong&gt; -&amp;gt; &lt;strong&gt;OIDC 应用&lt;/strong&gt;页面，你可以看到你的所有 OIDC 应用。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.authing.cn/blog/20200220203905.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;点击右边第一个按钮 「体验登录」，你会跳转到 Authing 的登录表单页面。&lt;/p&gt;

&lt;p&gt;首先我们使用非 example.com 后缀的邮箱注册，看到返回了「&lt;strong&gt;Access Denied&lt;/strong&gt;」 提示，这是我们默认指定的提示信息。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.authing.cn/blog/20200220203929.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;之后再使用后缀为 example.com 的邮箱注册，注册成功，如下所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.authing.cn/blog/20200220203940.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;由此可见，使用 Authing 的 Pipeline 可以帮助你不受限制的拓展 Authing 的能力。&lt;/p&gt;

&lt;h2 id=&quot;开发和调试&quot;&gt;开发和调试&lt;/h2&gt;

&lt;p&gt;在 Pipeline 函数中，开发者可以获取到几乎所有有关此次认证的数据，包括用户资料、IP、地理位置、认证方式、用户池配置等。&lt;/p&gt;

&lt;p&gt;为了方便 Pipeline 的开发和调试，Authing 精心准备了以下工具供开发者使用。&lt;/p&gt;

&lt;h3 id=&quot;1-函数模版&quot;&gt;1. 函数模版&lt;/h3&gt;

&lt;p&gt;Authing Pipeline 提供了&lt;a href=&quot;https://github.com/authing/pipeline&quot;&gt;丰富的函数模版&lt;/a&gt; 供开发者选择以满足不同的场景，且列表还在不断增加中，同时也欢迎你为我们&lt;a href=&quot;https://github.com/authing/pipeline/blob/master/CONTRIBUTING.md&quot;&gt;贡献模版&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.authing.cn/blog/20200220204056.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;2-工具函数&quot;&gt;2. 工具函数&lt;/h3&gt;

&lt;p&gt;在 Pipeline 函数中，可以直接使用 Authing SDK ！这意味着你在 Pipeline 中具备了所有 Authing 已有能力！除了 authing-js-sdk，我们还内置了一些其他的 node modules 以及工具函数，方便开发者调用，&lt;a href=&quot;https://docs.authing.cn/authing/extensibility/pipeline/available-node-modules&quot;&gt;点此了解更多&lt;/a&gt;。&lt;/p&gt;

&lt;h3 id=&quot;3-环境变量&quot;&gt;3. 环境变量&lt;/h3&gt;
&lt;p&gt;在 Pipeline 函数中，可以通过环境变量的方式保持链接、密钥等数据，避免硬编码，环境变量的增加方式如下所图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.authing.cn/blog/20200220204139.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在 Pipeline 函数中读取环境变量的方法为：&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;webhook&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;env&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;LARK_WEBHOOK&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这里的 env 是一个全局变量，LARK_WEBHOOK 是存储的一个环境变量值，&lt;a href=&quot;https://docs.authing.cn/authing/extensibility/pipeline/env&quot;&gt;点击&lt;/a&gt;了解更多关于环境变量的信息。&lt;/p&gt;

&lt;h3 id=&quot;4-调试代码&quot;&gt;4. 调试代码&lt;/h3&gt;

&lt;p&gt;Authing Pipeline 支持在线调试，如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.authing.cn/blog/20200220204235.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;此外，还支持查询 log 日志：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.authing.cn/blog/20200220204251.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;有关更多调试窗口的使用方法请见&lt;a href=&quot;https://docs.authing.cn/authing/extensibility/pipeline/how-to-debug&quot;&gt;如何调试 Authing Pipeline 函数&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;Authing Pipeline 使 Authing 的扩展能力达到了新的高度，借助于此，开发者可以毫无限制的扩展 Authing 的能力，我们迫不及待的想知道你以什么样的方式拓展 Authing 的能力！&lt;/p&gt;

&lt;h2 id=&quot;参考资料&quot;&gt;参考资料&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.authing.cn/authing/extensibility/pipeline/write-your-first-pipeline-function&quot;&gt;创建你的第一个 Pipeline 函数&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.authing.cn/authing/extensibility/pipeline/pipeline-function-api-doc&quot;&gt;了解 Authing Pipeline 函数的完整 API 文档&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://docs.authing.cn/authing/extensibility/pipeline/user-object&quot;&gt;user 对象完整 API&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://docs.authing.cn/authing/extensibility/pipeline/context-object&quot;&gt;context 对象完整 API&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.authing.cn/authing/extensibility/pipeline/env&quot;&gt;了解如何在 Authing Pipeline 函数中使用环境变量？&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.authing.cn/authing/extensibility/pipeline/available-node-modules&quot;&gt;在 Authing Pipeline 函数中有哪些开箱即用的 Node Modules &lt;/a&gt;?&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.authing.cn/authing/extensibility/pipeline/how-to-debug&quot;&gt;了解如何使用 Authing 的在线调试器调试代码 ?&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.authing.cn/authing/extensibility/pipeline/node-sdk&quot;&gt;了解如何使用 Authing Node SDK 管理自定义 Pipeline 函数?&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.authing.cn/authing/extensibility/pipeline/node-sdk&quot;&gt;非 JS 开发者，如何使用 GraphQL API 管理自定义 Pipeline 函数?&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</content><author><name>cj</name></author><category term="Pipeline" /><category term="扩能能力" /><summary type="html">Authing Pipeline 是一组运行在云端的用户自定义 JavaScript 代码，属于 Authing 扩展能力的重要部分，可以让开发者无限制扩展、自定义 Authing 的能力。</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://cdn.authing.cn/blog/20200220203521.png" /></entry><entry><title type="html">五分钟理解什么是 OIDC</title><link href="http://localhost:4000/blog/5-%E5%88%86%E9%92%9F%E7%90%86%E8%A7%A3%E4%BB%80%E4%B9%88%E6%98%AF-OIDC/" rel="alternate" type="text/html" title="五分钟理解什么是 OIDC" /><published>2020-02-18T00:00:00+08:00</published><updated>2020-02-18T00:00:00+08:00</updated><id>http://localhost:4000/blog/5%20%E5%88%86%E9%92%9F%E7%90%86%E8%A7%A3%E4%BB%80%E4%B9%88%E6%98%AF%20OIDC</id><content type="html" xml:base="http://localhost:4000/blog/5-%E5%88%86%E9%92%9F%E7%90%86%E8%A7%A3%E4%BB%80%E4%B9%88%E6%98%AF-OIDC/">&lt;p&gt;OIDC 的全称是 OpenID Connect，是一套基于 OAuth 2.0 的认证 + 授权协议，用于用户身份认证，将用户数据安全地暴露给第三方。&lt;/p&gt;

&lt;h1 id=&quot;oidc-与-oauth-20-有何不同&quot;&gt;OIDC 与 OAuth 2.0 有何不同？&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://oauth.net/2/&quot;&gt;OAuth 2.0&lt;/a&gt;&lt;/strong&gt; 是用于&lt;strong&gt;授权&lt;/strong&gt;的行业标准协议。 OAuth 2.0 致力于简化客户端开发人员的工作，同时为 Web 应用程序，桌面应用程序，移动电话和物联网设备提供特定的授权流程。&lt;/p&gt;

&lt;p&gt;以上是 OAuth 2.0 的官方定义。我们举一个实际的例子，你在登录京东的时候，会发现在京东的登录框中有使用 QQ 登录、使用微信登录的按钮，这些地方就是 OAuth 2.0 协议的用武之地。京东希望从 QQ 获取你的 QQ 用户数据，从而完成在京东的注册，这就需要数据的主人——你的授权。完成授权之后， QQ 会给京东一个 access_token，京东携带这个凭证，就能&lt;strong&gt;以你的名义&lt;/strong&gt;，以及&lt;strong&gt;你授予此网站的权限&lt;/strong&gt;（例如你授权京东能够访问你的个人信息而不是转账能力），访问&lt;strong&gt;你在 QQ 服务器上的数据&lt;/strong&gt;，从而获取你的信息，在此过程中，你&lt;strong&gt;无须告诉&lt;/strong&gt;京东你的 QQ &lt;strong&gt;账号和密码&lt;/strong&gt;，你输入账密信息的时候，是在腾讯的服务器完成的认证。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;OIDC&lt;/strong&gt; 与 &lt;strong&gt;OAuth 2.0&lt;/strong&gt; 相比，多了&lt;strong&gt;认证&lt;/strong&gt;的能力。不但能够返回用户的 access_token，让第三方通过 access_token 调用用户授权过的接口（用户&lt;strong&gt;授权&lt;/strong&gt;），还可以返回用户的 &lt;strong&gt;id_token&lt;/strong&gt;，第三方可以将 id_token 用作用户身份标识（用户&lt;strong&gt;认证&lt;/strong&gt;）。&lt;/p&gt;

&lt;p&gt;回到刚才的例子，京东获取到 QQ 颁发的 access_token（是一个随机字符串）之后确实能够获取到你的信息，但是如果不借助其他手段，是&lt;strong&gt;不具备用户身份认证功能&lt;/strong&gt;的。而在 OIDC 协议中，获取 access_token 的同时，会返回一个 JWT 格式的 id_token，可直接用作身份标识，供第三方确认用户身份。&lt;/p&gt;

&lt;p&gt;JWT Token 是这个样子的：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;eyJ0eXAiOiJKV1QiLA0KICJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFtcGxlLmNvbS9pc19yb290Ijp0cnVlfQ.dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;格式为“点分 base64 编码”，一共三段，第一部分叫作&lt;strong&gt;头部&lt;/strong&gt;（JOSE Header），第二部分叫作&lt;strong&gt;荷载&lt;/strong&gt;（Payload），第三部分叫作&lt;strong&gt;签名&lt;/strong&gt;（Signature）。其中的签名根据头部、荷载和一个密钥计算得出，不可伪造。&lt;/p&gt;

&lt;p&gt;base64 解码之后是这样子的：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{&quot;typ&quot;:&quot;JWT&quot;, &quot;alg&quot;:&quot;HS256&quot;}.{&quot;iss&quot;:&quot;joe&quot;, &quot;exp&quot;:1300819380, &quot;http://example.com/is_root&quot;:true}.&amp;lt;签名&amp;gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;更多 JWT 知识请&lt;a href=&quot;https://openid.net/specs/openid-connect-core-1_0.html&quot;&gt;参考 JWT 规范&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;总结成一句话：OAuth 2.0 能做的 OIDC 都能做，OAuth 2.0 不具备的认证能力，OIDC 也具备。&lt;/p&gt;

&lt;h1 id=&quot;oidc-协议的应用场景&quot;&gt;OIDC 协议的应用场景&lt;/h1&gt;

&lt;p&gt;所有使用 OAuth 2.0 的场景都可以升级为 OIDC 协议，OIDC 协议是 OAuth 2.0 的超集。以下是一些 OIDC 协议的应用场景：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;社会化登录场景，网站登录框上常见许多按钮「使用 XXX 登录」。&lt;/li&gt;
  &lt;li&gt;物联网设备的身份认证和授权。&lt;/li&gt;
  &lt;li&gt;企业内多个应用统一身份，单点登录。&lt;/li&gt;
  &lt;li&gt;开放平台对外暴露应用数据，做用户认证与授权。&lt;/li&gt;
  &lt;li&gt;Serverless 中的身份层。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;OIDC 协议是 OAuth 2.0 协议的下一代，是身份认证协议升级的不二之选。
OIDC 协议中的四个主体
在介绍 OIDC 授权模式之前，先要明确四个主体：&lt;strong&gt;第三方应用、资源服务器、资源所有者、认证授权服务器&lt;/strong&gt;。我们继续沿用前文京东与 QQ 登录的例子。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;P.S. QQ 使用的是变种 OAuth 2.0 协议，并不完全符合 OIDC 规范，在此假设 QQ 使用 OIDC 协议进行对外数据授权。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;第三方应用&quot;&gt;第三方应用&lt;/h2&gt;

&lt;p&gt;京东的角色是第三方应用。&lt;/p&gt;

&lt;h2 id=&quot;资源服务器&quot;&gt;资源服务器&lt;/h2&gt;

&lt;p&gt;QQ 的个人信息存放于资源服务器。&lt;/p&gt;

&lt;h2 id=&quot;资源所有者&quot;&gt;资源所有者&lt;/h2&gt;

&lt;p&gt;用户是 QQ 账号的所有者。&lt;/p&gt;

&lt;h2 id=&quot;认证授权服务器&quot;&gt;认证授权服务器&lt;/h2&gt;

&lt;p&gt;QQ 的授权服务器负责用户的身份认证和授权，管理第三方应用、受保护资源、资源所有者之间的关系。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.authing.cn/blog/20200218205006.png&quot; alt=&quot;四者关系&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;oidc-的三种授权模式&quot;&gt;OIDC 的三种授权模式&lt;/h1&gt;

&lt;h1 id=&quot;authorization-code-flow&quot;&gt;Authorization Code Flow&lt;/h1&gt;

&lt;p&gt;应用最为广泛的是&lt;strong&gt;授权码模式&lt;/strong&gt;，此模式的交互过程如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.authing.cn/blog/20200218205046.png&quot; alt=&quot;授权码模式&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;第三方应用访问认证服务器的授权链接。（用户在京东网站登录框点击使用 QQ 登录）&lt;/li&gt;
  &lt;li&gt;用户与认证服务器完成身份认证。（浏览器跳转到 QQ 授权页面，用户输入 QQ 号和密码）&lt;/li&gt;
  &lt;li&gt;认证服务器向第三方应用返回授权码 code。（QQ 服务器将用户的浏览器重定向，将授权码发送到京东服务器）&lt;/li&gt;
  &lt;li&gt;第三方应用携带授权码访问认证服务器的 token 接口。（京东服务器携带授权码与 QQ 服务器交互）&lt;/li&gt;
  &lt;li&gt;认证服务器返回 &lt;strong&gt;access_token&lt;/strong&gt; 和 &lt;strong&gt;id_token&lt;/strong&gt; 给第三方应用。（QQ 服务器返回 access_token 和 id_token 给京东服务器）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;此后，&lt;strong&gt;第三方应用&lt;/strong&gt;可以利用 access_token 到&lt;strong&gt;资源服务器&lt;/strong&gt;获取用户的信息，完成在第三方应用的注册和登录业务，并可以&lt;strong&gt;将 id_token 作为用户的身份凭证&lt;/strong&gt;，存放在前端。第三方应用的前端需要访问受保护的资源（例如用户账单信息、购物车）时需要&lt;strong&gt;携带 id_token，后端验证 id_token 合法性&lt;/strong&gt;，核实用户身份之后，返回相关资源数据。&lt;/p&gt;

&lt;h2 id=&quot;oidc-认证时相关-token-解释&quot;&gt;OIDC 认证时相关 Token 解释&lt;/h2&gt;

&lt;p&gt;OIDC 认证时会签发两种 Token，一类叫 id_token，还有一类叫 access_token。&lt;/p&gt;

&lt;p&gt;id_token 是&lt;strong&gt;用户身份的凭证，只起到判定用户身份的作用&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;id_token 示例：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiI1ZTQ5NjBkZmJkOTE1OGZiODQ0OTAzYTkiLCJiaXJ0aGRhdGUiOiIiLCJmYW1pbHlfbmFtZSI6IiIsImdlbmRlciI6IiIsImdpdmVuX25hbWUiOiIiLCJsb2NhbGUiOiIiLCJtaWRkbGVfbmFtZSI6IiIsIm5hbWUiOiIiLCJuaWNrbmFtZSI6IiIsInBpY3R1cmUiOiJodHRwczovL3VzZXJjb250ZW50cy5hdXRoaW5nLmNuL2F1dGhpbmctYXZhdGFyLnBuZyIsInByZWZlcnJlZF91c2VybmFtZSI6IiIsInByb2ZpbGUiOiIiLCJ1cGRhdGVkX2F0IjoiIiwid2Vic2l0ZSI6IiIsInpvbmVpbmZvIjoiIiwiY29tcGFueSI6IiIsImJyb3dzZXIiOiJNb3ppbGxhLzUuMCAoTWFjaW50b3NoOyBJbnRlbCBNYWMgT1MgWCAxMF8xNF82KSBBcHBsZVdlYktpdC81MzcuMzYgKEtIVE1MLCBsaWtlIEdlY2tvKSBDaHJvbWUvODAuMC4zOTg3Ljg3IFNhZmFyaS81MzcuMzYiLCJkZXZpY2UiOiIiLCJsb2dpbnNfY291bnQiOjEsInJlZ2lzdGVyX21ldGhvZCI6ImRlZmF1bHQ6dXNlcm5hbWUtcGFzc3dvcmQiLCJibG9ja2VkIjpmYWxzZSwibGFzdF9pcCI6IjEyMS4yMS41Ni4xNzEiLCJyZWdpc3Rlcl9pbl91c2VycG9vbCI6IjVjOTU5MDU1NzhmY2U1MDAwMTY2Zjg1MyIsImxhc3RfbG9naW4iOiIyMDIwLTAyLTE2VDE1OjMzOjUyLjQ0NFoiLCJzaWduZWRfdXAiOiIyMDIwLTAyLTE2VDE1OjMzOjUxLjY2NVoiLCJlbWFpbCI6InRlc3QxQDEyMy5jb20iLCJlbWFpbF92ZXJpZmllZCI6ZmFsc2UsInBob25lX251bWJlciI6IiIsInBob25lX251bWJlcl92ZXJpZmllZCI6ZmFsc2UsImF0X2hhc2giOiJWYW9sSnVqWXltQjUxNlNGOGNaQkpBIiwic2lkIjoiZGYzMGFlNDgtOTkzMS00YjZlLWI0YzgtMWI5NjRkOGZjOWIyIiwiYXVkIjoiNWQwMWUzODk5ODVmODFjNmMxZGQzMWRlIiwiZXhwIjoxNTgxODcwOTc4LCJpYXQiOjE1ODE4NjczODEsImlzcyI6Imh0dHBzOi8vb2F1dGguYXV0aGluZy5jbi9vYXV0aC9vaWRjIn0.pH-bWm-Im0wnOcUEA-OG_iKwy9DTZlAXuik50HPsfGY
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;解码后：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{
  &quot;alg&quot;: &quot;HS256&quot;,
  &quot;typ&quot;: &quot;JWT&quot;
}
.
{
  &quot;sub&quot;: &quot;5e3a3b2315a0b8398cdaaa08&quot;,
  &quot;birthdate&quot;: &quot;&quot;,
  &quot;family_name&quot;: &quot;&quot;,
  &quot;gender&quot;: &quot;&quot;,
  &quot;given_name&quot;: &quot;&quot;,
  &quot;locale&quot;: &quot;&quot;,
  &quot;middle_name&quot;: &quot;&quot;,
  &quot;name&quot;: &quot;&quot;,
  &quot;nickname&quot;: &quot;&quot;,
  &quot;picture&quot;: &quot;https://usercontents.authing.cn/authing-avatar.png&quot;,
  &quot;preferred_username&quot;: &quot;&quot;,
  &quot;profile&quot;: &quot;&quot;,
  &quot;updated_at&quot;: &quot;&quot;,
  &quot;website&quot;: &quot;&quot;,
  &quot;zoneinfo&quot;: &quot;&quot;,
  &quot;company&quot;: &quot;&quot;,
  &quot;browser&quot;: &quot;&quot;,
  &quot;device&quot;: &quot;&quot;,
  &quot;logins_count&quot;: 8,
  &quot;register_method&quot;: &quot;default:username-password&quot;,
  &quot;blocked&quot;: false,
  &quot;last_ip&quot;: &quot;127.0.0.1&quot;,
  &quot;register_in_userpool&quot;: &quot;5e3a3b2315a0b8398cdaaa04&quot;,
  &quot;last_login&quot;: &quot;2020-02-16T09:04:09.764Z&quot;,
  &quot;signed_up&quot;: &quot;2020-02-05T03:48:51.447Z&quot;,
  &quot;email&quot;: &quot;test@test.com&quot;,
  &quot;email_verified&quot;: false,
  &quot;phone_number&quot;: &quot;&quot;,
  &quot;at_hash&quot;: &quot;6k-IWJwh-Dd3_hLOay0s7A&quot;,
  &quot;sid&quot;: &quot;d50a8c9d-23db-4156-80ea-1c82d199d0e9&quot;,
  &quot;aud&quot;: &quot;5e3a3b2315a0b8398cdaaa0e&quot;,
  &quot;exp&quot;: 1581948533,
  &quot;iat&quot;: 1581944933,
  &quot;iss&quot;: &quot;https://core.littleimp.cn/oauth/oidc&quot;
}
.
签名
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;access_token 是&lt;strong&gt;用户授权给第三方应用的一个令牌&lt;/strong&gt;，第三方应用可以使用这个令牌访问用户在资源服务器上受保护的资源，&lt;strong&gt;一般不用于用户凭证和身份标识&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;access_token 示例：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiJXaXdndEdHYzVMeGtZRUFRY012RFkiLCJzdWIiOiI1ZTNhM2IyMzE1YTBiODM5OGNkYWFhMDgiLCJpc3MiOiJodHRwczovL2NvcmUubGl0dGxlaW1wLmNuL29hdXRoL29pZGMiLCJpYXQiOjE1ODE5NDQ5MzMsImV4cCI6MTU4MTk0ODUzMywic2NvcGUiOiJvcGVuaWQgcHJvZmlsZSBlbWFpbCBwaG9uZSIsImF1ZCI6IjVlM2EzYjIzMTVhMGI4Mzk4Y2RhYWEwZSJ9.MnAAGj6HlYvN3FOAo6PA2cxNxZDZbL3yhxTM3uxnt0M
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;解码后：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{
  &quot;alg&quot;: &quot;HS256&quot;,
  &quot;typ&quot;: &quot;JWT&quot;
}
.
{
  &quot;jti&quot;: &quot;WiwgtGGc5LxkYEAQcMvDY&quot;,
  &quot;sub&quot;: &quot;5e3a3b2315a0b8398cdaaa08&quot;,
  &quot;iss&quot;: &quot;https://core.littleimp.cn/oauth/oidc&quot;,
  &quot;iat&quot;: 1581944933,
  &quot;exp&quot;: 1581948533,
  &quot;scope&quot;: &quot;openid profile email phone&quot;,
  &quot;aud&quot;: &quot;5e3a3b2315a0b8398cdaaa0e&quot;
}
.
签名
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;implicit-flow&quot;&gt;Implicit Flow&lt;/h1&gt;

&lt;p&gt;在隐式模式中，认证服务器的授权接口不会返回授权码 code，而是在与用户完成认证后返回 id_token 和 access_token，交互模式如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.authing.cn/blog/20200218205133.png&quot; alt=&quot;隐式模式&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;第三方应用访问认证服务器的授权链接。（用户在京东网站登录框点击使用 QQ 登录）&lt;/li&gt;
  &lt;li&gt;用户与认证服务器完成身份认证。（浏览器跳转到 QQ 授权页面，用户输入 QQ 号和密码）&lt;/li&gt;
  &lt;li&gt;认证服务器向第三方应用返回 id_token 和 access_token。（QQ 服务器将用户的浏览器重定向，将 id_token access_token 发送到京东前端页面）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;隐式模式比授权码模式简单，经常用于将 id_token、access_token &lt;strong&gt;直接返回到前端&lt;/strong&gt;，方便前端直接存储 id_token 用于证明用户身份。也需要前端自行将 access_token 发回后端，后端用于获取用户的详细信息，这增加了&lt;strong&gt;暴露 access_token 的风险&lt;/strong&gt;。隐式模式&lt;strong&gt;不支持返回 refresh_token&lt;/strong&gt;，即不能从后端刷新 access_token，登录一旦过期需要用户重新登录。&lt;/p&gt;

&lt;h1 id=&quot;hybrid-flow&quot;&gt;Hybrid Flow&lt;/h1&gt;

&lt;p&gt;混合模式是以上两种模式的组合，特点是能够在授权接口一次性获取到 code、id_token、access_token，一般 code 会与 id_token、access_token 混合出现，混合模式的交互如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.authing.cn/blog/20200218205228.png&quot; alt=&quot;混合模式&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;第三方应用访问认证服务器的授权链接。（用户在京东网站登录框点击使用 QQ 登录）&lt;/li&gt;
  &lt;li&gt;用户与认证服务器完成身份认证。（浏览器跳转到 QQ 授权页面，用户输入 QQ 号和密码）&lt;/li&gt;
  &lt;li&gt;认证服务器向第三方应用返回 code、id_token 和 access_token。（QQ 服务器将用户的浏览器重定向，将 id_token access_token 发送到京东前端页面）&lt;/li&gt;
  &lt;li&gt;第三方应用携带授权码访问认证服务器的 token 接口。（京东服务器携带授权码与 QQ 服务器交互）&lt;/li&gt;
  &lt;li&gt;认证服务器返回 &lt;strong&gt;access_token&lt;/strong&gt; 和 &lt;strong&gt;id_token&lt;/strong&gt; 给第三方应用。（QQ 服务器返回 access_token 和 id_token 给京东服务器）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;混合模式可以灵活满足 code、id_token、access_token 的各种处理方式，可以在享有隐式模式便利的同时，利用 code 获取 refresh_token，从而可以在后端刷新用户 access_token，不必重复让用户登录。&lt;/p&gt;

&lt;h1 id=&quot;总结&quot;&gt;总结&lt;/h1&gt;

&lt;p&gt;OIDC 协议是 OAuth 2.0 协议的超集，是可以替代 OAuth 2.0 的下一代身份认证协议，能够解决认证 + 授权两个问题。OIDC 的授权流程与 OAuth 2.0 完全一致，能够保持向下兼容。&lt;/p&gt;

&lt;p&gt;授权服务器的意义在于管理&lt;strong&gt;第三方应用、受保护资源、资源所有者&lt;/strong&gt;之间的关系，让互相不信任的应用之间安全地暴露数据——应用之间约定好某种规范，按照这种规范，就能在用户授权的前提下，安全地将数据暴露给第三方，而第三方也无需获知用户的账密信息。&lt;/p&gt;

&lt;p&gt;id_token 是用户的&lt;strong&gt;身份凭证&lt;/strong&gt;，access_token 是用户的&lt;strong&gt;授权凭证&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;OIDC 有三种授权模式，分别是&lt;strong&gt;授权码模式、隐式模式、混合模式&lt;/strong&gt;。授权码模式中只能获取到 code；隐式模式中只能获取到 access_token id_token；混合模式中都能够获取到。&lt;/p&gt;</content><author><name>叶祖伟</name></author><category term="OIDC" /><summary type="html">OIDC 的全称是 OpenID Connect，是一套基于 OAuth 2.0 的认证 + 授权协议，用于用户身份认证，将用户数据安全地暴露给第三方。</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://cdn.authing.cn/blog/20200218203422.png" /></entry><entry><title type="html">Geek Talk 036 实录：Serverless 的前景和机会</title><link href="http://localhost:4000/blog/GeekTalk036%E5%AE%9E%E5%BD%95-Serverless-%E7%9A%84%E5%89%8D%E6%99%AF%E5%92%8C%E6%9C%BA%E4%BC%9A/" rel="alternate" type="text/html" title="Geek Talk 036 实录：Serverless 的前景和机会" /><published>2020-02-17T00:00:00+08:00</published><updated>2020-02-17T00:00:00+08:00</updated><id>http://localhost:4000/blog/GeekTalk036%E5%AE%9E%E5%BD%95:Serverless%20%E7%9A%84%E5%89%8D%E6%99%AF%E5%92%8C%E6%9C%BA%E4%BC%9A</id><content type="html" xml:base="http://localhost:4000/blog/GeekTalk036%E5%AE%9E%E5%BD%95-Serverless-%E7%9A%84%E5%89%8D%E6%99%AF%E5%92%8C%E6%9C%BA%E4%BC%9A/">&lt;p&gt;Serverless 正在改变未来软件开发的模式和流程，对于大多数应用而言，借助 Serverless 服务，开发者可以将绝大多数精力投入在业务逻辑的开发整合上，大大缩短开发周期，降低运维成本。本次主题将与大家探讨 Serverless 生态中缺少的工具以及潜在的创业机会。&lt;/p&gt;

&lt;p&gt;大家好，我谢扬。很高兴能够有这个机会更加交流关于 Serverless 的技术，我们目前创业做的事情跟 Serverless 也是非常强相关的，目前聚焦研发一款 IDaaS 身份即服务产品 Authing。我之前在字节跳动负责一款日活过亿的 Serverless 产品 LarkCloud。我个人对 Serverless 保持着长期的关注，对 Serverless 行业的发展也有很多想法，今天也跟大家分享一下。&lt;/p&gt;

&lt;p&gt;我们今晚的议题主要分为四个主题，第一个是 Serverless 架构的介绍，第二个是Serverless的一些使用场景，第三个是Serverless 的使用报告，这个报告是来自于：O’Reilly Serverless survey 2019 的调研，第四是跟大家展望一下未来的 Serverless 工具链是什么样子，然后它的前景和机会是什么。&lt;/p&gt;

&lt;h2 id=&quot;1-serverless-架构介绍&quot;&gt;1. Serverless 架构介绍&lt;/h2&gt;

&lt;h3 id=&quot;1云计算的发展&quot;&gt;1）云计算的发展&lt;/h3&gt;

&lt;p&gt;首先开始我们的第一个议题：Serverless 架构，在看这个架构之前，我们先来回顾一下云计算的发展。 图中蓝色这部分是由用户来进行管理的这一部分，黄色这一部分是由云服务商来进行管理的。从早期的 On-Premises 到 FaaS ，这是云计算的发展历程。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.authing.cn/blog/20200217155704.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;On-Premises 的时候，机房所有的硬件、操作系统、容器、运行时环境、应用、函数等都需要自己管理；发展到 IaaS 之后，那么开发商他们不需要维护自己的硬件了，但是还是需要维护很多东西。&lt;/p&gt;

&lt;p&gt;后来 CaaS 服务出现，容器即服务，我们自己不需要再维护操作系统层面的东西，只需要维护容器，K8s 这么短时间火起来，这也是一个很重要的原因。&lt;/p&gt;

&lt;p&gt;那么再往下就是像阿里云、AWS 这种云计算 PaaS 平台出来，做了很多周边的一些工具，比如说各种各样的监控、报警，还有整个的服务器管理的控制台，然后有了这种服务之后，让客户连这些服务也不用自己来管理了，只需要管理自己的应用就好了，这就是 PaaS 服务。&lt;/p&gt;

&lt;p&gt;那么再到现在，出现 FaaS 的产品形态，最右边的 FaaS 是蓝色的，下层所有模块都是黄色的，由云服务商提供，中间还有一个灰色模块 Application ，需要云服务商和用户一起进行管理。&lt;/p&gt;

&lt;p&gt;那么这是 FaaS 的一个演进历史，总的来说 FaaS、PaaS、CaaS 等服务发展出来的缘由：&lt;strong&gt;就是让更多的客户能够专心自己的业务，而不需要去维护底层这么多跟业务无关的基础设施。&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;2serverless-架构&quot;&gt;2）Serverless 架构&lt;/h3&gt;

&lt;p&gt;接下来看一下 Serverless 架构，这里我们以 AWS 的一些服务为例，最左边的一个User Agent（用户），从浏览器去访问一个系统，首先会经过一个API Gateway，API Gateway会出发一个函数 Cloud Function，在AWS中叫 Lambda，然后 Lambda 会去执行一些获取资源、业务操作，这些资源都是受限的，它可能是亚马逊的 DynamoDB、也可能是 AWS S3 存储、也可能是亚马逊的 EC2，也可能是你自己的一个社交数据以及通讯录好友等。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.authing.cn/blog/20200217155815.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这些资源默认是受限的，受限的时候就需要去访问一个&lt;strong&gt;无服务器的身份认证系统&lt;/strong&gt;，即图中的 Authing ，用户通过 Authing 进行登录，认证完成之后会获取一个 Token，然后用户带 Token 去请求资源，这个时候这个后端必须验证 Token 是合法的，才能够获取用户有权限访问的资源。这是 Serverless 整体的访问的一个流程。&lt;/p&gt;

&lt;p&gt;现在很多人把 Serverless 分为两块，一块叫做 FaaS（函数即服务）Functions as a Service的缩写，只需要执行一个函数，上传一个函数，然后这些函数来执行一些操作，比如说读取你的通讯、你的地址，或读取其他的业务信息。&lt;/p&gt;

&lt;p&gt;另外一块叫做 BaaS（后端即服务），全称是 Backend as a Service，就是把整个 BaaS 代码上传到服务器，然后它会自动给你做一些弹性伸缩。&lt;/p&gt;

&lt;p&gt;其实函数的粒度更细一些，然后我们今天主要探讨的还是FaaS，BaaS 现在发展的不是特别好，我个人也不是很看好 BaaS 这块的市场。&lt;/p&gt;

&lt;h3 id=&quot;3faas-函数的生命周期&quot;&gt;3）FaaS 函数的生命周期&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.authing.cn/blog/20200217155848.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;接下来我们了解一下 FaaS 的生命周期，FaaS 的全称是 Functions as a Service，开发者只需要开发一个函数，然后这个函数会根据函数的访问量来自动的做一些收缩。FaaS 有触发器，就是从哪一方进行调用，比如：你在浏览器上请求一个 FaaS ，那么就是收到一个 HTTP 请求。 又如说某个图片被上传到了腾讯云的 OSS 里面（OSS 是腾讯的存储服务），那么上传成功之后有一个回调消息，这个消息会去触发 FaaS 函数，这个就叫做 Webhook。还有一类物联网场景，比如温度采集器，测量到温度之后，会有一种 Pub/Sub 这种消息模型，这种消息模型是异步的，也是会执行这样一个 FaaS 触发器。&lt;/p&gt;

&lt;p&gt;那么一旦是触发了 FaaS 的执行，就会启动一个VM （虚拟机），那么这个 VM （虚拟机）目前主要分为两类：一类是直接 Fork 进程，然后在进程里执行这段代码，另一类就是去启动一个容器，然后在容器里面执行。在 Process 进程里执行代码的方式是不太安全的，所以现在很多人都转向了容器。当然容器的问题在于冷启动时间会非常长，也就是说假如这个函数本身执行时间只有 200 毫秒，如果加上容器的启动时间可能也是 200 毫秒，总共的时间可能变成了 400 毫秒，那么就会造成一些网络延迟，最后对用户体验产生影响。&lt;/p&gt;

&lt;p&gt;启动了这样一个 VM 之后，就会去运行这个函数，运行结束之后就会把这个实例给销毁掉，同时云服务商会根据你的运行时间来计算、所耗费的资源如：CPU、内存、包括带宽等等，然后计算这次运行花多少钱，来进行一次扣费。&lt;/p&gt;

&lt;p&gt;这就是 FaaS 函数的生命周期，接下来给大家剖析一下：为什么我们要用 FaaS ？&lt;/p&gt;

&lt;h3 id=&quot;4iaas-模型&quot;&gt;4）IaaS 模型&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.authing.cn/blog/20200217155916.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;首先，我们先来看 IaaS 模型。分别从四个视角来看一下 IaaS 的整体架构：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;第一是从 Service Models 视角&lt;/strong&gt;，即服务模式，分为 IaaS、PaaS、SaaS。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;第二是从 Cloud Stack 视角&lt;/strong&gt;，阐释来云计算是由最底层基础设施层、应用程序栈、应用程序、用户层 来构成。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;第三是从 Stack Components 视角&lt;/strong&gt;，来看一下详细的构成组件：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;基础设施层&lt;/strong&gt;：就是各种各样的硬件资源，如CPU、网络、带宽、硬盘等等，由基础设施厂商来提供服务，并保障最基础的系统安全。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Application Stack&lt;/strong&gt;：就是需要构建应用所需要的基础软件技术栈，包括了操作系统、编程语言、应用服务器、中间件、数据库（关系数据库、图数据库、亦或是非关系数据库等）、还有报警监控服务、DevOps、CI/CD、API Gateway 等。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Application 层&lt;/strong&gt;：开发者去建立自己的业务模型、业务应用的时候所需要的开发组件，「认证、授权」是其中最基础的组件，然后是 UI（即用户界面）、一些事务，比如你的支付、或直播的事务等。另外是一些报告，涉及与业务相关的用户的增长数据的报告、管理业务的使用情况，Key Metrics 是什么样子；另外还需要一个后台对所有资源进行管理。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;用户层&lt;/strong&gt;：包含用户登录、注册、管理等。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;第四是从不同服务模式下计算服务供应商和客户之间的责任边界。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;IaaS 模式下&lt;/strong&gt;：IDC 供应商的责任是搭建最基础的硬件基础设施、并对保障整个系统的安全。而客户需要从 OS 底层来搭建整个计算、应用环境、以及业务的开发。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;PaaS 模式下&lt;/strong&gt;：类似 AWS、阿里云等云服务提供商承担了基础设施的建设、以及核心基础软件环境的搭建。如操作系统、数据库、中间件、监控服务，把这些服务抽象成了一层云，然后提供给企业进行使用。客户只需要专注在应用环境搭建、及业务层面的开发。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;SaaS 模式下&lt;/strong&gt;：云服务厂商更进一步的把「应用环境」也服务化，客户仅需考虑业务层面的事情。比如应用层比较重要的两个模块：认证和授权模块也被SaaS 服务化；甚至 User 层的用户注册、登录、管理功能也被 SaaS 化，在美国的已经有 Auth0、Okta 等厂商提供这方面的服务，在中国我们 Authing 也在做类似的事情：IDaaS 身份即服务。有了 IDaaS 客户可以更直接开发业务，不需要操心：注册、登录、用户管理、认证、授权等功能。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;回头来看在 IaaS 时代客户需要做很多事情，基建和研发成本极高，进入市场的时间成本很大。但是经过一系列「服务化」进程后，客户愈加仅需关注自己的业务代码，快速实现、快速进入市场进行验证及销售，这也是从2019年开始，Low code/No code 的创业项目备受资本热捧。&lt;/p&gt;

&lt;h3 id=&quot;5caas-容器模型&quot;&gt;5）CaaS 容器模型&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.authing.cn/blog/20200217160041.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;随着技术迭代，进入到了容器模型的时代，企业的运维需要管理更多的产品矩阵及服务的稳定。首先是各种各样的服务发现、Container Runtime、包括整个容器集群的管理，还有一些安全性问题、性能问题，基于角色的访问控制（RBAC）、 LDAP/AD 的管理、以及 SSO 的实现等。&lt;/p&gt;

&lt;p&gt;对于开发者、运维需要学习很多 SSO 的知识，以及其他跟业务无关的很多东西，这加重了他们管理的负担。CaaS 容器模型让我们整个服务的可伸缩性大大提高了，但是也大大加重了运维人员的负担。&lt;/p&gt;

&lt;h3 id=&quot;6serverless-模型&quot;&gt;6）Serverless 模型&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.authing.cn/blog/20200217160116.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;行业逐步发展到了今天的 Serverless 模型，在之前模型下客户需要操心很多的组件。但是，进入Serverless 模型后，客户仅需要关心是「业务代码」，设计好自己的业务模型，把代码部署到云服务中，就可以完成所有的复杂的一系列的部署、运维、监控等操作。&lt;/p&gt;

&lt;h4 id=&quot;1faas-优势&quot;&gt;1）FaaS 优势&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.authing.cn/blog/20200217160243.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Serverless 带来的好处，首先是：零运维，也叫做零管理。除了零运维和零管理之外，还有其他很多优势，比如说按运行时间付费，你运行多长时间，就付多少钱；没有运行资源损耗的时候，不需要付任何钱。举个例子，可以看右边这张图，蓝色的线代表是每秒处理多少请求；红色的线是处理这些请求需要的服务器数量。可以看到蓝色的线有两个峰值，这代表需要 200 台服务器，在传统的架构下就需要准备 200 台服务器。 那么有了 FaaS 之后，就不需要买那么多服务器，只需要是把这个业务逻辑写好，然后它会自动为你进行伸缩。伸缩的策略也非常多，比如用机器学习来进行预测，或者说可以用一些即时计算进行预测等等。运维人员只需要去考虑管理更少的服务器，开发人员只需要去关心业务代码，就可以让企业更快进入市场，并且能够造一个原生的微服务，显著降低企业的管理和维护负担。&lt;/p&gt;

&lt;h4 id=&quot;2faas-劣势&quot;&gt;2）FaaS 劣势&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.authing.cn/blog/20200217160309.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;除了优势之外，FaaS 还有很多劣势，没有一个通用的标准。比如 AWS、Google，还有国内腾讯、阿里云、华为、京东云都有 FaaS 服务，但他们没有一个通用的标准；这也造成了：客户被供应商锁定的问题，无法便捷迁移。比如说我现在用 AWS，每天请求可能上亿，想要迁移到阿里云和腾讯云就非常的麻烦。第 2 点是 FaaS 是一个黑盒子环境，开发者需要去非常了解这个东西的底层是怎么回事，他才能敢去使用，否则他无法去预估一些潜在的风险。第 4 是冷启动的问题，也不算什么太大的问题，云厂商已经解决了这类问题，有很多处理方式。&lt;/p&gt;

&lt;p&gt;第 5 个问题是最要命的一个问题，目前的 FaaS 是没有经过一个非常复杂应用案例的验证。假如说我想用 Serverless 开发一个淘宝、QQ、微信或者一个直播软件，目前是没有这种案例的。&lt;strong&gt;一方面主要是因为生态的缺乏，另外一方面的话也是因为开发人员的思维认知没有提升，这绝对不是一个技术的问题，技术已经非常成熟。&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;3faas-厂商&quot;&gt;3）FaaS 厂商&lt;/h4&gt;

&lt;p&gt;下图是全球范围内在做 FaaS 的厂商，第一个 OpenWhisk 是 IBM 的开源的 FaaS 框架。另外一个是大家都知道的 AWS 的 Lambda，亚马逊的云服务算是业界的一个标准，还有 Google、微软都有类似的服务。国内主要是阿里云、腾讯云、华为云，除了这三家之外，其实京东、滴滴其他的云都有。另外一家就是字节跳动，他们叫做轻服务，这也是我当时在字节跳动开发的一款服务。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.authing.cn/blog/20200217160355.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;此外，还有一股不可忽视的力量，就是美国的 Auth0，是一款 IDaaS - 身份认证即服务，把身份认证上云，他们拥有一个 Webtasks 产品，可以让用户、开发者通过他们的服务快速完成身份认证功能，更多的精力聚焦到具体的业务方面。另外一个就是我们在做的 Authing ，未来的话也会有一个 FnSuite 这样一款函数产品，会和我们的业务有一个非常好的打通。&lt;/p&gt;

&lt;h2 id=&quot;2-serverless-使用场景&quot;&gt;2. Serverless 使用场景&lt;/h2&gt;

&lt;h3 id=&quot;1无服务器的应用后端场景&quot;&gt;1）无服务器的应用后端场景&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.authing.cn/blog/20200217160436.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;接下来介绍一下 Serverless 的使用场景。&lt;/p&gt;

&lt;p&gt;首先第一类就是这种无服务器的应用后端，比如说我写了一段代码，然后我把它 push 到 Github 上去，这个时候 Github 的 webhook，我需要让它通知到我的 Slack 或者我的飞书。&lt;/p&gt;

&lt;p&gt;假如没有 Serverless 的情况下，需要自己写一个代码后端框架，然后自己拼接一下，写个路由，写完路由之后，还需要再把它部署到服务器上去，然后再部署运维。&lt;/p&gt;

&lt;p&gt;那么有了 FaaS 之后，只需要写个函数，把它传到阿里云或者腾讯云上，云服务商返回一个 API 链接，开发者把链接填到 Github 上去，就完成了整个操作流程，非常简单。&lt;/p&gt;

&lt;p&gt;还有一种是新闻消息推送应用，一个新的用户，它注册了一个应用，然后在我们这个消息里面就推送给他一些新闻。&lt;/p&gt;

&lt;p&gt;再比如物联网的应用的后端，比如说一个温度的信息推送系统，经过 Pub/Sub 之后来去调用一个函数，然后我们的函数来执行一些具体业务操作，比如推送到我们后台里面进行监测和管理，以及一些报警等。&lt;/p&gt;

&lt;p&gt;这就是 Serverless 的第一类无服务器应用后端场景，如 QQ、微博、微信 IM 以及简单的消息推送场景，都可以使用Serverless。&lt;/p&gt;

&lt;h3 id=&quot;2人工智能应用场景&quot;&gt;2）人工智能应用场景&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.authing.cn/blog/20200217160548.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;第二类场景：人工智能应用。这张图来自 Google，大家可以从左往右看，比如通过 Slack、 Messenger、或 Google Home 和机器人对话，会发送一个 Http 请求，这个请求会在云端执行函数，然后这个函数会请求谷歌的 Dialogflow 是谷歌的一项对话管理服务。&lt;/p&gt;

&lt;p&gt;Dialogflow 把多轮的对话管理起来，后面的其他服务：ML、Vision API 等都是由云服务商提供的能力，&lt;strong&gt;该厂商的 Cloud Functions （云函数）就可以直接调用这些能力，这对云服务厂商来说是非常大的一个优势&lt;/strong&gt;。所以说 Serverless 只能由这些 BigTech 来研发，一些小公司或者创业公司想做Serverless 基础设施基本上是不太可能的，因为，&lt;strong&gt;Serverless 最核心竞争优势不仅仅前面的函数，更重要的是服务商本身所提供其他的能力可以供函数调用&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&quot;3实时数据处理场景&quot;&gt;3）实时数据处理场景&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.authing.cn/blog/20200217160640.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;第三类场景：实时数据处理，最典型的就是物联网应用，数据量非常大，用 Serverless 也是非常匹配。假如需要 1万 QPS ，函数可以立马生成支持 1万 QPS 的集群，如果你自己搭一个 EC 2 服务器或者是其他应用的话，还需要自己去管理集群，成本会变得很大。&lt;/p&gt;

&lt;h3 id=&quot;4aaas-认证即服务场景&quot;&gt;4）AaaS 认证即服务场景&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.authing.cn/blog/20200217160720.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;那么还有一类最不容忽视的一个场景是：&lt;strong&gt;AaaS （Authentication as a Service：认证即服务），把用户注册、登录、用户管理、认证及授权等模块 SaaS 服务化。 为什么需要 AaaS 这类服务呢？主要有三点原因：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;第一点：&lt;strong&gt;身份管理，是云计算里面除了计算资源、存储资源和网络资源之外，最标准化的一个产品。&lt;/strong&gt;为什么说最标准化？前面 IaaS 图中可以看到：Stack Components 包含了注册、登录、注册、用户管理以及认证和授权模块，基本上所有的应用：不管 是to B、to C、to G、to Developer 基本上都是需要的且流程非常标准；甚至在基础设施层面的服务，也都需要标准化的认证服务，比如：K8S 容器编排场景中，也都有认证/授权这种需求，另外在多云管理、DevOps 不同工具流身份的管理等。&lt;/p&gt;

&lt;p&gt;在没有 AaaS 云服务之前，大家都需要自己造的轮子，那么 AaaS 云服务的出现就让这种重复造轮子的事情不在发生，节省巨大的社会生产力，并且让身份管理变得非常简单安全。这个也是很多的厂商都看到的这样一个机会。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.authing.cn/blog/20200217160755.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;第二点：&lt;/strong&gt;身份管理问题在数十年间，从未得到一个很好的解决，用户以自己隐私代价来为企业「身份管理不善」买单。比如很多站点的用户数据泄露事故，这些用户泄露事故不仅给企业的名声造成很大的影响，而且，严重损害了用户的隐私。近期了解到的一家公司每年花几百万来购买身份管理服务。AaaS云服务产品的出现，将大大降低客户的投入成本及安全成本。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;第三点：&lt;/strong&gt;合规成本逐年上升：随着 GDPR、CCPA 、包括加拿大的 Castle 等，这些法律出台之后，政府对于企业在身份管理方面提出了更高的要求。假如企业要去满足这些要求，会花费巨大的成本，而使用AaaS 云服务，就可以保证企业可以非常高效、简单、安全的拥有一个合规身份管理产品。&lt;/p&gt;

&lt;h2 id=&quot;3-serverless-使用报告&quot;&gt;3. Serverless 使用报告&lt;/h2&gt;

&lt;p&gt;接下来看一个 Serverless 使用报告，一起来了解产业现状，数据来源于&lt;a href=&quot;https://www.oreilly.com/radar/oreilly-serverless-survey-2019-concerns-what-works-and-what-to-expect/&quot;&gt;O’Reilly serverless survey 2019&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;首先是 40% 的企业已经采用了 Serverless，这个占比还是比较大的，60% 没有采用，市场空间还是有很大的提升空间。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.authing.cn/blog/20200217160907.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;30% 的 Serverless 用户是一线工程师，然后是架构师、技术 leader 占 25%左右；还有技术类的也不少，另外一个出乎我意料的是：VP、总监、经理级别的用户也近20%；&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.authing.cn/blog/20200217160921.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;另外报告显示，采纳 Serverless 技术的行业也非常广泛，采用最多的是软件行业，第二大是金融及银行业，第三大行业是咨询行业。所以如果要在 Serverless 领域创业的话，可能最好的客户是金融业，要么做外包，要么服务金融业。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.authing.cn/blog/20200217160946.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;60% 的中大型规模企业采纳 Serverless：这个数字也是比较出乎意料，我们潜意识觉得采用 Serverless 新技术的可能都是小企业，但是从图中可以看到，其中一万人以上规模的公司，占到了 20%。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.authing.cn/blog/20200217161005.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;50%的 Serverless 用户，以经常使用 Serverless 超过一年时间，采用 Serverless 技术超过三年时间的企业也超过了10%&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.authing.cn/blog/20200217161023.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;然后 66% 的用户表示，采用 Serverless 技术后效果显著。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.authing.cn/blog/20200217161039.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这是为什么要使用 Serverless 的一些调查。我们看前三个最主要的几个理由，分别是减少运营成本、可以按序的自动的伸缩。第3个是不需要再关心服务器的维护问题，和第一点差不多，降低成本。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.authing.cn/blog/20200217161105.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;为什么不用 Serverless 的原因调查显示：&lt;/p&gt;

&lt;p&gt;企业在采纳 Serverless 技术之后面临最大的挑战是：对于当下员工的教育成本很高，去教育员工还是比较难的，所以如果说要在 Serverless 领域创业的话，能做一家Serverless 领域的咨询公司也不错，与教育机构合作培训人才。&lt;/p&gt;

&lt;p&gt;第二大挑战是因为 Serverless 领域缺乏标准，很容易被供应商锁定，不容易迁移到其他供应商，这个可能需要加快推动 Serverless 行业的标准化进程，防止被供应商锁定，现在 CNCF 基金会也在推动着这个事情。第三大挑战是集成测试、调试非常困难，这也反映了 Serverless 生态供应链的不健全问题，同样，也存在创业机会。&lt;/p&gt;

&lt;p&gt;不采用 Serverless 最大的原因是：考虑到安全问题。如果要创业的话，那么去解决 Serverless 的安全性问题也是一个很大的机会。第二大原因是：因为对于 Serverless 的未知而产生的畏难情绪，不知道使用了 Serverless 会发生什么的问题。第 3 个原因是：底层云服务商正在迁移中，来不及采用 Serverless。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.authing.cn/blog/20200217161217.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;什么角色在管理公司内部 Serverless 的基础设施？&lt;/strong&gt;首先是负责DevOps 的运营人员，第二是：软件工程师、第三是技术架构师。
这个是一个全球调查，我认为和中国的实际情况可能不太吻合，中国可能要反过来，第一可能是架构师来决定。 第二是具有话语权的软件工程师来决定是否采纳。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.authing.cn/blog/20200217161243.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;最后一个调查显示：50%+ 的企业愿意在未来三年尝试 Serverless，所以说 Serverless 在未来还会有一个非常大的增长。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.authing.cn/blog/20200217161727.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;4-serverless-工具链前景和机会&quot;&gt;4. Serverless 工具链、前景和机会&lt;/h2&gt;

&lt;p&gt;最后的话我们来聊一下，Serverless 工具链、前景和机会。首先我们来看工具链，分为三个版块，分别是开发、部署、监控。&lt;/p&gt;

&lt;h3 id=&quot;1开发工具&quot;&gt;1）开发工具：&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;第一是 CLI 工具：&lt;/strong&gt;主要是兼容商业 FaaS 以及开源的 FaaS ，Servereless.com 做的非常不错了，他们已经兼容了十几种 FaaS 平台。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;第二是编辑器的插件：&lt;/strong&gt;现在很多程序员还是习惯使用 VS Code 或者 Sublime 之类的工具进行开发的，所以需要一个非常方便的插件，可以便于管理、调试。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;第三是 WebIDE：&lt;/strong&gt;WebIDE 是一个衍生品，主要是作为方便去开发、调试的小工具，大多数开发者应该还是会基于本地的编辑器插件来开发。&lt;/p&gt;

&lt;p&gt;此外，可能还有一些其它工具有待于补充。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.authing.cn/blog/20200217161734.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;2部署工具&quot;&gt;2）部署工具&lt;/h3&gt;

&lt;p&gt;常用的部署部署工具包括：Git 集成、CI/CD 持续集成、Hooks （用于同步消息到 IM 工具）等。&lt;/p&gt;

&lt;p&gt;那么还需要做一些 Cronjob ，比如说能够非常方便的部署定时任务，并且我能够发布预览版和生产版。&lt;/p&gt;

&lt;h3 id=&quot;3监控工具&quot;&gt;3）监控工具&lt;/h3&gt;

&lt;p&gt;最后我们需要 monitor 来报警，需要短信通知、公司邮件通知，还需要日志等。&lt;/p&gt;

&lt;p&gt;我说的这三点其实只是产品层面的一些小打小闹，有没有这些功能，对 Serverless 的普及和产业的提高并没有太大的影响。我觉得如果要真正促进 Serverless 发展的话，还需要做以下三件事情。&lt;/p&gt;

&lt;h2 id=&quot;5-三个能促进产业发展的机会&quot;&gt;5. 三个能促进产业发展的机会&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.authing.cn/blog/20200217161819.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;第一件事情是有一个 FaaS Framework 专门用来编写大型项目，同时他是完全兼容 FaaS 架构的。为什么需要 FaaS Framework 呢？如果没有 FaaS Framework 的话，我们是没有办法用 FaaS 编写大型项目的。一个函数，只能做一些简单的事情，假如说需要做一个QQ，做一个微信，一个函数是肯定不行的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;第二件事是 Content as a Service&lt;/strong&gt;，CaaS 是 FaaS 本身的更高层级的抽象，FaaS 是提供计算能力，然后最重要的其实还是需要一个存储能力，尤其是结构化数据存储，那么就需要一个 CaaS 将存储云化。比如我我的 CaaS 平台去设计一些表和字段，然后这些字段中间还可以互相连接，最后他可以马上帮我我生成 REST API 或 GraphQL 等，并且它还有和 FaaS 结合的能力，我觉得它是未来一个很大的机会。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;第三类就叫做云原生编程语言。&lt;/strong&gt;这种编程语言的话，它完全是架构在现有的云计算厂商上去的，它的逻辑循环是不变的。但是他对硬盘的读写是在云上，并且它兼容各大云平台，比如说我要调用 AWS 的S3，我只需要写原生编程语言就可以，不需要去使用任何的框架，同时它可以启动云上的服务器进行调试。他从语言层面就是一个可伸缩的，比如说我我写了一个 1+1=2 这样一个计算，假如有一亿请求过来，那么在他语言层面就可以帮我调度可以抵抗一亿流量的计算资源。我觉得如果说这三件事情做好的话，能对整个产业有一个巨大的促进作用。&lt;/p&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.authing.cn/blog/20200217161852.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;最后总结一下，Serverless 是真正的云计算，它真的是按需付费，然后不需要去自己去管理任何的基础设施，只需要关注自己的核心业务，目前的云计算还没有真正做到这一点。然后小公司做 Serverlss 的话基本上没戏，主要原因是缺乏信任。&lt;/p&gt;

&lt;p&gt;如果是创业公司的话，可以从以下几个层面切入。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;第一是做一个 FaaS 聚合器提升开发便捷度，就像 Serverless.com 做的事情一样，&lt;/li&gt;
  &lt;li&gt;第二就是做一个 FaaS 没然后接外包，这种大型的外包业务能用 Serverless 来做最好。&lt;/li&gt;
  &lt;li&gt;第三是开发一个 CaaS 然后覆盖查询业务，然后再通过和 FaaS 打通，进而完成一些高阶操作，进而赋能业务。&lt;/li&gt;
  &lt;li&gt;第四个是开发云原生变成语言，然后与教育机构、培训机构、咨询机构合作，培养人才，人才有了这个意识之后，整个产业才能有一个更大的改变。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;大概是这样，谢谢大家。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;https://github.com/Authing/serverless-oidc&quot;&gt;https://github.com/Authing/serverless-oidc&lt;/a&gt;&lt;/p&gt;

  &lt;p&gt;身份认证云是无服务器架构的一个分支，使用身份认证云和使用无服务器架构拥有一样的好处。&lt;/p&gt;

  &lt;p&gt;请看 Authing 的思考及实践：&lt;/p&gt;

  &lt;ol&gt;
    &lt;li&gt;为什么身份认证值得上云？&lt;/li&gt;
    &lt;li&gt;FnGroup 制定的 FaaS 规范&lt;/li&gt;
    &lt;li&gt;中国首个 FaaS 规范出炉&lt;/li&gt;
  &lt;/ol&gt;

  &lt;p&gt;主页：&lt;a href=&quot;https://github.com/fngroup/fnlib&quot;&gt;https://github.com/fngroup/fnlib&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.authing.cn/blog/20200217162029.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;7-qa&quot;&gt;7. Q&amp;amp;A&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;周家泽：&lt;/strong&gt;我叫周家泽，我在西塔科技工作，我本身不是程序员，我们公司是主要做区块链当中底层的联盟链的开发。 本来我只是想了解一下 Authing 这个项目，所以我就进来一起听一下介绍这样子。然后我这边有一个问题，就是说因为 Authing 这个项目本身跟身份认证这块相关的，所以我想了解一下，就是说像从我们的角度看，这个项目或者说身份认证的项目跟区块链这块有没有结合点，然后会在什么样子的业务场景里面，&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;谢扬：&lt;/strong&gt;Authing 没有区块链，但是和区块链可以有很大的联系。比如数据的主权和身份的主权。场景的话，我觉得还是政府这一块，尤其是政府对公民数据的一个管理，是非常好的一个方向。我们在中国除了运营 Authing 外，还在运营 SoLiD，SoLiD 是万维网之父 Tim 发起的项目，它想要身份和数据由个人来控制。他们在欧洲、在芬兰、在比利时已经有了一个非常好的一个政府的实践经验。稍候，我可以把把一篇论文发给大家看一下这块的实践经验。从我的个人经验来看，区块链对政府的社会治理会有很大的帮助。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;论文推荐：&lt;a href=&quot;https://authing.cn/blog/solid-flemish/&quot;&gt;通过让公民控制自己的数据简化政府流程&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;李涛：&lt;/strong&gt;我补充一下，包括我们这次的新冠疫情，其实我们对人群的追踪，每个人都要填很多表格，其实我们都可以用 SoLiD，把我们每个人信息是实时同步给政府的各级组织，而不需要来回筛查、反复填写。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;王凯：&lt;/strong&gt;大家好，首先感谢谢扬精彩的分享。我也学到很多，我也是一个程序员比较杂，然后什么都干，包括运维这些东西，docker 什么的，目前是自己在创业。&lt;/p&gt;

&lt;p&gt;我主要做的一个事情是在线教育，主要是留学这块市场留学跟家教，但是我们这个业务比较复杂，是包含了中国跟东南亚，还有欧美的一些各个国家。我的问题是像我们这样的业务就是跨区域的，我该如何选择一个好的 Serverless 产品呢？我用 Serverless 的体验是比较糟糕，部署的稍候挺麻烦的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;谢扬：&lt;/strong&gt;用 Serverless.com 就好，它集成了国内外的各种各样的一些服务，比如 AWS、Google、腾讯云等，它们都有一个集成，用他们的工具就可以很方便的完成工作，解决你刚才说的跨国的这样一个问题。另外 Serverless.com 现在的社区运营是有中国人的，所以中国人用起来也会比较友好。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Mingliang：&lt;/strong&gt;大家好，谢谢涛哥和谢扬今天给大家带来的分享，特别好。我之前在上海创业公司电商社交，然后现在把这个业务都清理掉了，目前在新加坡国立大学读博士。我是一年级刚开始读博，我的研究方向是分布式系统，所以自然对这个身份的也很感兴趣。然后我想请教一下谢扬的问题，这个身份有没有和 SDN 有一些契合的点，或者说其实没有的话，可能未来是不是也有一些可以结合的点。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;谢扬：&lt;/strong&gt;我对这个领域还不是很了解，不过 SDN 这个概念的话，我是非常认可的。软件确实可以定义很多的硬件资源的，把它给出抽出来，变成一种信息化资源，包括现在的 SD-WAN。网络通信这一块也是类似这样一个事情。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;宋军：&lt;/strong&gt;大家好，我是宋军，谢扬的分享挺好的，我也有些收获。我先简单自我介绍一下，我现在就职于 Google。Google 的 FaaS 这里有一个小的案例可以去分享，我们当时做了一个中国的一个客户，大概用了 3000 个FaaS，这家客户叫茄子快传，他们用了半年左右，但是过了半年之后基本上切回去了。&lt;/p&gt;

&lt;p&gt;问题还是在于成本，我们都在讲，Lambda 是一个按量计费的产品，所以它成本会比较低。实际上当你的业务量特别大的时候，很有可能有非常大的成本，这种成本远远超过虚拟机的成本。&lt;/p&gt;

&lt;p&gt;我的问题是，如果有开源的 FaaS 产品，你会优先使用开源 FaaS 还是云上的 FaaS？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;谢扬：&lt;/strong&gt;从我的角度来说的话，我比较倾向于直接用云的，因为我用 FaaS 就是不想管理服务器，如果还要自己再部署一套 FaaS 对我来说是不太好的。 我还认识一个阿里的朋友，他把一个项目的成本从 800 万降到了 200 万，他怎么做到的呢？他把整个项目打包到一个函项里面去了。这个案例想说的是，每个项目都有一个阈值，然后你没有过阈值，可能就是省钱，阈值一过可能就要亏钱。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;王剑宇：&lt;/strong&gt;先谢谢涛哥和谢扬带给大家的一个技术分享！ 我来自北京，我在进行一个教育创业的项目，我比较关注的是认证服务这块，我一直在考虑到底是该怎么去实现这部分功能，以前是想说自己去写认证，但是认证其实说的是实现也容易，但是你要想把它做得很完善，其实并不容易。&lt;/p&gt;

&lt;p&gt;Auth0 之前我也尝试过，但是不是太稳定，这是一个问题。然后还有一个问题，现在国内登录的习惯，大家都是用微信或者手机号，而 Auth0 对国内的这种微信还有手机的支持是没有的。AWS 的 Cognito 我也用过，也是同样的问题。所以也是这个机会，正好我想了解一下 Authing，咱们 Authing 是否更接近于国内的用户习惯。还有第二个问题，我想了解一下有没有好的工具，来简化 FaaS 开发流程的。我之前使用 FaaS 做一些图形处理，搞的非常麻烦。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;谢扬：&lt;/strong&gt;Authing 对于国内用户来说确实是更加友好的，从刚才你的描述来看，Authing 完全可以满足你的需求。再回答第二个问题，如果说要你要是跨国使用的话，那么肯定推荐 Severless.com。因为他基本上兼容市面上所有主流的云厂商。其次 Serverless 已经被腾讯战略合作了，包括他的社区其实现在是由中国人来维护的，咱们用的话其实是非常方便。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;王剑宇：&lt;/strong&gt;好的，再我问一下，因为我之前一直使用的都是国外公司的云产品，然后我就在想，就像这 Authing 这种对 AWS 的支持和对腾讯与阿里的支持，有没有一些可能，我的意思是说，他会不会更侧重于对国内一些云服务厂商的支持？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;谢扬：&lt;/strong&gt;这事有点反直觉，我们现在对 AWS 的支持反而是最好的。另外 Authing 的流量来源，第一不是中国，是美国，中国只排第二。这说明我们是必须要走国际化路线的，也符合我们一开始的战略。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;胡鹏：&lt;/strong&gt;我先简单自我介绍一下，我之前一直是在区块链领域的，然后之前的工作是钱包相关的研发。因为我们做区块链的话，可能就是思考方式就会比较倾向于那种会考虑理想化的一些场景，就像对安全的一些极端的要求，对隐私的一些极端的要求。然后像刚刚说的 FaaS 的话，其实我让我想到一个问题，就是将很多东西都交给服务器，那么服务器其实就是在这里面权限特别大，可能会有安全上的考虑，尤其是有特殊要求的人。在我们密码学里面，我们现在来看有一个方向，在云上托管的数据是加密的，然后在此基础上进行加密计算，所以我不知道你们内部的产品研发方面有没有这个方向？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;谢扬：&lt;/strong&gt;我对加密这块不是很了解，我只知道有个同态加密的东西可以在加密结果上进行计算，而不用知道原文。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;胡鹏：&lt;/strong&gt;对，关于隐私计算还有零知识证明这样的技术。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;谢扬：&lt;/strong&gt;除了刚才说的这些，还有一个东西叫做 XAdES，这个是 W3C 的一个规范，比如可以用于你的毕业证的加密，然后给到公司，公司来验证你的文凭是否是真实的，这个也可以参考一下。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;王晓亮：&lt;/strong&gt;大家好，我现在在一家珠海移动公司，主要在大数据方向，所以我们在海外主要用的 Google Cloud，在国内用 AWS。我们用 Serverless 挺久了，其实就是因为我们的业务调用很复杂，比如说我整个的数据进来，然后触发了函数之后，会存储到 S3 什么地方去，或者说有一些数据会重新把它变成结构化的一些数据，最后可能再触发一些函数再存到另外一个地方。我看中间这样的很长的周期，其实整个的监控感觉不是特别好处理，因为涉及到很多不同的服务之间的一些中转，所以我想知道这块有没有相应的解决方案。这是第一个问题，第二个问题就是想知道有没有什么整合的 FaaS 方案。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;谢扬：&lt;/strong&gt;对。这可能只能用一些微服务的这种的措施来做服务治理，你写的每一个函数都需要注册到一个中央的函数服务中心里，然后用各种勾子来 track 他的访问轨迹，最后由一个可视化的界面来展示调用记录。第二个问题我还是推荐 Serverless.com，大家用起来会比较友好。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.authing.cn/blog/20200217162159.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;</content><author><name>ivy</name></author><category term="serverless" /><summary type="html">Serverless 正在改变未来软件开发的模式和流程，对于大多数应用而言，借助 Serverless 服务，开发者可以将绝大多数精力投入在业务逻辑的开发整合上，大大缩短开发周期，降低运维成本。本次主题将与大家探讨 Serverless 生态中缺少的工具以及潜在的创业机会。</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://cdn.authing.cn/blog/20200217155500.png" /></entry><entry><title type="html">案例 | 在 Odoo 中集成 Authing 完成单点登录</title><link href="http://localhost:4000/blog/%E5%9C%A8Odoo%E4%B8%AD%E9%9B%86%E6%88%90Authing%E5%AE%8C%E6%88%90%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/" rel="alternate" type="text/html" title="案例 | 在 Odoo 中集成 Authing 完成单点登录" /><published>2020-02-11T00:00:00+08:00</published><updated>2020-02-11T00:00:00+08:00</updated><id>http://localhost:4000/blog/%E5%9C%A8Odoo%E4%B8%AD%E9%9B%86%E6%88%90Authing%E5%AE%8C%E6%88%90%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95</id><content type="html" xml:base="http://localhost:4000/blog/%E5%9C%A8Odoo%E4%B8%AD%E9%9B%86%E6%88%90Authing%E5%AE%8C%E6%88%90%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/">&lt;p&gt;Odoo 是一套基于 Web 的开源商业业务应用程序。Odoo 的主要应用包括 CRM、网站构建器、电子商务、仓库管理、项目管理、计费和会计、销售点、人力资源、市场营销和制造等。&lt;/p&gt;

&lt;p&gt;Authing 在云上提供适用于 Web、iOS 和 Android 的通用身份认证和授权平台，可以帮助开发者和企业使用全新的方式、最简单的手段解决复杂的用户身份问题。&lt;/p&gt;

&lt;p&gt;本案例为 Odoo 集成 Authing 在云上实现单点登录的教程。&lt;/p&gt;

&lt;h2 id=&quot;问题&quot;&gt;问题&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;组织需要一套统一的账号体系来管理公司内外部的员工，并且能打通 Odoo；&lt;/li&gt;
  &lt;li&gt;除 Odoo 外，还有自研的系统和其他第三方系统；&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;解决方案&quot;&gt;解决方案&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;通过在 Odoo 中配置 OAuth 2.0 集成「使用 Authing 登录」从而完成对 Odoo 的单点登录；&lt;/li&gt;
  &lt;li&gt;自研系统直接通过 Authing 的 SDK 集成，将 Authing 作为身份中台向各个业务系统分发身份；&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;什么是-oauth-20&quot;&gt;什么是 OAuth 2.0&lt;/h2&gt;

&lt;p&gt;OAuth 2.0 是目前最流行的授权机制，用来授权第三方应用，获取用户数据。
这个标准比较抽象，使用了很多术语，初学者不容易理解。其实说起来并不复杂，阮一峰老师讲的非常好，请从这篇文章查看：&lt;a href=&quot;http://www.ruanyifeng.com/blog/2019/04/oauth_design.html&quot;&gt;http://www.ruanyifeng.com/blog/2019/04/oauth_design.html&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;集成效果&quot;&gt;集成效果&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/blog/assets/images/odooxauthing/effect.webp&quot; alt=&quot;assets/images/odooxauthing/effect.webp&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如上图所示，用户点击「使用 Authing 登录」后跳转到「Authing 登录页面」，从 Authing 登录后跳回到 Odoo 完成登录。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog/assets/images/odooxauthing/authing-guard.webp&quot; alt=&quot;assets/images/odooxauthing/effect.webp&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;集成流程&quot;&gt;集成流程&lt;/h2&gt;

&lt;h3 id=&quot;在-authing-中创建-oauth-应用&quot;&gt;在 Authing 中创建 OAuth 应用&lt;/h3&gt;

&lt;p&gt;如果你还没有 Authing 账号，请到 authing.cn/login 中注册一个账号，注册完成后按照以下流程完成一个 OAuth 应用的创建。&lt;/p&gt;

&lt;p&gt;依次点击&lt;strong&gt;第三方登录&lt;/strong&gt; -&amp;gt; &lt;strong&gt;OAuth 应用&lt;/strong&gt;  -&amp;gt; &lt;strong&gt;创建 OAuth 应用&lt;/strong&gt;开始创建，如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog/assets/images/odooxauthing/oidc.webp&quot; alt=&quot;assets/images/odooxauthing/effect.webp&quot; /&gt;&lt;/p&gt;

&lt;p&gt;点击后会弹出如下对话框：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog/assets/images/odooxauthing/oauth-form.webp&quot; alt=&quot;assets/images/odooxauthing/effect.webp&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;必要参数解释&quot;&gt;必要参数解释：&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;应用名称&lt;/strong&gt;，必填，用户会在登录页面看到此应用名称；&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;认证地址&lt;/strong&gt;，必填，一个 *.authing.cn 的二级域名，用户将访问此网址进行登录；&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;回调 URL&lt;/strong&gt;，必填，回调到开发者自己业务的地址，此处请填写：
    &lt;ul&gt;
      &lt;li&gt;http://&lt;您的 Odoo=&quot;&quot; 网站域名=&quot;&quot;&gt;/auth_oauth/oea;http://&lt;您的 Odoo=&quot;&quot; 网站域名=&quot;&quot;&gt;/auth_oauth/signin；&lt;/您的&gt;&lt;/您的&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;授权模式&lt;/strong&gt;，必填，该 OAuth 应用支持的授权模式，此处请勾选「&lt;strong&gt;implicit&lt;/strong&gt;」模式：&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog/assets/images/odooxauthing/oauth-form-sample.webp&quot; alt=&quot;assets/images/odooxauthing/effect.webp&quot; /&gt;&lt;/p&gt;

&lt;p&gt;创建完成后会获得应用密钥，如下所示，请保管好此信息。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog/assets/images/odooxauthing/oauth-secret.webp&quot; alt=&quot;assets/images/odooxauthing/effect.webp&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;在-odoo-中配置使用-authing-登录&quot;&gt;在 Odoo 中配置「使用 Authing 登录」&lt;/h3&gt;

&lt;p&gt;创建完 Authing 后打开你的 Odoo 网站，依次点击&lt;strong&gt;设置&lt;/strong&gt; -&amp;gt; &lt;strong&gt;常规设置&lt;/strong&gt; -&amp;gt; &lt;strong&gt;集成&lt;/strong&gt;，找到「&lt;strong&gt;OAuth 认证&lt;/strong&gt;」后打开此开关，如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog/assets/images/odooxauthing/odoo-open.webp&quot; alt=&quot;assets/images/odooxauthing/effect.webp&quot; /&gt;&lt;/p&gt;

&lt;p&gt;打开开关后点击「OAuth 服务商」进入配置页面，如下所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog/assets/images/odooxauthing/odoo-oauth-provider.webp&quot; alt=&quot;assets/images/odooxauthing/effect.webp&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在新页面中填写以下信息：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;服务商名称&lt;/strong&gt;，必填，写 Authing 便于标识；&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;客户端 ID&lt;/strong&gt;，必填，在 Authing 平台中配置好的应用 ID；&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;允许&lt;/strong&gt;，选填，是否启用此服务商，此处请勾选；&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;正文&lt;/strong&gt;，必填，显示在 Odoo 网站上登录按钮的文字；&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;身份验证网址&lt;/strong&gt;，必填，请填写：https://sso.authing.cn/authorize/&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;作用域&lt;/strong&gt;，必填，请填写：user；&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;验证网址&lt;/strong&gt;，必填，请填写：https://sso.authing.cn/authenticate/；&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;数据网址&lt;/strong&gt;，必填，请填写：https://users.authing.cn/oauth/user/userinfo；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/blog/assets/images/odooxauthing/odoo-oauth-info.webp&quot; alt=&quot;assets/images/odooxauthing/effect.webp&quot; /&gt;&lt;/p&gt;

&lt;p&gt;填写完成并保存后访问 &lt;您的 Odoo=&quot;&quot; 网址=&quot;&quot;&gt;/web/login 可看到网页上出现了「**使用 Authing 登录**」。&lt;/您的&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog/assets/images/odooxauthing/odoo-effect.webp&quot; alt=&quot;assets/images/odooxauthing/effect.webp&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;体验登录&quot;&gt;体验登录&lt;/h2&gt;

&lt;p&gt;访问 &lt;您的 Odoo=&quot;&quot; 网址=&quot;&quot;&gt;/web/login 并点击「**使用 Authing 登录**」即可体验登录。&lt;/您的&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog/assets/images/odooxauthing/odooxauthing.webp&quot; alt=&quot;assets/images/odooxauthing/odooxauthing.webp&quot; /&gt;&lt;/p&gt;</content><author><name>ivy</name></author><category term="odoo" /><summary type="html">Odoo 是一套基于 Web 的开源商业业务应用程序。Odoo 的主要应用包括 CRM、网站构建器、电子商务、仓库管理、项目管理、计费和会计、销售点、人力资源、市场营销和制造等。</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://cdn.authing.cn/blog/20200217171108.png" /></entry><entry><title type="html">Geek Talk 036：Serverless 的前景和机会</title><link href="http://localhost:4000/blog/GeekTalk036Serverless-%E7%9A%84%E5%89%8D%E6%99%AF%E5%92%8C%E6%9C%BA%E4%BC%9A/" rel="alternate" type="text/html" title="Geek Talk 036：Serverless 的前景和机会" /><published>2020-02-10T00:00:00+08:00</published><updated>2020-02-10T00:00:00+08:00</updated><id>http://localhost:4000/blog/GeekTalk036Serverless%20%E7%9A%84%E5%89%8D%E6%99%AF%E5%92%8C%E6%9C%BA%E4%BC%9A</id><content type="html" xml:base="http://localhost:4000/blog/GeekTalk036Serverless-%E7%9A%84%E5%89%8D%E6%99%AF%E5%92%8C%E6%9C%BA%E4%BC%9A/">&lt;p&gt;本次与大家探讨 Serverless 生态中缺少的工具以及潜在的创业机会。&lt;/p&gt;

&lt;h2 id=&quot;主题serverless-的前景和机会&quot;&gt;主题：Serverless 的前景和机会&lt;/h2&gt;

&lt;p&gt;简介：Serverless 正在改变未来软件开发的模式和流程，对于大多数应用而言，借助 Serverless 服务，开发者可以将绝大多数精力投入在业务逻辑的开发整合上，大大缩短开发周期，降低运维成本。本次主题将与大家探讨 Serverless 生态中缺少的工具以及潜在的创业机会。&lt;/p&gt;

&lt;p&gt;时间：2月13日 19:00 - 21:00&lt;/p&gt;

&lt;p&gt;地点：&lt;strong&gt;线上视频会议&lt;/strong&gt;，报名确认后，邮件和微信通知视频入口。&lt;/p&gt;

&lt;p&gt;邮件发送详细地址，请确保邮箱地址和 &lt;strong&gt;微信ID&lt;/strong&gt; 正确&lt;/p&gt;

&lt;p&gt;人数：30人&lt;/p&gt;

&lt;p&gt;嘉宾：谢扬&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.authing.cn/blog/20200211201759.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;蒸汽记忆创始人，SoLiD 中文社区（learnsolid.cn）发起人，连续创业者。&lt;/p&gt;

&lt;p&gt;曾任职字节跳动 LarkCloud 云服务部门核心 Hacker，负责⽇活过亿 Serverless 平台产品设计和技术研发，该平台支撑来头条系全产品矩阵：今日头条、抖音、西瓜视频、飞书等。&lt;/p&gt;

&lt;p&gt;2016 年创⽴⻰猫科技，研发容器云和 Low/No Code 平台（Gospely.com），获得Plug and Play、PreAngel 等资本投资。曾任好东西传送⻔ CTO，负责知识推荐和亿级维度舆情分析、统计⼯作，服务数⼗万专业⼈群。&lt;/p&gt;

&lt;p&gt;⻓期关注生产⼒科技，以提⾼社会生产⼒为个⼈使命。&lt;/p&gt;

&lt;p&gt;扫描以下二维码报名：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.authing.cn/blog/20200211202308.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;关于-geek2startup&quot;&gt;关于 Geek2Startup&lt;/h2&gt;

&lt;p&gt;Geek2Startup 推出的专注于创业团队之间的小范围深度交流分享活动，定期邀请创业中 Geek 同 Startup 之间就产品、设计、开发和运营等维度进行交流，期待每次交流都能解决初创团队遇到的问题，并能互相碰撞出更多的火花，求质不求量，走心不走肾。&lt;/p&gt;

&lt;p&gt;目前已经进行超过 30 期，每一位嘉宾都很精彩。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.authing.cn/blog/20200211202415.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;</content><author><name>ivy</name></author><category term="serverless" /><summary type="html">本次与大家探讨 Serverless 生态中缺少的工具以及潜在的创业机会。</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://cdn.authing.cn/blog/20200211201759.png" /></entry></feed>