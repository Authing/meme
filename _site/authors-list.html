<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Authors | Authing 官方博客</title>

    <!-- Begin Jekyll SEO tag v2.5.0 -->
<title>Authors | Authing 官方博客</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="Authors" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Authing 为个人和企业提供安全的云端身份认证服务，是行业领先的身份认证云。" />
<meta property="og:description" content="Authing 为个人和企业提供安全的云端身份认证服务，是行业领先的身份认证云。" />
<meta property="og:site_name" content="Authing 官方博客" />
<script type="application/ld+json">
{"headline":"Authors","url":"/blog/authors-list.html","publisher":{"@type":"Organization","logo":{"@type":"ImageObject","url":"/blog/assets/images/logo.png"}},"description":"Authing 为个人和企业提供安全的云端身份认证服务，是行业领先的身份认证云。","@type":"WebPage","@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="shortcut icon" type="image/x-icon" href="/blog/assets/images/favicon.ico">

    <!-- Font Awesome Icons -->
    <link rel="stylesheet" href="https://s3.pstatp.com/cdn/expire-1-M/font-awesome/5.3.1/css/all.css" crossorigin="anonymous">

    <!-- Google Fonts-->
    <link rel="stylesheet" href="https://usercontents.authing.cn/fonts.css?family=Lora:400,400i,700">

    <!-- Bootstrap Modified -->
    <link rel="stylesheet" href="/blog/assets/css/main.css">

    <!-- Jquery on header to make sure everything works, the rest  of the scripts in footer for fast loading -->
    <script src="https://s0.pstatp.com/cdn/expire-1-M/jquery/3.3.1/jquery.min.js" integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin="anonymous"></script>

    <!-- This goes before </head> closing tag, Google Analytics can be placed here --> 


</head>

<body class="">

    <!-- Navbar -->
    <nav id="MagicMenu" class="topnav navbar navbar-expand-lg navbar-light bg-white fixed-top">
    <div class="container">
        <a class="navbar-brand" href="https://authing.cn">
            <img src="https://usercontents.authing.cn/logo/authing@256x78.png" style="height:34px">
        </a>
        <button class="navbar-toggler collapsed" type="button" data-toggle="collapse" data-target="#navbarColor02" aria-controls="navbarColor02" aria-expanded="false" aria-label="Toggle navigation">
        <span class="navbar-toggler-icon"></span>
        </button>
        <div class="navbar-collapse collapse" id="navbarColor02" style="">
            <ul class="navbar-nav mr-auto d-flex align-items-center">
               <!--  Replace menu links here -->

<li class="nav-item">
    <a class="nav-link" href="/blog/index.html">主页</a>
</li>
<li class="nav-item">
    <a class="nav-link" href="/blog/categories.html#developers">开发者</a>
</li>
<li class="nav-item">
    <a class="nav-link" href="/blog/categories.html#cases">案例</a>
</li>
<li class="nav-item">
    <a class="nav-link" href="/blog/categories.html#cultures">文化</a>
</li>
<li class="nav-item">
    <a class="nav-link" href="/blog/categories.html#news">新闻</a>
</li>
<li class="nav-item">
    <a class="nav-link" href="/blog/categories.html#solid">SoLiD 数据主权</a>
</li>    

<li class="nav-item">
    <a class="nav-link" style="border:1px solid #ced4da;border-radius:4px;margin-right:7px;padding: 0.5rem 0.7rem;" href="/blog/about.html">联系我们</a>
</li>    
<li class="nav-item">
    <a target="_blank" class="nav-link" style="background: #49a1e0;color:#fff;border:1px solid #ced4da;border-radius:4px;padding: 0.5rem 0.7rem;"  href="https://sign.authing.cn">登录/注册</a>
</li>    

            </ul>
            <ul class="navbar-nav ml-auto d-flex align-items-center">
                <script src="/blog/assets/js/lunr.js"></script>

<script>
$(function() {
    $("#lunrsearchresults").on('click', '#btnx', function () {
        $('#lunrsearchresults').hide( 1000 );
        $( "body" ).removeClass( "modal-open" );
    });
});
    

var documents = [{
    "id": 0,
    "url": "/blog/404/",
    "title": "",
    "body": " 404 Page not found :(  The requested page could not be found. "
    }, {
    "id": 1,
    "url": "/blog/about.html",
    "title": "关于",
    "body": " Authing 是中国领先的 IDaaS 服务提供商，对标美国独角兽 Auth0。创始团队来自字节跳动、百度、IBM、阿里云、滴滴出行等互联网企业。Authing 提供开发者友好、易拓展的身份认证和授权平台，赋能企业在云端管理身份，主要功能包括：单点登录、用户分析、扫码登录、多因素认证、行为审计、风险控制、跨平台设备管理、IoT 身份认证等；兼容国际各类标准协议：OAuth2. 0、OIDC、SAML、AD/LDAP、WS-Fed、JWT 等。 支持云交付和私有化部署方式，帮助企业和开发者千倍级提升生产效率。    Authing 自上线以来已经服务海内外超过 3000 名企业开发者、拥有约 50 万的开发者社区和托管数百万终端用户，每月百万人次通过 Authing 平台进行认证，并已经服务数十家付费企业客户，覆盖教育、人工智能、出版社、 物联网等多个行业。 Authing 的故事：我为什么开发 Authing？我们为什么坚持做 ToB 的慢生意 Powered by by Authing. "
    }, {
    "id": 2,
    "url": "/blog/author-jane.html",
    "title": "Jane",
    "body": "                        Jane Follow:                                                    Posts by Jane:               "
    }, {
    "id": 3,
    "url": "/blog/author-sal.html",
    "title": "Sal",
    "body": "                        Sal Follow:                                                    Posts by Sal:               "
    }, {
    "id": 4,
    "url": "/blog/authors-list.html",
    "title": "Authors",
    "body": "Authors:                                             谢扬 :       (View Posts)      Working for computer technologies that can give new possibilities to science, engineering and art, while benefiting hundreds of millions of people.                           &nbsp;       &nbsp;                                                                             廖长江 :       (View Posts)      Web fullstack developer.                           &nbsp;       &nbsp;                                                                             杜新帅 :       (View Posts)      Blogger, love to explore new ideas and write on my morning coffee!                          &nbsp;       &nbsp;                                                                             叶祖伟 :       (View Posts)      Fullstack developer who plays music.                           &nbsp;       &nbsp;                                                                             晋剑 :       (View Posts)      不骑单车好多年 ;-)                          &nbsp;       &nbsp;                                      "
    }, {
    "id": 5,
    "url": "/blog/categories.html",
    "title": "类别",
    "body": "          类别          {% for category in site. categories %}     {{ category[0] }}:           {% assign pages_list = category[1] %}    {% for post in pages_list %}    {% if post. title != null %}     {% if group == null or group == post. group %}           {% include main-loop-card. html %}     {% endif %}    {% endif %}    {% endfor %}    {% assign pages_list = nil %}    {% assign group = nil %}    {% endfor %}                  {% include sidebar-featured. html %}          "
    }, {
    "id": 6,
    "url": "/blog/contact.html",
    "title": "联系我们",
    "body": "  Please send your message to {{site. name}}. We will reply as soon as possible!   "
    }, {
    "id": 7,
    "url": "/blog/",
    "title": "Authing 官方博客",
    "body": "  {% if page. url ==  /  %}            {% assign latest_post = site. posts[0] %}          &lt;div class= topfirstimage  style= background-image: url({% if latest_post. image contains  ://  %}{{ latest_post. image }}{% else %} {{site. baseurl}}/{{ latest_post. image}}{% endif %}); height: 200px;  background-size: cover;  background-repeat: no-repeat; &gt;&lt;/div&gt;           {{ latest_post. title }}  :       {{ latest_post. excerpt | strip_html | strip_newlines | truncate: 136 }}               In         {% for category in latest_post. categories %}        {{ category }},         {% endfor %}                                {{ latest_post. date | date: '%b %d, %Y' }}                            {%- assign second_post = site. posts[1] -%}                        {% if second_post. image %}                         &lt;img class= w-100  src= {% if second_post. image contains  ://  %}{{ second_post. image }}{% else %}{{ second_post. image | absolute_url }}{% endif %}  alt= {{ second_post. title }} &gt;                        {% endif %}                                    {{ second_post. title }}          :                       In             {% for category in second_post. categories %}            {{ category }},             {% endfor %}                                                      {{ second_post. date | date: '%b %d, %Y' }}                                    {%- assign third_post = site. posts[2] -%}                        {% if third_post. image %}                         &lt;img class= w-100  src= {% if third_post. image contains  ://  %}{{ third_post. image }}{% else %}{{site. baseurl}}/{{ third_post. image }}{% endif %}  alt= {{ third_post. title }} &gt;                        {% endif %}                                    {{ third_post. title }}          :                       In             {% for category in third_post. categories %}            {{ category }},             {% endfor %}                                                      {{ third_post. date | date: '%b %d, %Y' }}                                    {%- assign fourth_post = site. posts[3] -%}                        {% if fourth_post. image %}                        &lt;img class= w-100  src= {% if fourth_post. image contains  ://  %}{{ fourth_post. image }}{% else %}{{site. baseurl}}/{{ fourth_post. image }}{% endif %}  alt= {{ fourth_post. title }} &gt;                        {% endif %}                                    {{ fourth_post. title }}          :                       In             {% for category in fourth_post. categories %}            {{ category }},             {% endfor %}                                                      {{ fourth_post. date | date: '%b %d, %Y' }}                                  {% for post in site. posts %} {% if post. tags contains  sticky  %}                    {{post. title}}                  {{ post. excerpt | strip_html | strip_newlines | truncate: 136 }}                 阅读更多            	             {% endif %}{% endfor %}  {% endif %}                所有文章:         {% for post in paginator. posts %}          {% include main-loop-card. html %}        {% endfor %}                   {% if paginator. total_pages &gt; 1 %}              {% if paginator. previous_page %}        &laquo; Prev       {% else %}        &laquo;       {% endif %}       {% for page in (1. . paginator. total_pages) %}        {% if page == paginator. page %}        {{ page }}        {% elsif page == 1 %}        {{ page }}        {% else %}        {{ page }}        {% endif %}       {% endfor %}       {% if paginator. next_page %}        Next &raquo;       {% else %}        &raquo;       {% endif %}            {% endif %}                     {% include sidebar-featured. html %}      "
    }, {
    "id": 8,
    "url": "/blog/privacy-policy.html",
    "title": "Privacy Policy",
    "body": "”{{site. name}}” takes your privacy seriously. To better protect your privacy we provide this privacy policy notice explaining the way your personal information is collected and used. Collection of Routine Information: This website track basic information about their visitors. This information includes, but is not limited to, IP addresses, browser details, timestamps and referring pages. None of this information can personally identify specific visitor to this website. The information is tracked for routine administration and maintenance purposes. Cookies: Where necessary, this website uses cookies to store information about a visitor’s preferences and history in order to better serve the visitor and/or present the visitor with customized content. Advertisement and Other Third Parties: Advertising partners and other third parties may use cookies, scripts and/or web beacons to track visitor activities on this website in order to display advertisements and other useful information. Such tracking is done directly by the third parties through their own servers and is subject to their own privacy policies. This website has no access or control over these cookies, scripts and/or web beacons that may be used by third parties. Learn how to opt out of Google’s cookie usage. Links to Third Party Websites: We have included links on this website for your use and reference. We are not responsible for the privacy policies on these websites. You should be aware that the privacy policies of these websites may differ from our own. Security: The security of your personal information is important to us, but remember that no method of transmission over the Internet, or method of electronic storage, is 100% secure. While we strive to use commercially acceptable means to protect your personal information, we cannot guarantee its absolute security. Changes To This Privacy Policy: This Privacy Policy is effective and will remain in effect except with respect to any changes in its provisions in the future, which will be in effect immediately after being posted on this page. We reserve the right to update or change our Privacy Policy at any time and you should check this Privacy Policy periodically. If we make any material changes to this Privacy Policy, we will notify you either through the email address you have provided us, or by placing a prominent notice on our website. Contact Information: For any questions or concerns regarding the privacy policy, please contact us here. "
    }, {
    "id": 9,
    "url": "/blog/tags.html",
    "title": "Tags",
    "body": "          Tags          {% for tag in site. tags %}     {{ tag[0] }}:           {% assign pages_list = tag[1] %}    {% for post in pages_list %}    {% if post. title != null %}     {% if group == null or group == post. group %}           {% include main-loop-card. html %}     {% endif %}    {% endif %}    {% endfor %}    {% assign pages_list = nil %}    {% assign group = nil %}    {% endfor %}                  {% include sidebar-featured. html %}          "
    }, {
    "id": 10,
    "url": "/blog/robots.txt",
    "title": "",
    "body": "      Sitemap: {{ “sitemap. xml”   absolute_url }}   "
    }, {
    "id": 11,
    "url": "/blog/page2/",
    "title": "Authing 官方博客",
    "body": "  {% if page. url ==  /  %}            {% assign latest_post = site. posts[0] %}          &lt;div class= topfirstimage  style= background-image: url({% if latest_post. image contains  ://  %}{{ latest_post. image }}{% else %} {{site. baseurl}}/{{ latest_post. image}}{% endif %}); height: 200px;  background-size: cover;  background-repeat: no-repeat; &gt;&lt;/div&gt;           {{ latest_post. title }}  :       {{ latest_post. excerpt | strip_html | strip_newlines | truncate: 136 }}               In         {% for category in latest_post. categories %}        {{ category }},         {% endfor %}                                {{ latest_post. date | date: '%b %d, %Y' }}                            {%- assign second_post = site. posts[1] -%}                        {% if second_post. image %}                         &lt;img class= w-100  src= {% if second_post. image contains  ://  %}{{ second_post. image }}{% else %}{{ second_post. image | absolute_url }}{% endif %}  alt= {{ second_post. title }} &gt;                        {% endif %}                                    {{ second_post. title }}          :                       In             {% for category in second_post. categories %}            {{ category }},             {% endfor %}                                                      {{ second_post. date | date: '%b %d, %Y' }}                                    {%- assign third_post = site. posts[2] -%}                        {% if third_post. image %}                         &lt;img class= w-100  src= {% if third_post. image contains  ://  %}{{ third_post. image }}{% else %}{{site. baseurl}}/{{ third_post. image }}{% endif %}  alt= {{ third_post. title }} &gt;                        {% endif %}                                    {{ third_post. title }}          :                       In             {% for category in third_post. categories %}            {{ category }},             {% endfor %}                                                      {{ third_post. date | date: '%b %d, %Y' }}                                    {%- assign fourth_post = site. posts[3] -%}                        {% if fourth_post. image %}                        &lt;img class= w-100  src= {% if fourth_post. image contains  ://  %}{{ fourth_post. image }}{% else %}{{site. baseurl}}/{{ fourth_post. image }}{% endif %}  alt= {{ fourth_post. title }} &gt;                        {% endif %}                                    {{ fourth_post. title }}          :                       In             {% for category in fourth_post. categories %}            {{ category }},             {% endfor %}                                                      {{ fourth_post. date | date: '%b %d, %Y' }}                                  {% for post in site. posts %} {% if post. tags contains  sticky  %}                    {{post. title}}                  {{ post. excerpt | strip_html | strip_newlines | truncate: 136 }}                 阅读更多            	             {% endif %}{% endfor %}  {% endif %}                所有文章:         {% for post in paginator. posts %}          {% include main-loop-card. html %}        {% endfor %}                   {% if paginator. total_pages &gt; 1 %}              {% if paginator. previous_page %}        &laquo; Prev       {% else %}        &laquo;       {% endif %}       {% for page in (1. . paginator. total_pages) %}        {% if page == paginator. page %}        {{ page }}        {% elsif page == 1 %}        {{ page }}        {% else %}        {{ page }}        {% endif %}       {% endfor %}       {% if paginator. next_page %}        Next &raquo;       {% else %}        &raquo;       {% endif %}            {% endif %}                     {% include sidebar-featured. html %}      "
    }, {
    "id": 12,
    "url": "/blog/page3/",
    "title": "Authing 官方博客",
    "body": "  {% if page. url ==  /  %}            {% assign latest_post = site. posts[0] %}          &lt;div class= topfirstimage  style= background-image: url({% if latest_post. image contains  ://  %}{{ latest_post. image }}{% else %} {{site. baseurl}}/{{ latest_post. image}}{% endif %}); height: 200px;  background-size: cover;  background-repeat: no-repeat; &gt;&lt;/div&gt;           {{ latest_post. title }}  :       {{ latest_post. excerpt | strip_html | strip_newlines | truncate: 136 }}               In         {% for category in latest_post. categories %}        {{ category }},         {% endfor %}                                {{ latest_post. date | date: '%b %d, %Y' }}                            {%- assign second_post = site. posts[1] -%}                        {% if second_post. image %}                         &lt;img class= w-100  src= {% if second_post. image contains  ://  %}{{ second_post. image }}{% else %}{{ second_post. image | absolute_url }}{% endif %}  alt= {{ second_post. title }} &gt;                        {% endif %}                                    {{ second_post. title }}          :                       In             {% for category in second_post. categories %}            {{ category }},             {% endfor %}                                                      {{ second_post. date | date: '%b %d, %Y' }}                                    {%- assign third_post = site. posts[2] -%}                        {% if third_post. image %}                         &lt;img class= w-100  src= {% if third_post. image contains  ://  %}{{ third_post. image }}{% else %}{{site. baseurl}}/{{ third_post. image }}{% endif %}  alt= {{ third_post. title }} &gt;                        {% endif %}                                    {{ third_post. title }}          :                       In             {% for category in third_post. categories %}            {{ category }},             {% endfor %}                                                      {{ third_post. date | date: '%b %d, %Y' }}                                    {%- assign fourth_post = site. posts[3] -%}                        {% if fourth_post. image %}                        &lt;img class= w-100  src= {% if fourth_post. image contains  ://  %}{{ fourth_post. image }}{% else %}{{site. baseurl}}/{{ fourth_post. image }}{% endif %}  alt= {{ fourth_post. title }} &gt;                        {% endif %}                                    {{ fourth_post. title }}          :                       In             {% for category in fourth_post. categories %}            {{ category }},             {% endfor %}                                                      {{ fourth_post. date | date: '%b %d, %Y' }}                                  {% for post in site. posts %} {% if post. tags contains  sticky  %}                    {{post. title}}                  {{ post. excerpt | strip_html | strip_newlines | truncate: 136 }}                 阅读更多            	             {% endif %}{% endfor %}  {% endif %}                所有文章:         {% for post in paginator. posts %}          {% include main-loop-card. html %}        {% endfor %}                   {% if paginator. total_pages &gt; 1 %}              {% if paginator. previous_page %}        &laquo; Prev       {% else %}        &laquo;       {% endif %}       {% for page in (1. . paginator. total_pages) %}        {% if page == paginator. page %}        {{ page }}        {% elsif page == 1 %}        {{ page }}        {% else %}        {{ page }}        {% endif %}       {% endfor %}       {% if paginator. next_page %}        Next &raquo;       {% else %}        &raquo;       {% endif %}            {% endif %}                     {% include sidebar-featured. html %}      "
    }, {
    "id": 13,
    "url": "/blog/LDAP-%E5%8D%8F%E8%AE%AE%E5%85%A5%E9%97%A8/",
    "title": "LDAP 协议入门",
    "body": "2020/04/16 - ​什么是 LDAP？LDAP 的全称是 Lightweight Directory Access Protocol，轻量目录访问协议。 划重点，LDAP 是一个协议，约定了 Client 与 Server 之间的信息交互格式、使用的端口号、认证方式等内容。而 LDAP 协议的实现，有着众多版本，例如微软的 Active Directory 是 LDAP 在 Windows 上的实现，AD 实现了 LDAP 所需的树形数据库、具体如何解析请求数据并到数据库查询然后返回结果等功能。再例如 OpenLDAP 是可以运行在 Linux 上的 LDAP 协议的开源实现。而我们平常说的 LDAP Server，一般指的是安装并配置了 Active Directory、OpenLDAP 这些程序的服务器。 ​LDAP 协议能解决什么问题？要说 LDAP 协议能解决什么问题，那不得不提 AD。AD 是 Windows 服务器上最强大的功能，AD 是基于 LDAP 协议的一套解决方案（LDAP 服务器 + 应用），解决了细粒度的权限控制。核心：谁 以什么权限 访问什么。 ​用户服务: 管理用户的域账号、用户信息、企业通信录（与电子邮箱系统集成）、用户组管理、用户身份认证、用户授权管理、按需实施组管理策略等。在 Windows 下，有组策略管理器，如果启用域用户认证，那么这些组策略可以统一管理，方便地限制用户的权限。 计算机管理: 管理服务器及客户端计算机账户、所有服务器及客户端计算机加入域管理并按需实施组策略，甚至可以控制计算机禁止修改壁纸。（什么？给电脑重装系统就能解除限制？那么所有域上的资源都会无法访问了。） 资源管理: 管理打印机、文件共享服务、网络资源等实施组策略。 应用系统的支持: 对于电子邮件（Exchange）、在线及时通讯（Lync）、企业信息管理（SharePoint）、微软 CRM，ERP 等业务系统提供数据认证（身份认证、数据集成、组织规则等）。这里不单是微软产品的集成，其它的业务系统根据公用接口的方式一样可以嵌入进来。 为什么要用 LDAP 协议？历史原因，LDAP 协议诞生于 1988 年，比万维网的诞生还要早。1989 年英国科学家蒂姆·伯纳斯-李发明了万维网。因此沿用至今。 树形用户目录，树形存储结构，对组织管理建模符合直觉。 开放的标准化协议，受到广泛支持。 ​LDAP 拆而析之什么叫轻量？: LDAP 协议之前有一个 X. 500 DAP 协议规范，该协议十分复杂，是一个重量级的协议，后来对 X. 500 进行了简化，诞生了 LDAP 协议，与 X. 500 相比变得较为轻量。由 X. 500 DAP -&gt; LDAP，其实 LDAP 协议依然复杂。 什么叫目录？: 目录指的是用户目录，用户目录长这样： 复杂一点的是这样： 还有这样的： 目录服务就是按照树状存储信息的模式。目录服务的数据类型主要是字符型, 而不是关系数据库提供的整数、浮点数、日期、货币等类型。为了检索的需要添加了 BIN（二进制数据）、CIS（忽略大小写）、CES（大小写敏感）、TEL（电话型）等语法（Syntax）。同样也不提供象关系数据库中普遍包含的大量的函数。目录有很强的查询（读）功能，适合于进行大量数据的检索；但目录一般只执行简单的更新（写）操作，不支持批量更新所需要的事务处理功能；它主要面向数据的查询服务（查询和修改操作比一般是大于 10:1），不提供事务的回滚（rollback）机制；目录具有广泛复制信息的能力，适合于多个目录服务器同步/更新。 ​LDAP 数据库的信息组织形式目录服务的数据库以树形方式存储数据，也是一种 NoSQL。需要注意的是这是推荐的底层数据存储方式，因为目录服务查询比写入要多得多，所以使用树形数据库存储要有优势。但其实也可以使用 MySQL 或 MongoDB 这样的数据库当做 LDAP 数据源。LDAP 只是一个协议，约定的是 C/S 之间的通信方式。理论上服务器只要能够处理所有 LDAP 协议规定的操作，并返回正确的结果就可以。 专有名词解释在上面的用户目录中，有许多英文缩写。其实并不神秘，只是一些单词的缩写，接下来我们解释一些专有名词。在与 LDAP 打交道的过程中，这些名词一定会频繁遇到。 ​DIT（Directory Information Tree）目录信息树: LDAP directory servers present data arranged in tree-like hierarchies in which each entry may have zero or more subordinate entries. This structure is called the Directory Information Tree, or DIT. LDAP 目录服务器将信息以树形的方式组织，每一项都可以包含 0 个或多个子项。这样的结构叫做目录信息树。 目录信息树可以类比我们的磁盘文件系统目录树，上面的定义是官方定义，理解起来，DIT 就是指像文件系统一样的目录结构树。 ​Entry 项: 在用户目录中，你看到的每一行，都可以叫做一项，不论是叶子节点还是中间的节点。 项包含一个 DN，一些属性，一些对象类。 ​Root DSE（Root DSA-specific entry）根节点项: 每个 LDAP 服务器必须对外暴露一个特殊的项，叫做 root DSE，这个项的 DN 是空字符串。这个项是根节点，描述了 LDAP 服务器自身的信息和能力。例如你可以在下图看到 LDAP 服务器支持的功能，LDAP 协议版本等信息。 ​dn（Distinguished Name）分辨名: dn 如下图白色方框中的内容，分辨名用于唯一标识一个项，以及他在目录信息树中的位置。可以和文件系统中文件路径类比。类似于关系型数据库中的主键。dn 字符串从左向右，各组成部分依次向树根靠近。 ​rdn（Relative Distinguished Name）相对分辨名: Rdn 就是键值对，如下图黄色方框中的内容。dn 由若干个 rdn 组成，以逗号分隔。 ​dc（Distinguished Name）（域名组成）: 将 example. comexample. com 这样的域名，拆成 dc=example,dc=com 这样的形式。 ​o（Organization）组织机构、公司: 在 dn 中可能会包含 o=公司 这样的组成部分，这里的 o 指代组织机构。 ​ou（Organization Unit）组织单元、部门: 在 dn 中可能会包含 ou=某某部门 这样的组成部分，这里的 ou 指代组织单元。 ​Object Classes: 每个项里面包含若干个 Object Classes，Object Class 指定了本项中必须、可能包含的属性，相当于 MySQL 中的建表语句。包含某个 Object Class 的项，必须满足 Object Class 中约定的规范。如下图，person objectClass 中规定了 cn 和 sn 属性必须存在，在这一项的属性中，你可以看到 cn 和 sn 被加粗显示了。 下图是 person Object class 的定义，规定了拥有此 Object class 的项需要拥有的属性： 总结LDAP 协议是一个历史悠久的协议，诞生时间早于万维网。在当时商业数据库并不发达，而且当时商业数据库的驱动在多语言支持上也不友好——有可能这个数据库在你使用的编程语言上根本没有相关的开发包。LDAP 一直沿用至今，有很多的历史原因，因此许多应用都会支持通过 LDAP 登录。 LDAP 协议的用户目录是树形结构，天然与组织机构契合，而且在查询上速度非常快，比任何其他数据库都要快。 如果你想快速与 LDAP 服务器对接，不妨试一试试一试 Authing 的 LDAP 对接功能。 只要填好 LDAP 服务器的信息，然后点击保存。 还能够方便地测试 LDAP 服务器的连通性和用户登录凭据的合法性。 然后就可以使用 LDAP 进行登录了。 示例应用：https://ldap-test. authing. cn 教程文档：https://docs. authing. cn/authing/authentication/ldap/ldap 扫码查看直播回放 "
    }, {
    "id": 14,
    "url": "/blog/AWS-KMS-%E7%A7%91%E6%99%AE-What-Why-and-How/",
    "title": "AWS KMS 科普: What Why and How?",
    "body": "2020/04/03 - AWS KMS 科普: What Why and How?What: 密钥管理 —— 加密并不难，难的是密钥管理: AWS KMS 全称为 Key Management Service，中文直译过来为密钥管理服务 —— 这一点很重要，它提供的核心服务是密钥管理，帮助企业、开发者方便安全地管理密钥。很多刚接触 KMS 的同学经常搞不清 KMS 到底做是做什么的，很大原因也是没仔细注意到 Key Management 这两个词。 所以我们的第一个问题「What」就已经回答了，KMS 就是一个管理密钥的服务，它并不是某种 super super magic 的高超加密方法。  我希望本文的读者通过阅读能意识到一个观念：加密是简单的，难的是管理密钥本身。 Why: KMS 能确保你密钥的安全性: 接着来看第二个问题：Why ？为什么我需要把我的密钥给你管理，我自己保存不行了吗？事实上你完全可以自己管理，就像你完全可以自建机房一样，only if 你清楚各种最佳实践并愿意花时间自己去维护。服务之所以叫服务，是服务提供商为你做了各种各样麻烦的事情（They deal with those heavy lifting），从而让你把更多的时间精力花在更有价值的事情上。 那么 AWS KMS 为用户做了哪些麻烦的工作呢？  完全托管：你不需要额外的服务器，不需要额外的维护人员。 简化加密过程：你不需要去在意繁琐的加密细节过程，只需要调用相关接口就行了。 安全审计功能：关能够确保安全是不够的，你还需要知道谁具备这个密钥的使用权限，谁在什么时候用了这个密钥，谁又在什么时候删了这个密钥。这一点对大型企业以及提供平台服务的公司非常重要。而这些能够精确到非常细颗粒度的审计功能，已经被 AWS 通过 AWS Cloud Trail Service 完全内置在整个 AWS 生态内了。（It’s not enough to be secure, you have to demonstrate to somebody, whether that’s internal audit, your boss, or maybe your customers .  ） 确保你的密钥是安全的：你不需要费劲脑汁想办法把你的密钥保存在某个机密的、不对外网暴露的地方。事实上 AWS KMS 的密钥（确切来说是 Matser Key）是完全保存在内存中的，没有任何人（包括 AWS 自己）能够获取到密钥的原始内容，下文会介绍为什么。 密钥 rotate 流程：AWS 会定时或手动刷新密钥内容，这也是密钥管理的一个最佳实践。How: It’s complicated but they do it for you: 知道了为什么使用 AWS KMS，接下来也是本文重点内容，了解一下 How: KMS 内部实现原理。 首先了解一下对称加密与非对称加密：简要来说，对称加密指的是加密、解密用的是同一个密钥；非对称加密指的是加密、解密使用一对密钥：公钥和私钥，你可以使用公钥加密私钥解密，也可以反过来。如 HTTPS 用的就是非对称加密。 接下来看看 KMS 内部是如何保存你的密钥的：假设我们有一个用于加密数据的密钥，叫做 Data Key，将 Data 加密过后得到 Encrypted Data，这个过程很简单。 但是问题来了，该怎么处理 Data Key 呢，要是攻击者获取到了 Data Key，那不相当于数据也就被破解了？正确的选择是把 Data Key 也用某种密钥（这里把它叫做 Matser Key）加密一下（术语叫做 Wrapping），得到 Encrypted Data Key 。接着我们把 Encrypted Data 和 Encrypted Data Key 保存在一起，如下图所示： 可是问题又来了：Master Key 怎么加密？相信你已经察觉出来了，这很像一个俄罗斯套娃（划掉） 你没有看错，AWS KMS 还真就是这么做的，他们这样一层一层加密密钥（专业名词叫做 KMS Key Hierarchy），到最终的那个 Key 的时候，它的确是一个明文，但是：  它完完全全保存在内存里面，永远不会在物理介质里面保存下来。 它永远不会在公网传输。以至于连 AWS 员工都没有办法获取到原始内容。 那么其他的 Data Key 呢？我真正加密的数据的数据用的是 Data Key，要是 Data Key 泄漏了怎么办？这个问题很重要。那么 KMS 是如何解决的呢？ KMS 的 Data Key 是在内存中动态生成的，用于加密数据过后，它就在内存中被删掉了，只有加密过后的 Encrypted Data Key 保留了下来。 借用 AWS re:Invent 2019 上 AWS Solution Architect Peter M. O’Donnell 的话：  KMS is a very serious service, built by very serious people for very serious customers . 总结一下：  Data 是用 Data Key 加密的，得到 Encrypted Data。 Encrypted Data 和 Encrypted Data Key 保存在了一起。 你就算得到了 Encrypted Data 和 Encrypted Data Key 也没用，你还得得到上一层加密此 Encrypted Data Key 的 Matser Key，一层一层往上，你得知道最终那个在 Top Level 的 Master Key。 KMS 在根本上通过设计，确保了没有任何人能够获取到 Top Level Master Key。 所以你的数据是安全的。这篇文章介绍了 AWS KMS 是什么、为什么要用 KMS 以及 KMS 是如何保护你的密钥从而保护你的数据的，下一篇我们从实际应用的角度，来看看该怎么将 KMS 具体应用到你的系统中。 相关阅读：  https://amazonaws-china. com/kms/ AWS re:Invent 2019: Using AWS KMS for data protection, access control, and audit AWS Security Basics - AWS KMS"
    }, {
    "id": 15,
    "url": "/blog/%E5%BC%A0%E5%B0%8F%E9%BE%99%E7%9C%8B%E4%BA%86%E6%83%B3%E7%82%B9%E8%B5%9E-%E7%94%A8%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E7%99%BB%E5%BD%95%E9%98%BF%E9%87%8C%E4%BA%91/",
    "title": "张小龙看了想点赞 —— 用企业微信登录阿里云 ¿",
    "body": "2020/04/02 -  很多企业都在使用企业微信进行组织机构管理，同时又使用了阿里云的服务，我们不希望单独为每个员工创建一个阿里云子账号，要是能够直接使用企业微信登录就好了。这时候如何统一用户目录和实现单点登录就成了一个我们需要思考的问题。 阿里云在自己的单点登录管理（SSO）中介绍到，可以使用 SAML 协议提供单点登录管理，流程图如下： 阿里云与企业进行用户 SSO 时，阿里云是服务提供商（SP），而企业自有的身份管理系统则是身份提供商（IdP）。通过用户SSO，企业员工在登录后，将以 RAM 用户身份访问阿里云。  暂时先不用管 SAML 是什么，下文会详细讲到，这里简单理解为一种用户身份问答协议就行了。 当管理员在完成用户 SSO 的相关配置后，企业员工 Alice 可以通过上图所示的方法登录到阿里云。  Alice 使用浏览器登录阿里云，阿里云将 SAML 认证请求返回给浏览器。 浏览器向 IdP 转发 SAML 认证请求。 IdP 提示 Alice 登录，并在Alice登录成功后生成 SAML 响应返回给浏览器。 浏览器将 SAML 响应转发给 SSO 服务。 SSO 服务通过SAML互信配置，验证 SAML 响应的数字签名来判断 SAML 断言的真伪，并通过 SAML断言的 NameID 元素值，匹配到对应阿里云账号中的 RAM 用户身份。 SSO服务向浏览器返回控制台的URL。总结一下重要的点：IdP （身份提供商），也即企业用户，有一套自己的用户目录，至于这个用户目录具体是怎样的，你是用数据库存还是 Excel 存，你是用账号密码登录还是支持第三方社会化登录，阿里云并不操心。重要的是你的用户目录需要和阿里云 RAM 用户身份建立一对一关系。具体到 SAML 协议，你需要把你的用户目录的用户唯一字段作为 NameID 传给阿里云，这样阿里云就能够知道该以哪个 RAM 用户身份登录阿里云了。 于是我们的问题就 Break Down 为下面几步：  为你的用户目录支持 SAML 协议 为你的用户目录支持企业微信登录 将你的用户目录和阿里云用户角色之间建立一对一关系。如果你对其中某一部分很了解，可以跳过对应章节。 支持 SAML 协议: 首先科普一下 SAML 是什么：SAML 全称是 Security Assertion Markup Language （中文直译为「安全断言标记语言」），从字面意义我们还看不出什么头绪。 我们从协议交互角度切入：SAML 认证流程一般都会牵涉到两方：服务提供方（SP）和身份提供方（IdP），典型的 SP 有阿里云、腾讯云以及很多很多的 SaaS 服务；IdP 其实就是我们企业自己，因为用户目录在我们这里。访问 SP 服务的时候，SP 会向 IdP 发送一个 SAML Request（具体是什么我们暂时不关心），请求 IdP 判断用户身份。IdP 收到 SAML Request 后，可以通过某种手段对用户身份进行认证，如果已登录，可以直接返回用户身份信息给 SP；如果未登录，可以弹出一个登录框，用户登录之后再将用户身份返回给 SP。SP 收到用户信息之后，再在自己的数据库里面找出对应的用户，然后以这个用户的身份访问 SP 服务。 SAML 协议的具体实现过于复杂，不建议自己从零实现，可以借助已有开源库实现，比如：  NodeJS 的 samlify Python 的 python-saml Java 的 java-saml一般来说，如果你作为 IdP ，需要将自己内部用户目录数据库的字段和 SAML 字段对齐，并实现 metadata 、 SingleSignOnService 和 SingleLogoutService 接口，分别实现获取 IdP 元信息、单点登录和单点登出。具体代码实现这里就不详细讲了，感兴趣的可以用开源库实现一下，或者你也可以考虑使用我们的 SAML 服务。 支持企业微信登录: 企业微信支持两种身份认证方式：网页授权登录（指在企业微信 APP 内打开的网页，不适用于普通的浏览器网页）和扫码登录，这里我们主要讲如何接入扫码登录。  BTW: 如果你对扫码登录原理感兴趣，可以看看我们之前写的如何从零实现扫码登录系列文章。 企业微信扫码登录流程如下：用户进入第三方网站，且这个网站支持使用企业微信登录，用户使用企业微信扫码登录之后，企业微信会将登录授权码返回给你，接着你就可以使用这个授权码换取用户信息了。 首先你需要拼接一个微信扫码登录链接，如下图所示： https://open. work. weixin. qq. com/wwopen/sso/3rd_qrConnect?appid=ww100000a5f2191&amp;redirect_uri=http%3A%2F%2Fwww. oa. com&amp;state=web_login@gyoss9&amp;usertype=member appid 为服务商的CorpID redirect_uri 为用户授权之后企业微信服务器转发授权码的地址。 usertype 为支持登录的类型。admin代表管理员登录（使用微信扫码）,member代表成员登录（使用企业微信扫码），默认为admin。用户同意授权之后，会转发登录授权码给上面填写的 redirect_uri，你可以用它来换取用户信息： POST https://qyapi. weixin. qq. com/cgi-bin/service/get_login_info?access_token=PROVIDER_ACCESS_TOKENPOST 请求 body 为： {  auth_code : xxxxx }其中 auth_code 就是登录授权码，PROVIDER_ACCESS_TOKEN 是服务商凭证，你可以在这里看到如何获取服务商凭证。换取用户信息之后，你可以将其保持至自己的数据库。 具体的细节就不多说了，还牵涉到配置 IP 白名单，添加可信任域名等，如果你感兴趣，可以看企业微信的开发文档。当然，如果你不想自己实现，我们也提供这个服务。 用户目录和阿里云用户角色对齐: 如果你实现好了 SAML 协议，你有个有一个接口可以用于下载 IdP Metadata，需要将其上传给阿里云。 在阿里云添加用户: 使用你的阿里云账号登录阿里云的控制台。在你的用户头像上悬停鼠标，出现下拉菜单，点击「访问控制」。 进入左侧菜单 -&gt; 人员管理 -&gt; 用户，点击「新建用户」。 输入用户名称、显示名称，勾选控制台密码登录并点击「确认」。本教程中输入的登录名称是 authing，显示名称也是 authing。 点击左侧菜单 -&gt; 人员管理 -&gt; 用户，在右侧页面的列表中可以看到刚刚添加的用户，记录下用户登录名称（xxx@xxx. onaliyun. com），随后会用到。点击对应用户条目右侧的「添加权限」。 在权限列表中选择需要赋予该账户的权限，本教程选择「AdministratorAccess」最高权限。点击「确定」。 进入左侧菜单 -&gt; SSO 管理，右侧页面点击「用户 SSO」选项卡，在下方 SSO 登录设置处点击「编辑」。 SSO 功能状态选择「开启」。点击「上传文件」，上传你的 SAML IdP Metadata。点击「确认」。 在你的用户目录进行对齐: 上一步在阿里云配置好了账号，用户名为 xxx@xxx. onaliyun. com ，接下来需要将其映射到你的用户目录。方法很简单，你只需要将对应企业微信登录用户的 NameID 设置成 xxx@xxx. onaliyun. com 即可。 总结: 这篇文章，我们介绍了如何利用 SAML 协议将企业微信和阿里云建立起联系。总结一下，我们一共实现了三件事情：  接入 SAML 协议 接入企业微信登录 将阿里云 RAM 用户和自己的用户目录打通事实上，企业微信登录只是某种登录手段，你也完全可以支持 GitHub 登录、微博登录、手机号验证码登录、生物指纹登录 …. . 任何你能想到的登录方式都可以。 而上述这些东西，Authing 都支持，我们有非常丰富的社会化登录手段，除了企业微信，我们还支持 GitHub、微信、微博、钉钉、QQ、支付宝、小程序等。 我们还封装了简单易用的 SAML 协议，让你可以只需要填写自己简单的配置文件，就拥有一个完整的 SAML 协议实现以及一个美观易用的登录表单： 如果你不想关心具体的技术细节，完全可以直接使用 Authing 开箱即用的服务，将更多的精力集中到核心业务上。 欢迎体验：https://authing. cn "
    }, {
    "id": 16,
    "url": "/blog/%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87OIDC%E5%8D%8F%E8%AE%AE%E5%AE%9E%E7%8E%B0%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/",
    "title": "五分钟理解什么是 OIDC",
    "body": "2020/03/27 - 如何通过OIDC协议实现单点登录什么是单点登录我们通过一个例子来说明，假设有一所大学，内部有两个系统，一个是邮箱系统，一个是课表查询系统。现在想实现这样的效果：在邮箱系统中登录一遍，然后此时进入课表系统的网站，无需再次登录，课表网站系统直接跳转到个人课表页面，反之亦然。比较专业的定义如下： 单点登录（Single Sign On），简称为 SSO，是目前比较流行的企业业务整合的解决方案之一。 SSO 的定义是在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统。 为什么要实现单点登录单点登录的意义在于能够在不同的系统中统一账号、统一登录。用户不必在每个系统中都进行注册、登录，只需要使用一个统一的账号，登录一次，就可以访问所有系统。 通过 OIDC 协议实现单点登录创建自己的用户目录: 用户目录这个词很贴切，你的系统的总用户表就像一本书一样，书的封皮上写着“所有用户”四个字。打开第一页，就是目录，里面列满了用户的名字，翻到对应的页码就能看到这个人的邮箱，手机号，生日信息等等。无论你开发多少个应用，要确保你有一份这些应用所有用户信息的 truth source。所有的注册、认证、注销都要到你的用户目录中进行增加、查询、删除操作。你要做的就是创建一个中央数据表，专门用于存储用户信息，不论这个用户是来自 A 应用、B 应用还是 C 应用。 什么是 OIDC 协议: OIDC 的全称是 OpenID Connect，是一个基于 OAuth 2. 0 的轻量级认证 + 授权协议，是 OAuth 2. 0 的超集。它规定了其他应用，例如你开发的应用 A（XX 邮件系统），应用 B（XX 聊天系统），应用 C（XX 文档系统），如何到你的中央数据表中取出用户数据，约定了交互方式、安全规范等，确保了你的用户能够在访问所有应用时，只需登录一遍，而不是反反复复地输入密码，而且遵循这些规范，你的用户认证环节会很安全。 架设自己的 OIDC Provider: 什么是 OIDC Provider 呢？我来举一个例子：你经常见到一些网站的登录页面上有「使用 Github 登录」、「使用 Google 登录」这样的按钮。要想集成这样的功能，你要先去 Github 那里注册一个 OAuth App，填写一些资料，然后 Github 分配给你一对 id 和 key。 此时 Github 扮演的角色就是 OIDC Provider，你要做的就是把 Github 的这种角色的行为，搬到你自己的服务器来。 在 Github 上面搜索 OIDC Provider 会有很多结果： JS：https://github. com/panva/node-oidc-provider Golang：https://github. com/dexidp/dex Python：https://github. com/juanifioren/django-oidc-provider … 不再一一列举，你需要选择适合你的编程语言的 OIDC Provider 包，然后让它在你的服务器上运行起来。本文使用 JS 语言的 node-oidc-provider。 示例代码 Github: 可以在 Github 找到本文示例代码： https://github. com/Authing/implement-oidc-sso-demo. git 创建文件夹: 我们首先创建一个文件夹，用于存放代码： $ mkdir demo$ cd demo克隆仓库: 然后我们将 https://github. com/panva/node-oidc-provider. git 仓库 clone 到本地 $ git clone https://github. com/panva/node-oidc-provider. git安装依赖: $ cd node-oidc-provider$ npm install在 OIDC Provider 申请一个 Client: 上一步讲到，Github 会分配给你一对 id 和 key，这一步其实就是你在 Github 申请了一个 Client。那么如何向我们自己的服务器上的 OIDC Provider 申请一对这样的 id 和 key 呢？ 以 node-oidc-provider 举例，最快的获得一个 Client 的方法就是将 OIDC Client 所需的元数据直接写入 node-oidc-provider 的配置文件里面。 Wait wait wait，跨度有些大，这两者之间有什么关系？首先我们看，在 Github 上填写应用信息，然后提交，会发送一个 HTTP 请求到 Github 服务器。Github 服务器会生成一对 id 和 key，还会把它们与你的应用信息存储到 Github 自己的数据库里。所以，我们将 OIDC Client 所需的元数据直接写入到配置文件，可以理解成，我们在自己的数据库里手动插入了一条数据，为自己指定了一对 id 和 key 还有其他的一些 OIDC Client 信息。 修改配置文件: 进入 node-oidc-provider 项目下的 example 文件夹： $ cd . /example编辑 . /support/configuration. js ，更改第 16 行的 clients 配置，我们为自己指定了一个 client_id 和一个 client_secret，其中的 grant_types 为授权模式，authorization_code 即授权码模式，redirect_uris 数组是允许的业务回调地址，需要填写 Web App 应用的地址，OIDC Provider 会将临时授权码发送到这个地址，以便后续换取 token。 module. exports = { clients: [  {   client_id: '1',   client_secret: '1',   grant_types: ['refresh_token', 'authorization_code'],   redirect_uris: ['http://localhost:8080/app1. html', 'http://localhost:8080/app2. html'],  }, ],. . . }启动 node-oidc-provider: 在 node-oidc-provider/example 文件夹下，运行以下命令来启动我们的 OP： $ node express. js到现在，我们的准备工作已经完成了，在讲如何在 Web App 中进行单点登录之前，我们先了解一下 OIDC 授权码模式。刚刚提到的许多术语：授权码模式、业务回调地址、临时授权码，可能这些概念你会感到陌生，下文会详细介绍。 OIDC 授权码模式: 以下是 OIDC 授权码模式的交互模式，你的应用和 OP 之间要通过这样的交互方式来获取用户信息。 我们的 OIDC Provider 对外暴露一些接口 授权接口: 每次调用这个接口，就像是对 OIDC Provider 喊话：我要登录，如第一步所示。 然后 OIDC Provider 会检查当前用户在 OIDC Provider 的登录状态，如果是未登录状态，OIDC Provider 会弹出一个登录框，与终端用户确认身份，登录成功后会将一个临时授权码（一个随机字符串）发到你的应用（业务回调地址）；如果是已登录状态，OIDC Provider 会将浏览器直接重定向到你的应用（业务回调地址），并携带临时授权码（一个随机字符串）。如第二、三步所示。 token 接口: 每次调用这个接口，就像是对 OIDC Provider 说：这是我的授权码，给我换一个 access_token。如第四、五步所示。 用户信息接口: 每次调用这个接口，就像是对 OIDC Provider 说：这是我的 access_token，给我换一下用户信息。到此用户信息获取完毕。 为什么这么麻烦？直接返回用户信息不行吗？ 因为安全，关于 OIDC 协议的安全性，又可以展开很大的篇幅，现在简单解释一下：code 的有效期一般只有十分钟，而且一次使用过后作废。OIDC 协议授权码模式中，只有 code 的传输经过了用户的浏览器，一旦泄露，攻击者很难抢在应用服务器拿这个 code 换 token 之前，先去 OP 使用这个 code 换掉 token。而如果 access_token 的传输经过浏览器，一般 access_token 的有效期都是一个小时左右，攻击者可以利用 access_token 获取用户的信息，而应用服务器和 OP 也很难察觉到，更不必说去手动撤退了。如果直接传输用户信息，那安全性就更低了。一句话：避免让攻击者偷走用户信息。 编写第一个应用: 我们创建一个 app1. html 文件来编写第一个应用 demo，在 demo/app 目录下创建： $ touch app1. html并写入以下内容： &lt;!DOCTYPE html&gt;&lt;html lang= en &gt; &lt;head&gt;  &lt;meta charset= UTF-8  /&gt;  &lt;meta name= viewport  content= width=device-width, initial-scale=1. 0  /&gt;  &lt;title&gt;第一个应用&lt;/title&gt; &lt;/head&gt; &lt;body&gt;  &lt;a href= http://localhost:3000/auth?client_id=1&amp;redirect_uri=http://localhost:8080/app1. html&amp;scope=openid profile&amp;response_type=code&amp;state=455356436 &gt;登录&lt;/a&gt; &lt;/body&gt;&lt;/html&gt;编写第二个应用: 我们创建一个 app2. html 文件来编写第二个应用 demo，注意 redirect_uri 的变化，在 demo/app 目录下创建： $ touch app2. html并写入以下内容： &lt;!DOCTYPE html&gt;&lt;html lang= en &gt; &lt;head&gt;  &lt;meta charset= UTF-8  /&gt;  &lt;meta name= viewport  content= width=device-width, initial-scale=1. 0  /&gt;  &lt;title&gt;第二个应用&lt;/title&gt; &lt;/head&gt; &lt;body&gt;  &lt;a href= http://localhost:3000/auth?client_id=1&amp;redirect_uri=http://localhost:8080/app2. html&amp;scope=openid profile&amp;response_type=code&amp;state=455356436 &gt;登录&lt;/a&gt; &lt;/body&gt;&lt;/html&gt;向 OIDC Provider 发起登录请求: 现在我们启动一个 web 服务器，推荐使用 http-server $ npm install -g http-server # 安装 http-server$ cd demo/app$ http-server . 我们访问第一个应用：http://localhost:8080/app1. html 然后点击「登录」，也就是访问 OIDC Provider 的授权接口。然后我们来到了 OIDC Provider 交互环节，OIDC Provider 发现用户没有登录，要求用户先登录。node-oidc-provider demo 会放通任意用户名 + 密码，但是你在真正实施单点登录时，你必须使用你的用户目录即中央数据表中的用户数据来鉴权用户，相关的代码可能会涉及到数据库适配器，自定义用户查询逻辑，这些在 node-oidc-provider 包的相关配置中需要自行插入。 现在点击「登录」，转到确权页面，这个页面会显示你的应用需要获取那些用户权限，本例中请求用户授权获取他的基础资料。 点击「继续」，完成在 OP 的登录，之后 OP 会将浏览器重定向到预先设置的业务回调地址，所以我们又回到了 app1. html。 在 url query 中有一个 code 参数，这个参数就是临时授权码。code 最终对应一条用户信息，接下来看我们如何获取用户信息。 Web App 从 OIDC Provider 获取用户信息: 事实上，code 可以直接发送到后端，然后在后端使用 code 换取 access_token。这里我使用 postman 演示如何通过 code 换取 access_token。 你可以使用 curl 命令来发送 HTTP 请求： $ curl --location --request POST 'http://localhost:3000/token' \--header 'Content-Type: application/x-www-form-urlencoded' \--data-urlencode 'client_id=1' \--data-urlencode 'client_secret=1' \--data-urlencode 'redirect_uri=http://localhost:8080/app2. html' \--data-urlencode 'code=QL10pBYMjVSw5B3Ir3_KdmgVPCLFOMfQHOcclKd2tj1' \--data-urlencode 'grant_type=authorization_code' 获取到 access_token 之后，我们可以使用 access_token 访问 OP 上面的资源，主要用于获取用户信息，即你的应用从你的用户目录中读取一条用户信息。 你可以使用 curl 来发送 HTTP 请求： $ curl --location --request POST 'http://localhost:3000/me' \--header 'Content-Type: application/x-www-form-urlencoded' \--data-urlencode 'access_token=I6WB2g0Rq9G307pPVTDhN5vKuyC9eWjrGjxsO2j6jm-' 到此，App 1 的登录已经完成，接下来，让我们看进入 App 2 是怎样的情形。 登录第二个 Web App: 我们打开第二个应用，http://localhost:8080/app2. html 然后点击「登录」。 用户已经在 App 1 登录时与 OP 建立了会话，User ←→ OP 已经是登录状态，所以 OP 检查到之后，没有再让用户输入登录凭证，而是直接将用户重定向回业务地址，并返回了授权码 code。 同样，App 2 使用 code 换 access_token curl 命令代码： $ curl --location --request POST 'http://localhost:3000/token' \--header 'Content-Type: application/x-www-form-urlencoded' \--data-urlencode 'client_id=1' \--data-urlencode 'client_secret=1' \--data-urlencode 'redirect_uri=http://localhost:8080/app2. html' \--data-urlencode 'code=QL10pBYMjVSw5B3Ir3_KdmgVPCLFOMfQHOcclKd2tj1' \--data-urlencode 'grant_type=authorization_code' 再使用 access_token 换用户信息，可以看到，是同一个用户。 curl 命令代码： $ curl --location --request POST 'http://localhost:3000/me' \--header 'Content-Type: application/x-www-form-urlencoded' \--data-urlencode 'access_token=I6WB2g0Rq9G307pPVTDhN5vKuyC9eWjrGjxsO2j6jm-' 到此，我们实现了 App 1 与 App 2 之间的账号打通与单点登录。 登录态管理: 到目前为止，看起来还不错，我们已经实现了两个应用之间账号的统一，而且在 App 1 中登录时输入一次密码，在 App 2 中登录，无需再次让用户输入密码进行登录，可以直接返回授权码到业务地址然后完成后续的用户信息获取。 现在我们来考虑一下退出问题 只退出 App 1 而不退出 App 2: 这个问题实质上是登录态的管理问题。我们应该管理三个会话：User ←→ App 1、User ←→ App 2、User ←→ OP。 当 OP 给 App 1 返回 code 时，App 1 的后端在完成用户信息获取后，应该与浏览器建立会话，也就是说 App 1 与用户需要自己保持一套自己的登录状态，方式上可以通过 App 1 自签的 JWT Token 或 App 1 的 cookie-session。对于 App 2，也是同样的做法。 当用户在 App 1 退出时，App 1 只需清理掉自己的登录状态就完成了退出，而用户访问 App 2 时，仍然和 App 2 存在会话，因此用户在 App 2 是登录状态。 同时退出 App 1 和 App 2: 刚才说到单点登录，与之相对的就是单点登出，即用户只需退出一次，就能在所有的应用中退出，变成未登录状态。 最先想到的是这种方式，我们在 OIDC Provider 进行登出。 之后我们的状态是这样的： 好吧，其实没有任何效果，因为用户和 App 1 之间的会话依然保持，用户和 App 2 之间的会话同样依然保持，所以用户在 App 1 和 App 2 的状态仍然是登录态。 所以，有没有什么办法在用户从 OIDC Provider 登出之后，App 1 和 App 2 的会话也被切断呢？我们可以通过 OIDC Session Mangement 来解决这个问题。 简单来说，App 1 的前端需要轮询 OP，不断询问 OP：用户在你那还登录着吗？如果答案是否定的，App 1 主动将用户踢下线，并将会话释放掉，让用户重新登录，App 2 也是同样的操作。 当用户在 OP 登出后，App 1、App 2 轮询 OP 时会收到用户已经从 OP 登出的响应，接下来，应该释放掉自己的会话状态，并将用户踢出系统，重新登录。 刚刚我们提到 OIDC Session Management，这部分的核心就是两个 iframe，一个是我们自己应用中写的（以下叫做 RP iframe），用于不断发送 PostMessage 给 OP iframe，OP iframe 负责查询用户登录状态，并返回给 RP iframe。 让我们把这部分的代码加上： 首先打开 node-oidc-provider 的 sessionManangement 功能，编辑 . /support/configuration. js 文件，在 42 行附近，进行以下修改： . . . features: { sessionManagement: {  enabled: true,  keepHeaders: false, },},. . . 然后和 app1. html、app2. html 平级新建一个 rp. html 文件，并加入以下内容： &lt;script&gt; var stat = 'unchanged'; var url = new URL(window. parent. location); // 这里的 '1' 是我们的 client_id，之前在 node-oidc-provider 中填写的 var mes = '1' + ' ' + url. searchParams. get('session_state'); console. log('mes: ') console. log(mes) function check_session() {  var targetOrigin = 'http://localhost:3000';  var win = window. parent. document. getElementById('op'). contentWindow;  win. postMessage(mes, targetOrigin); } function setTimer() {  check_session();  timerID = setInterval('check_session()', 3 * 1000); } window. addEventListener('message', receiveMessage, false); setTimer() function receiveMessage(e) {  console. log(e. data);  var targetOrigin = 'http://localhost:3000';  if (e. origin !== targetOrigin) {   return;  }  stat = e. data;  if (stat == 'changed') {   console. log('should log out now!!');  } }&lt;/script&gt;在 app1. html 和 app2. html 中加入两个 iframe 标签： &lt;iframe src= rp. html  hidden&gt;&lt;/iframe&gt;&lt;iframe src= http://localhost:3000/session/check  id= op  hidden&gt;&lt;/iframe&gt;使用 Ctrl + C 关闭我们的 node-oidc-provider 和 http-server，然后再次启动。访问 app1. html，打开浏览器控制台，会得到以下信息，这意味着，用户当前处于未登录状态，应该进行 App 自身会话的销毁等操作 然后我们点击「登录」，在 OP 完成登录之后，回调到 app1. html，此时用户变成了登录状态，注意地址栏多了一个参数：session_state，这个参数就是我们上文用于在代码中向 OP iframe 轮询时需要携带的参数。 现在我们试一试单点登出，对于 node-oidc-provider 包提供的 OIDC Provider，只需要前端访问 localhost:3000/session/end 收到来自 OP 的登出成功信息 我们转到 app1. html 看一下，此时控制台输出，用户已经登出，现在要执行会话销毁等操作了。 不想维护 App 1 与用户的登录状态、App 2 与用户的登录状态: 如果不各自维护 App 1、App 2 与用户的登录状态，那么无法实现只退出 App 1 而不退出 App 2 这样的需求。所有的登录状态将会完全依赖用户与 OP 之间的登录状态，在效果上是：用户在 OP 一次登录，之后访问所有的应用，都不必再输入密码，实现单点登录；用户在 OP 登出，则在所有应用登出，实现单点登出。 使用 Authing 解决单点登录以上就是一个完整的单点登录系统的轮廓，我们需要维护一份全体用户目录，进行用户注册、登录；我们需要自己搭建一个 OIDC Provider，并申请一个 OIDC Client；我们需要使用 code 换 token，token 换用户信息；我们需要在自己的应用中不断轮询 OP 的登录状态。 读到这里，你可能会觉得实现一套完整的单点登录系统十分繁琐，不仅要对 OIDC 协议非常熟悉，还要自己架设 OIDC Provider，并且需要自行处理应用、用户、OP 之间登录状态。有没有开箱即用的登录服务呢？Authing 能够提供云上的 OP，云上的用户目录和直观的控制台，能够轻松管理所有用户、完成对 OP 的配置。  Authing 对开发者十分友好，提供丰富的 SDK，进行快速集成。 如果你不想关心登录的细节，将 Authing 集成到你的系统必定能够大幅提升开发效率，能够将更多的精力集中到核心业务上。 欢迎体验：https://authing. cn 实现单点登录：https://docs. authing. cn/authing/quickstart/implement-sso-with-authing "
    }, {
    "id": 17,
    "url": "/blog/Authing%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%99%BB%E5%BD%95%E6%96%B9%E5%BC%8F/",
    "title": "Authing 移动端登录方式, 10 行代码实现 App 扫码登录",
    "body": "2020/03/01 - Authing 新增四种移动端登录方式：移动应用微信登录、移动应用支付宝登录、App 拉起小程序登录、App 扫码登录。 Authing 新增了对四种移动端登录方式的支持，可以让开发者在 Web 端、移动端、小程序端同时接入 Authing:  移动应用微信登录 移动应用支付宝登录 App 拉起小程序登录 App 扫码登录  点击上图跳转到 GitHub Demo 页面。 其中，「App 拉起小程序登录」指的是在 App 中，借助微信开放能力，唤起微信小程序「小登录」，获取用户微信授权进行登录。此方法可以获取到用户手机号。 下面分别介绍一下如何快速接入这四种登录方式。 App 拉起小程序登录接入 App 拉起小程序登录，你需要做如下准备工作：  注册 Authing 开发者账号 申请微信移动应用 私有化部署用户，需要在 Authing 控制台填入你的小程序信息。  非私有化部署用户，需要将你的移动应用关联小登录。可在微信开放平台 “管理中心-移动应用-应用详情-关联小程序信息”，为通过审核的移动应用发起关联小程序操作。小登录的 AppID 为 wxa0435021fd7a3af2 .  在你做好这些准备工作之后，先使用微信 SDK 拉起小程序(具体的接入流程请见微信官方文档):  小程序 userName 为 gh_a781a791e29e path 为 /routers/explore path query 参数为：     userPoolId: 你的用户池 ID   getPhone: 是否需要获取用户手机号，1 表示需要，不填或者其他表示不需要   fromApp: 1，此参数必填。   useSelfWxapp: 此参数必填。私有化用户填 1，非私有化用户填 0.    下面是 Swift 代码示例： let userPoolId =  5e4cdd055df3df65dc58b97d let req = WXLaunchMiniProgramReq()req. userName =  gh_a781a791e29e req. path =  /routes/explore?userPoolId=\(userPoolId)&amp;getPhone=1&amp;fromApp=1&amp;useSelfWxapp=0 req. miniProgramType = WXMiniProgramType. releaseWXApi. send(req)用户同意授权之后，会携带 ticket 跳回你的 App，之后你可以使用此 ticket 换取用户信息： POST https://oauth. authing. cn/oauth/app2wxapp/auth/:userPoolId  Path 参数 userPoolId: 你的 Authing 用户池 ID。 Post Body 参数:     ticket: 得到的 ticket   secret: 用户池密钥。默认情况下，出于安全考虑，ticket 换取用户信息需要提供用户池密钥，这意味着不能直接在 App 内直接换取用户信息。开发者可以在用户池基础配置页面修改此选项：    下面是演示示例： 此方式可以获取用户手机号。你可以扫描下方的小程序二维码体验一下「小登录」：  如果你想私有化部署自己的小程序，可以联系我们。手机号：18616699123。 详细接入流程请见：接入APP 拉起小程序登录 App 扫码登录和其他三种登录方式不同，你不需要做任何准备工作。同时，我们提供 Web 端的 SDK，可以让你在 Web 端使用 10 行代码实现一个完整的扫码登录表单： const Authing = require('authing-js-sdk');// 初始化 Authing SDK for JavaScriptconst authing = new Authing({  userPoolId: 'YOUR_USERPOOL_ID',});// 调用 APP 扫码登录的方法，此方法将生成一个用于扫码登录的图片和相关提示信息authing. qrlogin. startScanning({ onSuccess(data) {  console. log(data);  const {ticket, userInfo} = data;  // 存储 token 到 localStorage 中  localStorage. setItem('token', userInfo. token); }}) That’s it! 就这么简单! 下面是 startScanning 支持的完整参数，你可以掌控扫码登录的所有流程，实现高度自定义： authing. qrlogin. startScanning({  mount: '', // 可选，二维码挂载点，如不写则默认漂浮在文档中间  interval: 1000, // 可选，轮询间隔时间，默认为 800 ms   onPollingStart: (intervalNum) =&gt; {},  onResult: (res) =&gt; {},  onScanned: (userInfo) =&gt; {},  onSuccess: (data) =&gt; {    const { ticket, userInfo } = data;  },  onCancel: () =&gt; {},  onExpired: () =&gt; {},  onError: (data) =&gt; {},  onQRCodeShow: (qrcode) =&gt; {},  onQRCodeLoad: (qrcode) =&gt; {},  onQRCodeLoadFaild: (error) =&gt; {},    tips: '使用 &lt;strong&gt; APP &lt;/strong&gt; 扫码登录',  scannedTips: '用户已扫码，等待确认',  canceledTips: '用户取消授权',  expiredTips: '二维码已过期',  successTips: '扫码成功',  retryTips: '重试',  failedTips: '网络出错，请重试'})      参数   可选/必选   说明         mount   可选   挂载点 Dom ID，如不写则默认漂浮在文档中间。       interval   可选   轮询时间间隔，单位为 ms，默认为 800 ms。       onPollingStart   可选   轮询开始时会被回调，只会回调一次。回调参数 intervalNum 为 setInterval 返回的数值，可使用 clearInterval 停止轮询。如：clearInterval(intervalNum)       onResult   可选   每次查询获取到数据都会回调       onScanned   可选   用户扫码时会被回调，只会回调一次。回调参数 userInfo 只包含了用户昵称和头像，开发者可以将其展示在扫码框中。       onSuccess   可选   用户同意授权之后将会被回调，只会回调一次，之后轮询结束。参数 data 是一个字典，包含两个字段：ticket 和 userInfo。出于安全性考虑，默认情况下，userInfo 只会包含昵称（nickname）和头像（photo）两个字段，开发者也可以在后台配置使其返回完整用户信息，详情见自定义配置。 ticket 可以用来换取完整的用户信息，相关接口见下文。       onCancel   可选   用户取消授权只会会被回调，只回调一次，之后轮询结束。       onExpired   可选   二维码失效时被回调，只回调一次，之后轮询结束。       onError   可选   每次查询失败时都会回调。回调参数 data 示例如 {“code”: 2241,”message”: “二维码不存在”,”data”: null}。完整错误代码请见完整错误代码页。       onQRCodeLoad   可选   二维码首次成功加载时回调。回调参数 qrcode 是一个字典，包含两个字段：qrcodeId、qrcodeUrl。       onQRCodeShow   可选   二维码首次出现在页面上时回调。回调参数 qrcode 同上。       onQRCodeLoadFaild   可选   二维码加载失败时会被回调。   在移动端，开发者可以调用 iOS/Android 相关接口解析二维码，二维码包含原始数据如下： {   scene :  APP_AUTH ,   qrcodeId :  5e05f0c57fde537d950f7da5 ,   userPoolId :  5e04ae0d5f3cee22fb37612b ,   createdAt :  2019-12-27T11:53:41. 260Z ,   expireAt :  2019-12-27T11:55:41. 260Z ,   userDefinedData : {  hello :  world  }} scene: 二维码场景值，APP_AUTH 表示 APP 扫码登录。 qrcodeId: 二维码 ID。 qrcodeId: 用户池 ID。 userDefinedData: 用户自定义数据。接着可以调用 Authing API，进行标记已扫码、同意授权、取消授权操作，如同意授权的 API 如下： POST https://oauth. authing. cn/oauth/scan-qrcode/confirm  请求头 Authorization: 已登录用户的 token Body 参数 qrcodeId: 二维码 ID。以下是一个对应的 Swift 代码示例： import Alamofirefunc confirmQRLogin(qrcodeId: String) {  let api =  https://oauth. authing. cn/oauth/scan-qrcode/confirm   let headers: HTTPHeaders = [     Authorization :  &lt;USER_TOKEN&gt; ,     Accept :  application/json   ]  struct Body: Encodable {    let qrcodeId: String  }  let body = Body(qrcodeId: qrcodeId)  AF. request(    api,    method: . post,    parameters: body,    headers: headers  ). responseString { response in        // 将 response. value 转化成字符串，示例如下：    // [ code : 200,  message :  二维码扫描确认成功 , data:    ]    let resp = convertToDictionary(text: response. value!)!    let code = resp[ code ] as! Int    if code != 200 {      debugPrint( 确认授权失败:  , resp)    }  }}详细接入方式请见：接入 App 扫码登录 微信登录与支付宝登录接入移动应用微信登录和支付宝登录，你需要做如下准备工作：  注册 Authing 开发者账号 申请微信、支付宝移动应用 在 Authing 控制台填入微信、支付宝移动应用信息 接入微信、支付宝移动端 SDK在你做好这些准备工作之后，先使用微信/支付宝 SDK 拉起微信/支付宝，用户同意授权之后，你会得到一个 code。此 code 可通过 Authing 的接口换取用户信息。 以微信登录 API 为例： GET https://oauth. authing. cn/oauth/wechatmobile/auth/:userPoolId?code=&lt;YOUR_CODE&gt;  path 参数 userPoolId: 你的用户池 ID。 query 参数 code: 拉起微信得到的 code。下面是 Swift 示例代码： import Alamofirelet url =  https://oauth. authing. cn/oauth/wechatmobile/auth/\(UserPoolId)?code=\(code!) AF. request(url). responseString { response in  debugPrint( Response: \(response. value) )}详细的接入流程请见：  接入移动应用微信登录 接入移动应用支付宝登录获取用户信息之后获取到用户信息之后，你可以得到登录凭证 token，你可以在后续的 API 请求中携带上此 token, 然后在后端接口中根据此 token 区分不同用户。 设置 Authorization 请求头为 “Bearer “ + token, 例如： Authorization:  Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9. eyJkYXRhIjp7InVuaW9uaWQiOiJvaVBiRHVHNFM3bXNyS0hQS0RjOE1FQ1NlOGpNIiwiaWQiOiI1ZGMxMGJjYjZmOTRjMTc4YzZmZmZmYjkiLCJjbGllbnRJZCI6IjVkYTdlZGFiNTAzOTZjMWFkOTYyMzc4YSJ9LCJpYXQiOjE1NzI5NTY0MjUsImV4cCI6MTU3NDI1MjQyNX0. OTgl72WZS8So3R5DbWCJ7I_Bd0LaZa4S0TAVMg9qaYQ  如果你使用的是 Swift 的 Alamofire, 可以这样写： let api =  YOUR_SERVICE_URL let headers: HTTPHeaders = [   Authorization :  &lt;USER_TOKEN&gt; ,   Accept :  application/json ]let body = Body(qrcodeId: qrcodeId)AF. request(  api,  method: . post,  headers: headers). responseString { response in print(response. value)}你可以在后端调用 Authing 的 API 验证通过 Authorization 判断该用户是否具备相关权限。 详情请见验证 token。 总结你可以在这个 GitHub 项目找到完整的示例代码：https://github. com/Authing/AuthingIOSDemo。 以下是 Authing 目前支持的社会化登录方式，国内主流的第三方身份提供商目前都已经支持了: 同时我们接下来会继续不断完善，让有身份认证的地方就有 Authing ! "
    }, {
    "id": 18,
    "url": "/blog/%E5%9B%BD%E4%BA%A7-Serverless-Identity-%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6%E5%B7%A5%E4%BD%9C%E5%9D%8A/",
    "title": "#ShapeIdentity 001 期：国产 Serverless Identity 开源组件工作坊",
    "body": "2020/02/27 - 我们发起 # Shape Identity 系列线上技术公开课，旨在倡议：在阻击物理世界「新冠」病毒的同时，不要忽视数字空间的安全。我们将定期邀请业界 Identity 专家一起探讨 Identity 技术的发展！主题涵盖：IDaaS/IAM、Serverless、ZeroTrust、Cloud Native 等开源技术。第一期本周六，2月29日，四年独一无二的日子，本次线上直播 Authing 联合腾讯云、Serverless Framework中文社区，与大家共同探讨：Serverless Framework 组件的开发及应用。 疫情肆虐，不仅对老百姓生命健康造成重大威胁，对各行各业的发展也造成重大影响。同时，开学、复工在即，疫情防控进入了关键阶段，「居家隔离、远程办公」是当下遏制疫情扩散的最佳防控措施。  1918年的西班牙流感席卷全球的模拟 2019 新型冠状病毒（2019-nCoV）使得中国一夜之间成了「全球最大的远程办公数字社会」，但是如此大规模的，敦刻尔克式的“数字化转型”，对「企业协同」、「企业 VPN 性能及安全性」、网络信息安全迎来重要考验， 也难免会出现大量次生安全问题，尤其在春节假期延长，大量企事业单位启动「远程办公」，原本在防火墙内，使用公司设备办公的员工，使用家用 PC 开始办公，并通过公共 WiFi 访问企业内部的数据和应用时，企业网络安全部门面临着空前的安全威胁，其中，「身份安全」是至关重要的一环。 于是，我们发起 # Shape Identity 系列线上技术公开课，旨在倡议：在阻击物理世界「新冠」病毒的同时，不要忽视数字空间的安全。我们将定期邀请业界 Identity 专家一起探讨 Identity 技术的发展！主题涵盖：IDaaS/IAM、Serverless、ZeroTrust、Cloud Native 等开源技术。 第 001 期，定在本周六，2月29日，四年独一无二的日子，也是 2020年的第60天。本次线上直播 Authing 联合腾讯云、Serverless Framework中文社区，与大家共同探讨：Serverless Framework 组件的开发及应用。本周六（2020-02-29 ）13:00——17:00，通过「腾讯会议」 300人在线分享及 Q&amp;A 视频互动、B站直播弹幕互动， 参与互动将送出「腾讯云」赞助纪念品。 近些年 Serverless 风起云涌，它正在深刻的改变未来软件开发的模式和流程，对于大多数应用而言，借助 Serverless 服务，开发者可以将绝大多数精力投入在业务逻辑的开发整合上，大大缩短开发周期，降低运维成本。Serverless Framework 当属时下最火热的开源框架。 主持人：晋剑 Authing 联合创始人兼COO 一、如何开发自己的第一个 Serverless Component？: 陈涛：Serverless Framework 社区专家参与 Serverless 社区及开源的相关研发工作。拥有丰富前端、JavaScript 技术经验，以及网站及小程序等项目开发经验，腾讯云 Serverless 系列课程特约讲师。内容简介：  Serverless Component 运行机制 Serverless Component 开发步骤（功能需求，组建配置） Serverless Component 组件开发（default 函数，remove 函数） Serverless Component 运行，调试与发布二、Authing 是如何开发 Serverless-OIDC 组件？: 高鹏洋：Authing 全栈工程师曾就职于中科红旗，负责容器云研发。曾参与中国移动 HA 系统研发，CNCF 贡献者，郑州 TFUG 组织者。热爱创造，喜欢探索未知，乐于与人交流，是一名 Acmer 。 内容简介：OIDC 是 OAuth 2. 0 的超集，同时是 Authing 推荐的身份认证最佳实践。在没有 Serverless 的情况下，开发者需要架设一个服务器用来在后端处理 OIDC code 换 Token 和 Token 换用户信息的流程，有了 Serverless 之后，开发者不需要编写任何路由就可以获取用户信息。本次主题将分享如何通过使用腾讯提供的 SCF 和 API 网关 Serverless Component 来快速创造一个 由多个原生 SCF 组成的 Serverless Component：https://github. com/Authing/serverless-oidc  三、基于Serverless Framework和OIDC 组件设计一个图床应用: 谢扬：Authing 创始人，SoLiD 中文社区（learnsolid. cn）发起人曾任职字节跳动 LarkCloud 云服务部门核心 Hacker，负责⽇活过亿 Serverless 平台产品设计和技术研发，该平台支撑来头条系全产品矩阵：今日头条、抖音、西瓜视频、飞书等。 ⻓期关注生产⼒科技，以提⾼社会生产⼒为个⼈使命。 内容简介：基于 Serverless Framework 和 Authing 完成一个可以共享和配置访问权限的图床管理应用。 四、线上自由 Q &amp; A 环节: 火速扫码报名: 火速扫码，回复 “ID”入群抢占「腾讯会议」 席位，仅300席提示：尽量提前下载安装「腾讯会议」客户端，群内获取会议链接 其他朋友们也可通过B站直播链接参与互动 Authing Live 直播间（https://live. bilibili. com/4850077 ） 相关阅读:  Authing 的故事：我为什么开发 Authing？ 如何在远程办公中保持高效的研发效率？ 一份普通人能理解的关于 Authing 的介绍 Authing 是什么以及为什么需要 Authing？ 为什么身份认证值得上云？ Authing @ 2019 总结 Authing 开发资源最全合集重磅：Authing 将于2020 Q1 开源，欢迎 Star 关注 "
    }, {
    "id": 19,
    "url": "/blog/Introduce-Authing-Pipeline/",
    "title": "Introduce Pipeline: Authing 的可扩展性达到了新高度",
    "body": "2020/02/20 - Authing Pipeline 是一组运行在云端的用户自定义 JavaScript 代码，属于 Authing 扩展能力的重要部分，可以让开发者无限制扩展、自定义 Authing 的能力。 演示: 开始具体介绍之前，我们先看一下 Pipeline 的使用效果。 使用 Pipeline 开启注册白名单: 此示例我们创建了一个 Pipeline 函数，此函数只允许邮箱后缀为 @authing. cn 的用户注册。 再由下图可得：邮箱 test@qq. com 注册失败，并且返回了 Access Denied! 提示，而 test@authing. cn 邮箱注册成功。 使用 Pipline 推送飞书群通知: 此示例创建了一个用户注册之后发送飞书群通知的 Pipeline 函数，飞书群 webhook 通过环境变量读取。  使用 Pipeline 自定义 Token: 使用 authing-js-sdk 验证效果，可以看到用户的 token 中有了对应的字段和值。 Pipeline 的运行架构图如下： 如上可知，Pipeline 作为一组函数，整个流程中的函数数据可以相互传递，实现工业流水线一样的效果。这种设计模式，可以使得开发者的自定义函数更加模块化，便于管理。 同时我们还提供了丰富的函数模版，帮助开发者快速上手开发。 Authing Pipeline 后端使用 Serverless 架构，所有的用户自定义代码均运行在云端，保证不同租户之间的隔离性，同时能弹性伸缩，既保证了安全性，又提升了运行效率。 应用场景: 借助 Authing Pipeline，开发者可以实现以下功能：‌  白名单机制：如注册邮箱域名白名单、注册 IP 白名单、手机号白名单等。 事件通知：如用户注册之后发送通知到钉钉、飞书或 Slack 中。 权限控制：如用户登录之后根据邮箱将其加入某用户组等。 扩展用户字段：如往修改默认头像、添加自定义 metadata、加入身份证号等。 自定义 token：如往 token 中加入自定义字段、删除自定义字段等。 … 还有更多，想象空间是无穷的。接下来，我们一起看看如何创建一个 Pipeline 函数。 创建第一个 Pipeline 函数: 创建 Pipeline 函数之前，你需要拥有一个 Authing 开发者账号，注册之后在控制台中依次点击 用户池 -&gt; 扩展能力 -&gt; 自定义 Pipeline 页面，你会看到如下提示： 点击右上角 “创建 Pipeline 函数“，选择一个函数模版用来开发： 在本示例中，我们选择访问控制模版中的「注册邮箱域名白名单」。  P. S. 示例中设置的域名白名单是 「example. com」，你也可以改成自己的。 点击左下角的“保存“按钮，我们会将此函数部署到云端，需要一定时间，请耐心等待。 回到 Pipeline 函数列表页面，可以看到我们刚刚添加的那个函数。 接下来我们验证一下此注册白名单是否有效： 这里我们使用 Authing 提供的表单进行登录，进入用户池 -&gt; 社会化登录 -&gt; OIDC 应用页面，你可以看到你的所有 OIDC 应用。 点击右边第一个按钮 「体验登录」，你会跳转到 Authing 的登录表单页面。 首先我们使用非 example. com 后缀的邮箱注册，看到返回了「Access Denied」 提示，这是我们默认指定的提示信息。 之后再使用后缀为 example. com 的邮箱注册，注册成功，如下所示： 由此可见，使用 Authing 的 Pipeline 可以帮助你不受限制的拓展 Authing 的能力。 开发和调试: 在 Pipeline 函数中，开发者可以获取到几乎所有有关此次认证的数据，包括用户资料、IP、地理位置、认证方式、用户池配置等。 为了方便 Pipeline 的开发和调试，Authing 精心准备了以下工具供开发者使用。 1. 函数模版: Authing Pipeline 提供了丰富的函数模版 供开发者选择以满足不同的场景，且列表还在不断增加中，同时也欢迎你为我们贡献模版。 2. 工具函数: 在 Pipeline 函数中，可以直接使用 Authing SDK ！这意味着你在 Pipeline 中具备了所有 Authing 已有能力！除了 authing-js-sdk，我们还内置了一些其他的 node modules 以及工具函数，方便开发者调用，点此了解更多。 3. 环境变量: 在 Pipeline 函数中，可以通过环境变量的方式保持链接、密钥等数据，避免硬编码，环境变量的增加方式如下所图所示： 在 Pipeline 函数中读取环境变量的方法为： const webhook = env. LARK_WEBHOOK这里的 env 是一个全局变量，LARK_WEBHOOK 是存储的一个环境变量值，点击了解更多关于环境变量的信息。 4. 调试代码: Authing Pipeline 支持在线调试，如下图所示： 此外，还支持查询 log 日志： 有关更多调试窗口的使用方法请见如何调试 Authing Pipeline 函数。 总结: Authing Pipeline 使 Authing 的扩展能力达到了新的高度，借助于此，开发者可以毫无限制的扩展 Authing 的能力，我们迫不及待的想知道你以什么样的方式拓展 Authing 的能力！ 参考资料:  创建你的第一个 Pipeline 函数 了解 Authing Pipeline 函数的完整 API 文档     user 对象完整 API   context 对象完整 API    了解如何在 Authing Pipeline 函数中使用环境变量？ 在 Authing Pipeline 函数中有哪些开箱即用的 Node Modules ? 了解如何使用 Authing 的在线调试器调试代码 ? 了解如何使用 Authing Node SDK 管理自定义 Pipeline 函数? 非 JS 开发者，如何使用 GraphQL API 管理自定义 Pipeline 函数?"
    }, {
    "id": 20,
    "url": "/blog/5-%E5%88%86%E9%92%9F%E7%90%86%E8%A7%A3%E4%BB%80%E4%B9%88%E6%98%AF-OIDC/",
    "title": "五分钟理解什么是 OIDC",
    "body": "2020/02/18 - OIDC 的全称是 OpenID Connect，是一套基于 OAuth 2. 0 的认证 + 授权协议，用于用户身份认证，将用户数据安全地暴露给第三方。 OIDC 与 OAuth 2. 0 有何不同？OAuth 2. 0 是用于授权的行业标准协议。 OAuth 2. 0 致力于简化客户端开发人员的工作，同时为 Web 应用程序，桌面应用程序，移动电话和物联网设备提供特定的授权流程。 以上是 OAuth 2. 0 的官方定义。我们举一个实际的例子，你在登录京东的时候，会发现在京东的登录框中有使用 QQ 登录、使用微信登录的按钮，这些地方就是 OAuth 2. 0 协议的用武之地。京东希望从 QQ 获取你的 QQ 用户数据，从而完成在京东的注册，这就需要数据的主人——你的授权。完成授权之后， QQ 会给京东一个 access_token，京东携带这个凭证，就能以你的名义，以及你授予此网站的权限（例如你授权京东能够访问你的个人信息而不是转账能力），访问你在 QQ 服务器上的数据，从而获取你的信息，在此过程中，你无须告诉京东你的 QQ 账号和密码，你输入账密信息的时候，是在腾讯的服务器完成的认证。 OIDC 与 OAuth 2. 0 相比，多了认证的能力。不但能够返回用户的 access_token，让第三方通过 access_token 调用用户授权过的接口（用户授权），还可以返回用户的 id_token，第三方可以将 id_token 用作用户身份标识（用户认证）。 回到刚才的例子，京东获取到 QQ 颁发的 access_token（是一个随机字符串）之后确实能够获取到你的信息，但是如果不借助其他手段，是不具备用户身份认证功能的。而在 OIDC 协议中，获取 access_token 的同时，会返回一个 JWT 格式的 id_token，可直接用作身份标识，供第三方确认用户身份。 JWT Token 是这个样子的： eyJ0eXAiOiJKV1QiLA0KICJhbGciOiJIUzI1NiJ9. eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFtcGxlLmNvbS9pc19yb290Ijp0cnVlfQ. dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk格式为“点分 base64 编码”，一共三段，第一部分叫作头部（JOSE Header），第二部分叫作荷载（Payload），第三部分叫作签名（Signature）。其中的签名根据头部、荷载和一个密钥计算得出，不可伪造。 base64 解码之后是这样子的： { typ : JWT ,  alg : HS256 }. { iss : joe ,  exp :1300819380,  http://example. com/is_root :true}. &lt;签名&gt;更多 JWT 知识请参考 JWT 规范。 总结成一句话：OAuth 2. 0 能做的 OIDC 都能做，OAuth 2. 0 不具备的认证能力，OIDC 也具备。 OIDC 协议的应用场景所有使用 OAuth 2. 0 的场景都可以升级为 OIDC 协议，OIDC 协议是 OAuth 2. 0 的超集。以下是一些 OIDC 协议的应用场景：  社会化登录场景，网站登录框上常见许多按钮「使用 XXX 登录」。 物联网设备的身份认证和授权。 企业内多个应用统一身份，单点登录。 开放平台对外暴露应用数据，做用户认证与授权。 Serverless 中的身份层。OIDC 协议是 OAuth 2. 0 协议的下一代，是身份认证协议升级的不二之选。OIDC 协议中的四个主体在介绍 OIDC 授权模式之前，先要明确四个主体：第三方应用、资源服务器、资源所有者、认证授权服务器。我们继续沿用前文京东与 QQ 登录的例子。  P. S. QQ 使用的是变种 OAuth 2. 0 协议，并不完全符合 OIDC 规范，在此假设 QQ 使用 OIDC 协议进行对外数据授权。 第三方应用: 京东的角色是第三方应用。 资源服务器: QQ 的个人信息存放于资源服务器。 资源所有者: 用户是 QQ 账号的所有者。 认证授权服务器: QQ 的授权服务器负责用户的身份认证和授权，管理第三方应用、受保护资源、资源所有者之间的关系。 OIDC 的三种授权模式Authorization Code Flow应用最为广泛的是授权码模式，此模式的交互过程如下图：  第三方应用访问认证服务器的授权链接。（用户在京东网站登录框点击使用 QQ 登录） 用户与认证服务器完成身份认证。（浏览器跳转到 QQ 授权页面，用户输入 QQ 号和密码） 认证服务器向第三方应用返回授权码 code。（QQ 服务器将用户的浏览器重定向，将授权码发送到京东服务器） 第三方应用携带授权码访问认证服务器的 token 接口。（京东服务器携带授权码与 QQ 服务器交互） 认证服务器返回 access_token 和 id_token 给第三方应用。（QQ 服务器返回 access_token 和 id_token 给京东服务器）此后，第三方应用可以利用 access_token 到资源服务器获取用户的信息，完成在第三方应用的注册和登录业务，并可以将 id_token 作为用户的身份凭证，存放在前端。第三方应用的前端需要访问受保护的资源（例如用户账单信息、购物车）时需要携带 id_token，后端验证 id_token 合法性，核实用户身份之后，返回相关资源数据。 OIDC 认证时相关 Token 解释: OIDC 认证时会签发两种 Token，一类叫 id_token，还有一类叫 access_token。 id_token 是用户身份的凭证，只起到判定用户身份的作用。 id_token 示例： eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9. eyJzdWIiOiI1ZTQ5NjBkZmJkOTE1OGZiODQ0OTAzYTkiLCJiaXJ0aGRhdGUiOiIiLCJmYW1pbHlfbmFtZSI6IiIsImdlbmRlciI6IiIsImdpdmVuX25hbWUiOiIiLCJsb2NhbGUiOiIiLCJtaWRkbGVfbmFtZSI6IiIsIm5hbWUiOiIiLCJuaWNrbmFtZSI6IiIsInBpY3R1cmUiOiJodHRwczovL3VzZXJjb250ZW50cy5hdXRoaW5nLmNuL2F1dGhpbmctYXZhdGFyLnBuZyIsInByZWZlcnJlZF91c2VybmFtZSI6IiIsInByb2ZpbGUiOiIiLCJ1cGRhdGVkX2F0IjoiIiwid2Vic2l0ZSI6IiIsInpvbmVpbmZvIjoiIiwiY29tcGFueSI6IiIsImJyb3dzZXIiOiJNb3ppbGxhLzUuMCAoTWFjaW50b3NoOyBJbnRlbCBNYWMgT1MgWCAxMF8xNF82KSBBcHBsZVdlYktpdC81MzcuMzYgKEtIVE1MLCBsaWtlIEdlY2tvKSBDaHJvbWUvODAuMC4zOTg3Ljg3IFNhZmFyaS81MzcuMzYiLCJkZXZpY2UiOiIiLCJsb2dpbnNfY291bnQiOjEsInJlZ2lzdGVyX21ldGhvZCI6ImRlZmF1bHQ6dXNlcm5hbWUtcGFzc3dvcmQiLCJibG9ja2VkIjpmYWxzZSwibGFzdF9pcCI6IjEyMS4yMS41Ni4xNzEiLCJyZWdpc3Rlcl9pbl91c2VycG9vbCI6IjVjOTU5MDU1NzhmY2U1MDAwMTY2Zjg1MyIsImxhc3RfbG9naW4iOiIyMDIwLTAyLTE2VDE1OjMzOjUyLjQ0NFoiLCJzaWduZWRfdXAiOiIyMDIwLTAyLTE2VDE1OjMzOjUxLjY2NVoiLCJlbWFpbCI6InRlc3QxQDEyMy5jb20iLCJlbWFpbF92ZXJpZmllZCI6ZmFsc2UsInBob25lX251bWJlciI6IiIsInBob25lX251bWJlcl92ZXJpZmllZCI6ZmFsc2UsImF0X2hhc2giOiJWYW9sSnVqWXltQjUxNlNGOGNaQkpBIiwic2lkIjoiZGYzMGFlNDgtOTkzMS00YjZlLWI0YzgtMWI5NjRkOGZjOWIyIiwiYXVkIjoiNWQwMWUzODk5ODVmODFjNmMxZGQzMWRlIiwiZXhwIjoxNTgxODcwOTc4LCJpYXQiOjE1ODE4NjczODEsImlzcyI6Imh0dHBzOi8vb2F1dGguYXV0aGluZy5jbi9vYXV0aC9vaWRjIn0. pH-bWm-Im0wnOcUEA-OG_iKwy9DTZlAXuik50HPsfGY解码后： {  alg :  HS256 ,  typ :  JWT }. {  sub :  5e3a3b2315a0b8398cdaaa08 ,  birthdate :   ,  family_name :   ,  gender :   ,  given_name :   ,  locale :   ,  middle_name :   ,  name :   ,  nickname :   ,  picture :  https://usercontents. authing. cn/authing-avatar. png ,  preferred_username :   ,  profile :   ,  updated_at :   ,  website :   ,  zoneinfo :   ,  company :   ,  browser :   ,  device :   ,  logins_count : 8,  register_method :  default:username-password ,  blocked : false,  last_ip :  127. 0. 0. 1 ,  register_in_userpool :  5e3a3b2315a0b8398cdaaa04 ,  last_login :  2020-02-16T09:04:09. 764Z ,  signed_up :  2020-02-05T03:48:51. 447Z ,  email :  test@test. com ,  email_verified : false,  phone_number :   ,  at_hash :  6k-IWJwh-Dd3_hLOay0s7A ,  sid :  d50a8c9d-23db-4156-80ea-1c82d199d0e9 ,  aud :  5e3a3b2315a0b8398cdaaa0e ,  exp : 1581948533,  iat : 1581944933,  iss :  https://core. littleimp. cn/oauth/oidc }. 签名access_token 是用户授权给第三方应用的一个令牌，第三方应用可以使用这个令牌访问用户在资源服务器上受保护的资源，一般不用于用户凭证和身份标识。 access_token 示例： eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9. eyJqdGkiOiJXaXdndEdHYzVMeGtZRUFRY012RFkiLCJzdWIiOiI1ZTNhM2IyMzE1YTBiODM5OGNkYWFhMDgiLCJpc3MiOiJodHRwczovL2NvcmUubGl0dGxlaW1wLmNuL29hdXRoL29pZGMiLCJpYXQiOjE1ODE5NDQ5MzMsImV4cCI6MTU4MTk0ODUzMywic2NvcGUiOiJvcGVuaWQgcHJvZmlsZSBlbWFpbCBwaG9uZSIsImF1ZCI6IjVlM2EzYjIzMTVhMGI4Mzk4Y2RhYWEwZSJ9. MnAAGj6HlYvN3FOAo6PA2cxNxZDZbL3yhxTM3uxnt0M解码后： {  alg :  HS256 ,  typ :  JWT }. {  jti :  WiwgtGGc5LxkYEAQcMvDY ,  sub :  5e3a3b2315a0b8398cdaaa08 ,  iss :  https://core. littleimp. cn/oauth/oidc ,  iat : 1581944933,  exp : 1581948533,  scope :  openid profile email phone ,  aud :  5e3a3b2315a0b8398cdaaa0e }. 签名Implicit Flow在隐式模式中，认证服务器的授权接口不会返回授权码 code，而是在与用户完成认证后返回 id_token 和 access_token，交互模式如下图所示：  第三方应用访问认证服务器的授权链接。（用户在京东网站登录框点击使用 QQ 登录） 用户与认证服务器完成身份认证。（浏览器跳转到 QQ 授权页面，用户输入 QQ 号和密码） 认证服务器向第三方应用返回 id_token 和 access_token。（QQ 服务器将用户的浏览器重定向，将 id_token access_token 发送到京东前端页面）隐式模式比授权码模式简单，经常用于将 id_token、access_token 直接返回到前端，方便前端直接存储 id_token 用于证明用户身份。也需要前端自行将 access_token 发回后端，后端用于获取用户的详细信息，这增加了暴露 access_token 的风险。隐式模式不支持返回 refresh_token，即不能从后端刷新 access_token，登录一旦过期需要用户重新登录。 Hybrid Flow混合模式是以上两种模式的组合，特点是能够在授权接口一次性获取到 code、id_token、access_token，一般 code 会与 id_token、access_token 混合出现，混合模式的交互如下图所示：  第三方应用访问认证服务器的授权链接。（用户在京东网站登录框点击使用 QQ 登录） 用户与认证服务器完成身份认证。（浏览器跳转到 QQ 授权页面，用户输入 QQ 号和密码） 认证服务器向第三方应用返回 code、id_token 和 access_token。（QQ 服务器将用户的浏览器重定向，将 id_token access_token 发送到京东前端页面） 第三方应用携带授权码访问认证服务器的 token 接口。（京东服务器携带授权码与 QQ 服务器交互） 认证服务器返回 access_token 和 id_token 给第三方应用。（QQ 服务器返回 access_token 和 id_token 给京东服务器）混合模式可以灵活满足 code、id_token、access_token 的各种处理方式，可以在享有隐式模式便利的同时，利用 code 获取 refresh_token，从而可以在后端刷新用户 access_token，不必重复让用户登录。 总结OIDC 协议是 OAuth 2. 0 协议的超集，是可以替代 OAuth 2. 0 的下一代身份认证协议，能够解决认证 + 授权两个问题。OIDC 的授权流程与 OAuth 2. 0 完全一致，能够保持向下兼容。 授权服务器的意义在于管理第三方应用、受保护资源、资源所有者之间的关系，让互相不信任的应用之间安全地暴露数据——应用之间约定好某种规范，按照这种规范，就能在用户授权的前提下，安全地将数据暴露给第三方，而第三方也无需获知用户的账密信息。 id_token 是用户的身份凭证，access_token 是用户的授权凭证。 OIDC 有三种授权模式，分别是授权码模式、隐式模式、混合模式。授权码模式中只能获取到 code；隐式模式中只能获取到 access_token id_token；混合模式中都能够获取到。 "
    }, {
    "id": 21,
    "url": "/blog/GeekTalk036%E5%AE%9E%E5%BD%95-Serverless-%E7%9A%84%E5%89%8D%E6%99%AF%E5%92%8C%E6%9C%BA%E4%BC%9A/",
    "title": "Geek Talk 036 实录：Serverless 的前景和机会",
    "body": "2020/02/17 - Serverless 正在改变未来软件开发的模式和流程，对于大多数应用而言，借助 Serverless 服务，开发者可以将绝大多数精力投入在业务逻辑的开发整合上，大大缩短开发周期，降低运维成本。本次主题将与大家探讨 Serverless 生态中缺少的工具以及潜在的创业机会。 大家好，我谢扬。很高兴能够有这个机会更加交流关于 Serverless 的技术，我们目前创业做的事情跟 Serverless 也是非常强相关的，目前聚焦研发一款 IDaaS 身份即服务产品 Authing。我之前在字节跳动负责一款日活过亿的 Serverless 产品 LarkCloud。我个人对 Serverless 保持着长期的关注，对 Serverless 行业的发展也有很多想法，今天也跟大家分享一下。 我们今晚的议题主要分为四个主题，第一个是 Serverless 架构的介绍，第二个是Serverless的一些使用场景，第三个是Serverless 的使用报告，这个报告是来自于：O’Reilly Serverless survey 2019 的调研，第四是跟大家展望一下未来的 Serverless 工具链是什么样子，然后它的前景和机会是什么。 1. Serverless 架构介绍: 1）云计算的发展: 首先开始我们的第一个议题：Serverless 架构，在看这个架构之前，我们先来回顾一下云计算的发展。 图中蓝色这部分是由用户来进行管理的这一部分，黄色这一部分是由云服务商来进行管理的。从早期的 On-Premises 到 FaaS ，这是云计算的发展历程。 On-Premises 的时候，机房所有的硬件、操作系统、容器、运行时环境、应用、函数等都需要自己管理；发展到 IaaS 之后，那么开发商他们不需要维护自己的硬件了，但是还是需要维护很多东西。 后来 CaaS 服务出现，容器即服务，我们自己不需要再维护操作系统层面的东西，只需要维护容器，K8s 这么短时间火起来，这也是一个很重要的原因。 那么再往下就是像阿里云、AWS 这种云计算 PaaS 平台出来，做了很多周边的一些工具，比如说各种各样的监控、报警，还有整个的服务器管理的控制台，然后有了这种服务之后，让客户连这些服务也不用自己来管理了，只需要管理自己的应用就好了，这就是 PaaS 服务。 那么再到现在，出现 FaaS 的产品形态，最右边的 FaaS 是蓝色的，下层所有模块都是黄色的，由云服务商提供，中间还有一个灰色模块 Application ，需要云服务商和用户一起进行管理。 那么这是 FaaS 的一个演进历史，总的来说 FaaS、PaaS、CaaS 等服务发展出来的缘由：就是让更多的客户能够专心自己的业务，而不需要去维护底层这么多跟业务无关的基础设施。 2）Serverless 架构: 接下来看一下 Serverless 架构，这里我们以 AWS 的一些服务为例，最左边的一个User Agent（用户），从浏览器去访问一个系统，首先会经过一个API Gateway，API Gateway会出发一个函数 Cloud Function，在AWS中叫 Lambda，然后 Lambda 会去执行一些获取资源、业务操作，这些资源都是受限的，它可能是亚马逊的 DynamoDB、也可能是 AWS S3 存储、也可能是亚马逊的 EC2，也可能是你自己的一个社交数据以及通讯录好友等。 这些资源默认是受限的，受限的时候就需要去访问一个无服务器的身份认证系统，即图中的 Authing ，用户通过 Authing 进行登录，认证完成之后会获取一个 Token，然后用户带 Token 去请求资源，这个时候这个后端必须验证 Token 是合法的，才能够获取用户有权限访问的资源。这是 Serverless 整体的访问的一个流程。 现在很多人把 Serverless 分为两块，一块叫做 FaaS（函数即服务）Functions as a Service的缩写，只需要执行一个函数，上传一个函数，然后这些函数来执行一些操作，比如说读取你的通讯、你的地址，或读取其他的业务信息。 另外一块叫做 BaaS（后端即服务），全称是 Backend as a Service，就是把整个 BaaS 代码上传到服务器，然后它会自动给你做一些弹性伸缩。 其实函数的粒度更细一些，然后我们今天主要探讨的还是FaaS，BaaS 现在发展的不是特别好，我个人也不是很看好 BaaS 这块的市场。 3）FaaS 函数的生命周期: 接下来我们了解一下 FaaS 的生命周期，FaaS 的全称是 Functions as a Service，开发者只需要开发一个函数，然后这个函数会根据函数的访问量来自动的做一些收缩。FaaS 有触发器，就是从哪一方进行调用，比如：你在浏览器上请求一个 FaaS ，那么就是收到一个 HTTP 请求。 又如说某个图片被上传到了腾讯云的 OSS 里面（OSS 是腾讯的存储服务），那么上传成功之后有一个回调消息，这个消息会去触发 FaaS 函数，这个就叫做 Webhook。还有一类物联网场景，比如温度采集器，测量到温度之后，会有一种 Pub/Sub 这种消息模型，这种消息模型是异步的，也是会执行这样一个 FaaS 触发器。 那么一旦是触发了 FaaS 的执行，就会启动一个VM （虚拟机），那么这个 VM （虚拟机）目前主要分为两类：一类是直接 Fork 进程，然后在进程里执行这段代码，另一类就是去启动一个容器，然后在容器里面执行。在 Process 进程里执行代码的方式是不太安全的，所以现在很多人都转向了容器。当然容器的问题在于冷启动时间会非常长，也就是说假如这个函数本身执行时间只有 200 毫秒，如果加上容器的启动时间可能也是 200 毫秒，总共的时间可能变成了 400 毫秒，那么就会造成一些网络延迟，最后对用户体验产生影响。 启动了这样一个 VM 之后，就会去运行这个函数，运行结束之后就会把这个实例给销毁掉，同时云服务商会根据你的运行时间来计算、所耗费的资源如：CPU、内存、包括带宽等等，然后计算这次运行花多少钱，来进行一次扣费。 这就是 FaaS 函数的生命周期，接下来给大家剖析一下：为什么我们要用 FaaS ？ 4）IaaS 模型: 首先，我们先来看 IaaS 模型。分别从四个视角来看一下 IaaS 的整体架构： 第一是从 Service Models 视角，即服务模式，分为 IaaS、PaaS、SaaS。 第二是从 Cloud Stack 视角，阐释来云计算是由最底层基础设施层、应用程序栈、应用程序、用户层 来构成。 第三是从 Stack Components 视角，来看一下详细的构成组件：  基础设施层：就是各种各样的硬件资源，如CPU、网络、带宽、硬盘等等，由基础设施厂商来提供服务，并保障最基础的系统安全。 Application Stack：就是需要构建应用所需要的基础软件技术栈，包括了操作系统、编程语言、应用服务器、中间件、数据库（关系数据库、图数据库、亦或是非关系数据库等）、还有报警监控服务、DevOps、CI/CD、API Gateway 等。 Application 层：开发者去建立自己的业务模型、业务应用的时候所需要的开发组件，「认证、授权」是其中最基础的组件，然后是 UI（即用户界面）、一些事务，比如你的支付、或直播的事务等。另外是一些报告，涉及与业务相关的用户的增长数据的报告、管理业务的使用情况，Key Metrics 是什么样子；另外还需要一个后台对所有资源进行管理。 用户层：包含用户登录、注册、管理等。第四是从不同服务模式下计算服务供应商和客户之间的责任边界。  IaaS 模式下：IDC 供应商的责任是搭建最基础的硬件基础设施、并对保障整个系统的安全。而客户需要从 OS 底层来搭建整个计算、应用环境、以及业务的开发。 PaaS 模式下：类似 AWS、阿里云等云服务提供商承担了基础设施的建设、以及核心基础软件环境的搭建。如操作系统、数据库、中间件、监控服务，把这些服务抽象成了一层云，然后提供给企业进行使用。客户只需要专注在应用环境搭建、及业务层面的开发。 SaaS 模式下：云服务厂商更进一步的把「应用环境」也服务化，客户仅需考虑业务层面的事情。比如应用层比较重要的两个模块：认证和授权模块也被SaaS 服务化；甚至 User 层的用户注册、登录、管理功能也被 SaaS 化，在美国的已经有 Auth0、Okta 等厂商提供这方面的服务，在中国我们 Authing 也在做类似的事情：IDaaS 身份即服务。有了 IDaaS 客户可以更直接开发业务，不需要操心：注册、登录、用户管理、认证、授权等功能。回头来看在 IaaS 时代客户需要做很多事情，基建和研发成本极高，进入市场的时间成本很大。但是经过一系列「服务化」进程后，客户愈加仅需关注自己的业务代码，快速实现、快速进入市场进行验证及销售，这也是从2019年开始，Low code/No code 的创业项目备受资本热捧。 5）CaaS 容器模型: 随着技术迭代，进入到了容器模型的时代，企业的运维需要管理更多的产品矩阵及服务的稳定。首先是各种各样的服务发现、Container Runtime、包括整个容器集群的管理，还有一些安全性问题、性能问题，基于角色的访问控制（RBAC）、 LDAP/AD 的管理、以及 SSO 的实现等。 对于开发者、运维需要学习很多 SSO 的知识，以及其他跟业务无关的很多东西，这加重了他们管理的负担。CaaS 容器模型让我们整个服务的可伸缩性大大提高了，但是也大大加重了运维人员的负担。 6）Serverless 模型: 行业逐步发展到了今天的 Serverless 模型，在之前模型下客户需要操心很多的组件。但是，进入Serverless 模型后，客户仅需要关心是「业务代码」，设计好自己的业务模型，把代码部署到云服务中，就可以完成所有的复杂的一系列的部署、运维、监控等操作。 1）FaaS 优势: Serverless 带来的好处，首先是：零运维，也叫做零管理。除了零运维和零管理之外，还有其他很多优势，比如说按运行时间付费，你运行多长时间，就付多少钱；没有运行资源损耗的时候，不需要付任何钱。举个例子，可以看右边这张图，蓝色的线代表是每秒处理多少请求；红色的线是处理这些请求需要的服务器数量。可以看到蓝色的线有两个峰值，这代表需要 200 台服务器，在传统的架构下就需要准备 200 台服务器。 那么有了 FaaS 之后，就不需要买那么多服务器，只需要是把这个业务逻辑写好，然后它会自动为你进行伸缩。伸缩的策略也非常多，比如用机器学习来进行预测，或者说可以用一些即时计算进行预测等等。运维人员只需要去考虑管理更少的服务器，开发人员只需要去关心业务代码，就可以让企业更快进入市场，并且能够造一个原生的微服务，显著降低企业的管理和维护负担。 2）FaaS 劣势: 除了优势之外，FaaS 还有很多劣势，没有一个通用的标准。比如 AWS、Google，还有国内腾讯、阿里云、华为、京东云都有 FaaS 服务，但他们没有一个通用的标准；这也造成了：客户被供应商锁定的问题，无法便捷迁移。比如说我现在用 AWS，每天请求可能上亿，想要迁移到阿里云和腾讯云就非常的麻烦。第 2 点是 FaaS 是一个黑盒子环境，开发者需要去非常了解这个东西的底层是怎么回事，他才能敢去使用，否则他无法去预估一些潜在的风险。第 4 是冷启动的问题，也不算什么太大的问题，云厂商已经解决了这类问题，有很多处理方式。 第 5 个问题是最要命的一个问题，目前的 FaaS 是没有经过一个非常复杂应用案例的验证。假如说我想用 Serverless 开发一个淘宝、QQ、微信或者一个直播软件，目前是没有这种案例的。一方面主要是因为生态的缺乏，另外一方面的话也是因为开发人员的思维认知没有提升，这绝对不是一个技术的问题，技术已经非常成熟。 3）FaaS 厂商: 下图是全球范围内在做 FaaS 的厂商，第一个 OpenWhisk 是 IBM 的开源的 FaaS 框架。另外一个是大家都知道的 AWS 的 Lambda，亚马逊的云服务算是业界的一个标准，还有 Google、微软都有类似的服务。国内主要是阿里云、腾讯云、华为云，除了这三家之外，其实京东、滴滴其他的云都有。另外一家就是字节跳动，他们叫做轻服务，这也是我当时在字节跳动开发的一款服务。 此外，还有一股不可忽视的力量，就是美国的 Auth0，是一款 IDaaS - 身份认证即服务，把身份认证上云，他们拥有一个 Webtasks 产品，可以让用户、开发者通过他们的服务快速完成身份认证功能，更多的精力聚焦到具体的业务方面。另外一个就是我们在做的 Authing ，未来的话也会有一个 FnSuite 这样一款函数产品，会和我们的业务有一个非常好的打通。 2. Serverless 使用场景: 1）无服务器的应用后端场景: 接下来介绍一下 Serverless 的使用场景。 首先第一类就是这种无服务器的应用后端，比如说我写了一段代码，然后我把它 push 到 Github 上去，这个时候 Github 的 webhook，我需要让它通知到我的 Slack 或者我的飞书。 假如没有 Serverless 的情况下，需要自己写一个代码后端框架，然后自己拼接一下，写个路由，写完路由之后，还需要再把它部署到服务器上去，然后再部署运维。 那么有了 FaaS 之后，只需要写个函数，把它传到阿里云或者腾讯云上，云服务商返回一个 API 链接，开发者把链接填到 Github 上去，就完成了整个操作流程，非常简单。 还有一种是新闻消息推送应用，一个新的用户，它注册了一个应用，然后在我们这个消息里面就推送给他一些新闻。 再比如物联网的应用的后端，比如说一个温度的信息推送系统，经过 Pub/Sub 之后来去调用一个函数，然后我们的函数来执行一些具体业务操作，比如推送到我们后台里面进行监测和管理，以及一些报警等。 这就是 Serverless 的第一类无服务器应用后端场景，如 QQ、微博、微信 IM 以及简单的消息推送场景，都可以使用Serverless。 2）人工智能应用场景: 第二类场景：人工智能应用。这张图来自 Google，大家可以从左往右看，比如通过 Slack、 Messenger、或 Google Home 和机器人对话，会发送一个 Http 请求，这个请求会在云端执行函数，然后这个函数会请求谷歌的 Dialogflow 是谷歌的一项对话管理服务。 Dialogflow 把多轮的对话管理起来，后面的其他服务：ML、Vision API 等都是由云服务商提供的能力，该厂商的 Cloud Functions （云函数）就可以直接调用这些能力，这对云服务厂商来说是非常大的一个优势。所以说 Serverless 只能由这些 BigTech 来研发，一些小公司或者创业公司想做Serverless 基础设施基本上是不太可能的，因为，Serverless 最核心竞争优势不仅仅前面的函数，更重要的是服务商本身所提供其他的能力可以供函数调用。 3）实时数据处理场景: 第三类场景：实时数据处理，最典型的就是物联网应用，数据量非常大，用 Serverless 也是非常匹配。假如需要 1万 QPS ，函数可以立马生成支持 1万 QPS 的集群，如果你自己搭一个 EC 2 服务器或者是其他应用的话，还需要自己去管理集群，成本会变得很大。 4）AaaS 认证即服务场景: 那么还有一类最不容忽视的一个场景是：AaaS （Authentication as a Service：认证即服务），把用户注册、登录、用户管理、认证及授权等模块 SaaS 服务化。 为什么需要 AaaS 这类服务呢？主要有三点原因： 第一点：身份管理，是云计算里面除了计算资源、存储资源和网络资源之外，最标准化的一个产品。为什么说最标准化？前面 IaaS 图中可以看到：Stack Components 包含了注册、登录、注册、用户管理以及认证和授权模块，基本上所有的应用：不管 是to B、to C、to G、to Developer 基本上都是需要的且流程非常标准；甚至在基础设施层面的服务，也都需要标准化的认证服务，比如：K8S 容器编排场景中，也都有认证/授权这种需求，另外在多云管理、DevOps 不同工具流身份的管理等。 在没有 AaaS 云服务之前，大家都需要自己造的轮子，那么 AaaS 云服务的出现就让这种重复造轮子的事情不在发生，节省巨大的社会生产力，并且让身份管理变得非常简单安全。这个也是很多的厂商都看到的这样一个机会。 第二点：身份管理问题在数十年间，从未得到一个很好的解决，用户以自己隐私代价来为企业「身份管理不善」买单。比如很多站点的用户数据泄露事故，这些用户泄露事故不仅给企业的名声造成很大的影响，而且，严重损害了用户的隐私。近期了解到的一家公司每年花几百万来购买身份管理服务。AaaS云服务产品的出现，将大大降低客户的投入成本及安全成本。 第三点：合规成本逐年上升：随着 GDPR、CCPA 、包括加拿大的 Castle 等，这些法律出台之后，政府对于企业在身份管理方面提出了更高的要求。假如企业要去满足这些要求，会花费巨大的成本，而使用AaaS 云服务，就可以保证企业可以非常高效、简单、安全的拥有一个合规身份管理产品。 3. Serverless 使用报告: 接下来看一个 Serverless 使用报告，一起来了解产业现状，数据来源于O’Reilly serverless survey 2019。 首先是 40% 的企业已经采用了 Serverless，这个占比还是比较大的，60% 没有采用，市场空间还是有很大的提升空间。 30% 的 Serverless 用户是一线工程师，然后是架构师、技术 leader 占 25%左右；还有技术类的也不少，另外一个出乎我意料的是：VP、总监、经理级别的用户也近20%； 另外报告显示，采纳 Serverless 技术的行业也非常广泛，采用最多的是软件行业，第二大是金融及银行业，第三大行业是咨询行业。所以如果要在 Serverless 领域创业的话，可能最好的客户是金融业，要么做外包，要么服务金融业。 60% 的中大型规模企业采纳 Serverless：这个数字也是比较出乎意料，我们潜意识觉得采用 Serverless 新技术的可能都是小企业，但是从图中可以看到，其中一万人以上规模的公司，占到了 20%。 50%的 Serverless 用户，以经常使用 Serverless 超过一年时间，采用 Serverless 技术超过三年时间的企业也超过了10% 然后 66% 的用户表示，采用 Serverless 技术后效果显著。 这是为什么要使用 Serverless 的一些调查。我们看前三个最主要的几个理由，分别是减少运营成本、可以按序的自动的伸缩。第3个是不需要再关心服务器的维护问题，和第一点差不多，降低成本。 为什么不用 Serverless 的原因调查显示： 企业在采纳 Serverless 技术之后面临最大的挑战是：对于当下员工的教育成本很高，去教育员工还是比较难的，所以如果说要在 Serverless 领域创业的话，能做一家Serverless 领域的咨询公司也不错，与教育机构合作培训人才。 第二大挑战是因为 Serverless 领域缺乏标准，很容易被供应商锁定，不容易迁移到其他供应商，这个可能需要加快推动 Serverless 行业的标准化进程，防止被供应商锁定，现在 CNCF 基金会也在推动着这个事情。第三大挑战是集成测试、调试非常困难，这也反映了 Serverless 生态供应链的不健全问题，同样，也存在创业机会。 不采用 Serverless 最大的原因是：考虑到安全问题。如果要创业的话，那么去解决 Serverless 的安全性问题也是一个很大的机会。第二大原因是：因为对于 Serverless 的未知而产生的畏难情绪，不知道使用了 Serverless 会发生什么的问题。第 3 个原因是：底层云服务商正在迁移中，来不及采用 Serverless。 什么角色在管理公司内部 Serverless 的基础设施？首先是负责DevOps 的运营人员，第二是：软件工程师、第三是技术架构师。这个是一个全球调查，我认为和中国的实际情况可能不太吻合，中国可能要反过来，第一可能是架构师来决定。 第二是具有话语权的软件工程师来决定是否采纳。 最后一个调查显示：50%+ 的企业愿意在未来三年尝试 Serverless，所以说 Serverless 在未来还会有一个非常大的增长。 4. Serverless 工具链、前景和机会: 最后的话我们来聊一下，Serverless 工具链、前景和机会。首先我们来看工具链，分为三个版块，分别是开发、部署、监控。 1）开发工具：: 第一是 CLI 工具：主要是兼容商业 FaaS 以及开源的 FaaS ，Servereless. com 做的非常不错了，他们已经兼容了十几种 FaaS 平台。 第二是编辑器的插件：现在很多程序员还是习惯使用 VS Code 或者 Sublime 之类的工具进行开发的，所以需要一个非常方便的插件，可以便于管理、调试。 第三是 WebIDE：WebIDE 是一个衍生品，主要是作为方便去开发、调试的小工具，大多数开发者应该还是会基于本地的编辑器插件来开发。 此外，可能还有一些其它工具有待于补充。 2）部署工具: 常用的部署部署工具包括：Git 集成、CI/CD 持续集成、Hooks （用于同步消息到 IM 工具）等。 那么还需要做一些 Cronjob ，比如说能够非常方便的部署定时任务，并且我能够发布预览版和生产版。 3）监控工具: 最后我们需要 monitor 来报警，需要短信通知、公司邮件通知，还需要日志等。 我说的这三点其实只是产品层面的一些小打小闹，有没有这些功能，对 Serverless 的普及和产业的提高并没有太大的影响。我觉得如果要真正促进 Serverless 发展的话，还需要做以下三件事情。 5. 三个能促进产业发展的机会: 第一件事情是有一个 FaaS Framework 专门用来编写大型项目，同时他是完全兼容 FaaS 架构的。为什么需要 FaaS Framework 呢？如果没有 FaaS Framework 的话，我们是没有办法用 FaaS 编写大型项目的。一个函数，只能做一些简单的事情，假如说需要做一个QQ，做一个微信，一个函数是肯定不行的。 第二件事是 Content as a Service，CaaS 是 FaaS 本身的更高层级的抽象，FaaS 是提供计算能力，然后最重要的其实还是需要一个存储能力，尤其是结构化数据存储，那么就需要一个 CaaS 将存储云化。比如我我的 CaaS 平台去设计一些表和字段，然后这些字段中间还可以互相连接，最后他可以马上帮我我生成 REST API 或 GraphQL 等，并且它还有和 FaaS 结合的能力，我觉得它是未来一个很大的机会。 第三类就叫做云原生编程语言。这种编程语言的话，它完全是架构在现有的云计算厂商上去的，它的逻辑循环是不变的。但是他对硬盘的读写是在云上，并且它兼容各大云平台，比如说我要调用 AWS 的S3，我只需要写原生编程语言就可以，不需要去使用任何的框架，同时它可以启动云上的服务器进行调试。他从语言层面就是一个可伸缩的，比如说我我写了一个 1+1=2 这样一个计算，假如有一亿请求过来，那么在他语言层面就可以帮我调度可以抵抗一亿流量的计算资源。我觉得如果说这三件事情做好的话，能对整个产业有一个巨大的促进作用。 总结: 最后总结一下，Serverless 是真正的云计算，它真的是按需付费，然后不需要去自己去管理任何的基础设施，只需要关注自己的核心业务，目前的云计算还没有真正做到这一点。然后小公司做 Serverlss 的话基本上没戏，主要原因是缺乏信任。 如果是创业公司的话，可以从以下几个层面切入。  第一是做一个 FaaS 聚合器提升开发便捷度，就像 Serverless. com 做的事情一样， 第二就是做一个 FaaS 没然后接外包，这种大型的外包业务能用 Serverless 来做最好。 第三是开发一个 CaaS 然后覆盖查询业务，然后再通过和 FaaS 打通，进而完成一些高阶操作，进而赋能业务。 第四个是开发云原生变成语言，然后与教育机构、培训机构、咨询机构合作，培养人才，人才有了这个意识之后，整个产业才能有一个更大的改变。大概是这样，谢谢大家。  https://github. com/Authing/serverless-oidc  身份认证云是无服务器架构的一个分支，使用身份认证云和使用无服务器架构拥有一样的好处。  请看 Authing 的思考及实践：    为什么身份认证值得上云？  FnGroup 制定的 FaaS 规范  中国首个 FaaS 规范出炉  主页：https://github. com/fngroup/fnlib 7. Q&amp;A: 周家泽：我叫周家泽，我在西塔科技工作，我本身不是程序员，我们公司是主要做区块链当中底层的联盟链的开发。 本来我只是想了解一下 Authing 这个项目，所以我就进来一起听一下介绍这样子。然后我这边有一个问题，就是说因为 Authing 这个项目本身跟身份认证这块相关的，所以我想了解一下，就是说像从我们的角度看，这个项目或者说身份认证的项目跟区块链这块有没有结合点，然后会在什么样子的业务场景里面， 谢扬：Authing 没有区块链，但是和区块链可以有很大的联系。比如数据的主权和身份的主权。场景的话，我觉得还是政府这一块，尤其是政府对公民数据的一个管理，是非常好的一个方向。我们在中国除了运营 Authing 外，还在运营 SoLiD，SoLiD 是万维网之父 Tim 发起的项目，它想要身份和数据由个人来控制。他们在欧洲、在芬兰、在比利时已经有了一个非常好的一个政府的实践经验。稍候，我可以把把一篇论文发给大家看一下这块的实践经验。从我的个人经验来看，区块链对政府的社会治理会有很大的帮助。  论文推荐：通过让公民控制自己的数据简化政府流程李涛：我补充一下，包括我们这次的新冠疫情，其实我们对人群的追踪，每个人都要填很多表格，其实我们都可以用 SoLiD，把我们每个人信息是实时同步给政府的各级组织，而不需要来回筛查、反复填写。 王凯：大家好，首先感谢谢扬精彩的分享。我也学到很多，我也是一个程序员比较杂，然后什么都干，包括运维这些东西，docker 什么的，目前是自己在创业。 我主要做的一个事情是在线教育，主要是留学这块市场留学跟家教，但是我们这个业务比较复杂，是包含了中国跟东南亚，还有欧美的一些各个国家。我的问题是像我们这样的业务就是跨区域的，我该如何选择一个好的 Serverless 产品呢？我用 Serverless 的体验是比较糟糕，部署的稍候挺麻烦的。 谢扬：用 Serverless. com 就好，它集成了国内外的各种各样的一些服务，比如 AWS、Google、腾讯云等，它们都有一个集成，用他们的工具就可以很方便的完成工作，解决你刚才说的跨国的这样一个问题。另外 Serverless. com 现在的社区运营是有中国人的，所以中国人用起来也会比较友好。 Mingliang：大家好，谢谢涛哥和谢扬今天给大家带来的分享，特别好。我之前在上海创业公司电商社交，然后现在把这个业务都清理掉了，目前在新加坡国立大学读博士。我是一年级刚开始读博，我的研究方向是分布式系统，所以自然对这个身份的也很感兴趣。然后我想请教一下谢扬的问题，这个身份有没有和 SDN 有一些契合的点，或者说其实没有的话，可能未来是不是也有一些可以结合的点。 谢扬：我对这个领域还不是很了解，不过 SDN 这个概念的话，我是非常认可的。软件确实可以定义很多的硬件资源的，把它给出抽出来，变成一种信息化资源，包括现在的 SD-WAN。网络通信这一块也是类似这样一个事情。 宋军：大家好，我是宋军，谢扬的分享挺好的，我也有些收获。我先简单自我介绍一下，我现在就职于 Google。Google 的 FaaS 这里有一个小的案例可以去分享，我们当时做了一个中国的一个客户，大概用了 3000 个FaaS，这家客户叫茄子快传，他们用了半年左右，但是过了半年之后基本上切回去了。 问题还是在于成本，我们都在讲，Lambda 是一个按量计费的产品，所以它成本会比较低。实际上当你的业务量特别大的时候，很有可能有非常大的成本，这种成本远远超过虚拟机的成本。 我的问题是，如果有开源的 FaaS 产品，你会优先使用开源 FaaS 还是云上的 FaaS？ 谢扬：从我的角度来说的话，我比较倾向于直接用云的，因为我用 FaaS 就是不想管理服务器，如果还要自己再部署一套 FaaS 对我来说是不太好的。 我还认识一个阿里的朋友，他把一个项目的成本从 800 万降到了 200 万，他怎么做到的呢？他把整个项目打包到一个函项里面去了。这个案例想说的是，每个项目都有一个阈值，然后你没有过阈值，可能就是省钱，阈值一过可能就要亏钱。 王剑宇：先谢谢涛哥和谢扬带给大家的一个技术分享！ 我来自北京，我在进行一个教育创业的项目，我比较关注的是认证服务这块，我一直在考虑到底是该怎么去实现这部分功能，以前是想说自己去写认证，但是认证其实说的是实现也容易，但是你要想把它做得很完善，其实并不容易。 Auth0 之前我也尝试过，但是不是太稳定，这是一个问题。然后还有一个问题，现在国内登录的习惯，大家都是用微信或者手机号，而 Auth0 对国内的这种微信还有手机的支持是没有的。AWS 的 Cognito 我也用过，也是同样的问题。所以也是这个机会，正好我想了解一下 Authing，咱们 Authing 是否更接近于国内的用户习惯。还有第二个问题，我想了解一下有没有好的工具，来简化 FaaS 开发流程的。我之前使用 FaaS 做一些图形处理，搞的非常麻烦。 谢扬：Authing 对于国内用户来说确实是更加友好的，从刚才你的描述来看，Authing 完全可以满足你的需求。再回答第二个问题，如果说要你要是跨国使用的话，那么肯定推荐 Severless. com。因为他基本上兼容市面上所有主流的云厂商。其次 Serverless 已经被腾讯战略合作了，包括他的社区其实现在是由中国人来维护的，咱们用的话其实是非常方便。 王剑宇：好的，再我问一下，因为我之前一直使用的都是国外公司的云产品，然后我就在想，就像这 Authing 这种对 AWS 的支持和对腾讯与阿里的支持，有没有一些可能，我的意思是说，他会不会更侧重于对国内一些云服务厂商的支持？ 谢扬：这事有点反直觉，我们现在对 AWS 的支持反而是最好的。另外 Authing 的流量来源，第一不是中国，是美国，中国只排第二。这说明我们是必须要走国际化路线的，也符合我们一开始的战略。 胡鹏：我先简单自我介绍一下，我之前一直是在区块链领域的，然后之前的工作是钱包相关的研发。因为我们做区块链的话，可能就是思考方式就会比较倾向于那种会考虑理想化的一些场景，就像对安全的一些极端的要求，对隐私的一些极端的要求。然后像刚刚说的 FaaS 的话，其实我让我想到一个问题，就是将很多东西都交给服务器，那么服务器其实就是在这里面权限特别大，可能会有安全上的考虑，尤其是有特殊要求的人。在我们密码学里面，我们现在来看有一个方向，在云上托管的数据是加密的，然后在此基础上进行加密计算，所以我不知道你们内部的产品研发方面有没有这个方向？ 谢扬：我对加密这块不是很了解，我只知道有个同态加密的东西可以在加密结果上进行计算，而不用知道原文。 胡鹏：对，关于隐私计算还有零知识证明这样的技术。 谢扬：除了刚才说的这些，还有一个东西叫做 XAdES，这个是 W3C 的一个规范，比如可以用于你的毕业证的加密，然后给到公司，公司来验证你的文凭是否是真实的，这个也可以参考一下。 王晓亮：大家好，我现在在一家珠海移动公司，主要在大数据方向，所以我们在海外主要用的 Google Cloud，在国内用 AWS。我们用 Serverless 挺久了，其实就是因为我们的业务调用很复杂，比如说我整个的数据进来，然后触发了函数之后，会存储到 S3 什么地方去，或者说有一些数据会重新把它变成结构化的一些数据，最后可能再触发一些函数再存到另外一个地方。我看中间这样的很长的周期，其实整个的监控感觉不是特别好处理，因为涉及到很多不同的服务之间的一些中转，所以我想知道这块有没有相应的解决方案。这是第一个问题，第二个问题就是想知道有没有什么整合的 FaaS 方案。 谢扬：对。这可能只能用一些微服务的这种的措施来做服务治理，你写的每一个函数都需要注册到一个中央的函数服务中心里，然后用各种勾子来 track 他的访问轨迹，最后由一个可视化的界面来展示调用记录。第二个问题我还是推荐 Serverless. com，大家用起来会比较友好。 "
    }, {
    "id": 22,
    "url": "/blog/%E5%9C%A8Odoo%E4%B8%AD%E9%9B%86%E6%88%90Authing%E5%AE%8C%E6%88%90%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/",
    "title": "案例 | 在 Odoo 中集成 Authing 完成单点登录",
    "body": "2020/02/11 - Odoo 是一套基于 Web 的开源商业业务应用程序。Odoo 的主要应用包括 CRM、网站构建器、电子商务、仓库管理、项目管理、计费和会计、销售点、人力资源、市场营销和制造等。 Authing 在云上提供适用于 Web、iOS 和 Android 的通用身份认证和授权平台，可以帮助开发者和企业使用全新的方式、最简单的手段解决复杂的用户身份问题。 本案例为 Odoo 集成 Authing 在云上实现单点登录的教程。 问题:  组织需要一套统一的账号体系来管理公司内外部的员工，并且能打通 Odoo； 除 Odoo 外，还有自研的系统和其他第三方系统；解决方案:  通过在 Odoo 中配置 OAuth 2. 0 集成「使用 Authing 登录」从而完成对 Odoo 的单点登录； 自研系统直接通过 Authing 的 SDK 集成，将 Authing 作为身份中台向各个业务系统分发身份；什么是 OAuth 2. 0: OAuth 2. 0 是目前最流行的授权机制，用来授权第三方应用，获取用户数据。这个标准比较抽象，使用了很多术语，初学者不容易理解。其实说起来并不复杂，阮一峰老师讲的非常好，请从这篇文章查看：http://www. ruanyifeng. com/blog/2019/04/oauth_design. html 集成效果: 如上图所示，用户点击「使用 Authing 登录」后跳转到「Authing 登录页面」，从 Authing 登录后跳回到 Odoo 完成登录。 集成流程: 在 Authing 中创建 OAuth 应用: 如果你还没有 Authing 账号，请到 authing. cn/login 中注册一个账号，注册完成后按照以下流程完成一个 OAuth 应用的创建。 依次点击第三方登录 -&gt; OAuth 应用 -&gt; 创建 OAuth 应用开始创建，如下图所示： 点击后会弹出如下对话框： 必要参数解释：:  应用名称，必填，用户会在登录页面看到此应用名称； 认证地址，必填，一个 *. authing. cn 的二级域名，用户将访问此网址进行登录； 回调 URL，必填，回调到开发者自己业务的地址，此处请填写：     http:///auth_oauth/oea;http:///auth_oauth/signin；    授权模式，必填，该 OAuth 应用支持的授权模式，此处请勾选「implicit」模式：示例： 创建完成后会获得应用密钥，如下所示，请保管好此信息。 在 Odoo 中配置「使用 Authing 登录」: 创建完 Authing 后打开你的 Odoo 网站，依次点击设置 -&gt; 常规设置 -&gt; 集成，找到「OAuth 认证」后打开此开关，如下图所示： 打开开关后点击「OAuth 服务商」进入配置页面，如下所示： 在新页面中填写以下信息：  服务商名称，必填，写 Authing 便于标识； 客户端 ID，必填，在 Authing 平台中配置好的应用 ID； 允许，选填，是否启用此服务商，此处请勾选； 正文，必填，显示在 Odoo 网站上登录按钮的文字； 身份验证网址，必填，请填写：https://sso. authing. cn/authorize/ 作用域，必填，请填写：user； 验证网址，必填，请填写：https://sso. authing. cn/authenticate/； 数据网址，必填，请填写：https://users. authing. cn/oauth/user/userinfo； 填写完成并保存后访问 /web/login 可看到网页上出现了「**使用 Authing 登录**」。 体验登录: 访问 /web/login 并点击「**使用 Authing 登录**」即可体验登录。 "
    }, {
    "id": 23,
    "url": "/blog/GeekTalk036Serverless-%E7%9A%84%E5%89%8D%E6%99%AF%E5%92%8C%E6%9C%BA%E4%BC%9A/",
    "title": "Geek Talk 036：Serverless 的前景和机会",
    "body": "2020/02/10 - 本次与大家探讨 Serverless 生态中缺少的工具以及潜在的创业机会。 主题：Serverless 的前景和机会: 简介：Serverless 正在改变未来软件开发的模式和流程，对于大多数应用而言，借助 Serverless 服务，开发者可以将绝大多数精力投入在业务逻辑的开发整合上，大大缩短开发周期，降低运维成本。本次主题将与大家探讨 Serverless 生态中缺少的工具以及潜在的创业机会。 时间：2月13日 19:00 - 21:00 地点：线上视频会议，报名确认后，邮件和微信通知视频入口。 邮件发送详细地址，请确保邮箱地址和 微信ID 正确 人数：30人 嘉宾：谢扬 蒸汽记忆创始人，SoLiD 中文社区（learnsolid. cn）发起人，连续创业者。 曾任职字节跳动 LarkCloud 云服务部门核心 Hacker，负责⽇活过亿 Serverless 平台产品设计和技术研发，该平台支撑来头条系全产品矩阵：今日头条、抖音、西瓜视频、飞书等。 2016 年创⽴⻰猫科技，研发容器云和 Low/No Code 平台（Gospely. com），获得Plug and Play、PreAngel 等资本投资。曾任好东西传送⻔ CTO，负责知识推荐和亿级维度舆情分析、统计⼯作，服务数⼗万专业⼈群。 ⻓期关注生产⼒科技，以提⾼社会生产⼒为个⼈使命。 扫描以下二维码报名： 关于 Geek2Startup: Geek2Startup 推出的专注于创业团队之间的小范围深度交流分享活动，定期邀请创业中 Geek 同 Startup 之间就产品、设计、开发和运营等维度进行交流，期待每次交流都能解决初创团队遇到的问题，并能互相碰撞出更多的火花，求质不求量，走心不走肾。 目前已经进行超过 30 期，每一位嘉宾都很精彩。 "
    }, {
    "id": 24,
    "url": "/blog/rbac/",
    "title": "RBAC | 组织机构管理最佳实践",
    "body": "2020/02/05 - 在现实生活中，组、角色往往是分层嵌套的，呈树状结构，最常见的就是组织机构，如公司、学校等等。这篇文章，我们会假设一家互联网公司 —— 「非凡科技有限公司」，看看他们是如何使用 Authing 快速完成组织机构建模的。 借助 Authing，可以快速实现基于角色的访问控制（RBAC）。简单来说，RBAC 指的是通过用户的角色（Role）赋予其相关权限，这实现了细粒度的访问控制，并提供了一个相比直接授予单个用户权限，更简单、可控的管理方式。 而在现实生活中，组、角色往往是分层嵌套的，呈树状结构，最常见的就是组织机构，如公司、学校等等。这篇文章，我们会设想一家互联网公司 —— 「非凡科技有限公司」，看看他们是如何使用 Authing 快速完成组织机构建模的。 一、非凡科技有限公司背景介绍: 该公司约 300 名员工，其公司架构大致如下：    一级部门有产品部、研发部、运营部、综合管理部     一级部门下面又有二级部门，如产品部中包含产品经理和设计等。  这是一个典型的树状数据结构，有且仅有一个根节点，以及多个分层的节点。一般而言，根节点就是一家公司、一个组织，其他的每个节点都对应一个部门。 ‌ 这里有一点需要注意：在 Authing 中，这样的节点对应的是一个 Group，比如「非凡科技有限公司」是一个 Group，「产品部」也是一个 Group。我们要做的，是要把这些 Group 放到他在树上所属的位置。 一个 Group 可以拥有多个角色（Role），一个角色包含一个或多个权限（Permission）；而一个 Group 由若干用户（User）组成，某个 Group 中的用户会继承该 Group 下的所有角色，从而具备相关权限。 了解如何管理 Group 中的 User、如何管理 Group 中的 Role、如何配置 Role 的 Permission，请见文档：角色权限管理。 了解如何查询单个用户的 Group, Role, Permission 列表，请见文档：查询用户权限。 如何使用 Authing 完成组织机构管理 1、梳理组织机构节点: 首先，我们需要列举出该组织结构拥有的所有节点：    非凡科技有限公司     产品部     研发部     运营部     综合管理部     产品经理     设计     开发     测试     运维     用户运营     渠道运营     HR     财务     行政  这些节点在 Authing 中都是一个 Group，所以需要先创建这些 Group： const 非凡科技有限公司 = await createGroup( 非凡科技有限公司 )const 产品部 = await createGroup('产品部')const 产品经理 = await createGroup('产品经理')const 设计 = await createGroup('设计')const 研发部 = await createGroup('研发部')const 开发 = await createGroup('开发')const 测试 = await createGroup('测试')const 运维 = await createGroup('运维')const 运营部 = await createGroup('运营部')const 用户运营 = await createGroup('用户运营')const 渠道运营 = await createGroup('渠道运营')const 综合管理部 = await createGroup('综合管理部')const HR = await createGroup('HR')const 财务 = await createGroup('财务')const 行政 = await createGroup('行政')‌ 2、创建组织机构: 接着创建组织机构（一组树状的 Group），这需要指定根节点对应的 Group: let org = await authing. org. createOrg({ rootGroupId: 非凡科技有限公司. _id})3、加入产品部及其子部门节点: ‌ 接着插入产品部的各级节点： ‌ 这里需要指定以下参数：    组织机构 ID     该节点对应的 Group ID     该节点的父节点的 Group ID  如加入产品部节点时，groupId 为 Group 的 ID，parentGroupId 为 Group 的 ID。 await authing. org. addNode({ orgId: org. _id, groupId: 产品部. _id, parentGroupId: 非凡科技有限公司. _id})await authing. org. addNode({ orgId: org. _id, groupId: 产品经理. _id, parentGroupId: 产品部. _id})await authing. org. addNode({ orgId: org. _id, groupId: 设计. _id, parentGroupId: 产品部. _id})4、以此类推，加入所有节点: 研发部： // 添加研发部await authing. org. addNode({ orgId: org. _id, groupId: 研发部. _id, parentGroupId: 非凡科技有限公司. _id})await authing. org. addNode({ orgId: org. _id, groupId: 开发. _id, parentGroupId: 研发部. _id})await authing. org. addNode({ orgId: org. _id, groupId: 测试. _id, parentGroupId: 研发部. _id})await authing. org. addNode({ orgId: org. _id, groupId: 运维. _id, parentGroupId: 研发部. _id})运营部： await authing. org. addNode({ orgId: org. _id, groupId: 运营部. _id, parentGroupId: 非凡科技有限公司. _id})await authing. org. addNode({ orgId: org. _id, groupId: 用户运营. _id, parentGroupId: 运营部. _id})await authing. org. addNode({ orgId: org. _id, groupId: 渠道运营. _id, parentGroupId: 运营部. _id})‌ 综合管理部： // 添加综合管理部await authing. org. addNode({ orgId: org. _id, groupId: 综合管理部. _id, parentGroupId: 非凡科技有限公司. _id})await authing. org. addNode({ orgId: org. _id, groupId: HR. _id, parentGroupId: 综合管理部. _id})await authing. org. addNode({ orgId: org. _id, groupId: 财务. _id, parentGroupId: 综合管理部. _id})await authing. org. addNode({ orgId: org. _id, groupId: 行政. _id, parentGroupId: 综合管理部. _id})5、查看最新组织机构结构: 到现在，我们的非凡科技有限公司组织机构见建模完成了，是时候获取其最新的树状结构了： const { tree } = await authing. org. findById(org. _id)​        二、如何向组织机构中添加用户和配置权限: 前面说过，Authing 中一个组织结构节点对应一个 Group，对此我们提供了完整的 SDK。 1、为组织机构节点配置权限: 相关 SDK 见：角色权限管理。 非凡科技有限公司的所有员工，都具备开具发票、使用公司邮箱的权限。与此对应，在此我们创建两个角色：Invoice Submitter 和 Corp Email User。 ‌ 其中 Invoice Submitter 具备以下权限：    invoice:login     invoice:create     invoice:query     invoice:list     invoice:delete  Corp Email User 具备以下权限：    corp-email:login     corp-email:send     corp-email:receive     corp-email:list     corp-email:detail  这可以通过以下代码完成： const InvoiceSubmitter = await createRole('Invoice Submitter')let permissions = await createPermissionBatch(['invoice:login', 'invoice:create', 'invoice:query', 'invoice:list', 'invoice:delete'])await authing. authz. addPermissionToRoleBatch({ roleId: InvoiceSubmitter. _id, permissionIdList: permissions. map(x =&gt; x. _id)})const CorpEmailUser = await createRole('Corp Email Use')permissions = await createPermissionBatch(['corp-email:login', 'corp-email:send', 'corp-email:receive', 'corp-email:list', 'corp-email:detail'])await authing. authz. addPermissionToRoleBatch({ roleId: CorpEmailUser. _id, permissionIdList: permissions. map(x =&gt; x. _id)})接着让 Group 非凡科技有限公司具备 Invoice Submitter 和 Corp Email User 两个角色： await authing. authz. addRoleToGroup({ roleId: InvoiceSubmitter. _id, groupId: 非凡科技有限公司. _id})await authing. authz. addRoleToGroup({ roleId: InvoiceSubmitter. _id, groupId: 非凡科技有限公司. _id})现在，非凡科技有限公司这个节点将会具备 Invoice Submitter 和 Corp Email User 两个角色 2、向组织机构节点添加用户: 相关 API 见：角色权限管理。  某个 Group 内的用户会继承该 Group 内所有角色的权限（如果有重叠，将会取并集）。 下面我们往用户池中注册新用户，然后将其加入非凡科技有限公司 Group 中： const user = await createUser()await authing. authz. addUserToGroup({ groupId: 非凡科技有限公司. _id, userId: user. _id})3、查询用户具备的权限: 相关 API 见：查询用户权限。 const { rawList: permissionList } = await authing. userPermissionList(user. _id)‌permissionList 如下：可见，此用户已经继承了 Invoice Submitter 和 Corp Email User 两个角色的所有权限： [ 'invoice:login', 'invoice:create', 'invoice:query', 'invoice:list', 'invoice:delete', 'corp-email:login', 'corp-email:send', 'corp-email:receive', 'corp-email:list', 'corp-email:detail', ]开发者拿到用户权限列表之后，可以在业务代码层判断用户是否具备某一特定权限，如： if  corp-email:login  not in user. permissionList: return  Permission Denied 4、使用 RBAC 的优势:    系统性、可重复性的权限指派     更方便的用户权限审计，快速定位问题     快速地添加、修改角色，甚至可以调用 API 实现     减少授予用户权限时发生错误的可能性     引入第三方用户/新用户/未登录用户时，赋予他们预先配置好的角色，比如 guest 分组   更多关于 RBAC 的介绍请参考实现基于角色的访问控制（RBAC）。  三、总结: 本文我们以「非凡科技有限公司」为例，介绍了如何将一棵组织机构树转换成一组嵌套、有层次的 Group。通过 Authing 提供的分组角色权限管理 API，可以为 Group 配置角色、指派成员，使得该 Group 中的用户继承所需的权限，从而完成组织机构建模与权限控制。 关于 Authing: Authing 是中国领先的 IDaaS 服务提供商，对标美国独角兽 Auth0。创始团队来自字节跳动、百度、IBM、阿里云、滴滴出行等互联网企业。Authing 提供开发者友好、易拓展的身份认证和授权平台，赋能企业在云端管理身份，主要功能包括：单点登录、用户分析、扫码登录、多因素认证、行为审计、风险控制、跨平台设备管理、IoT 身份认证等；兼容国际各类标准协议：OAuth2. 0、OIDC、SAML、AD/LDAP、WS-Fed、JWT 等。 支持云交付和私有化部署方式，帮助企业和开发者千倍级提升生产效率。 Authing 自上线以来已经服务海内外超过 3000 名企业开发者、拥有约 50 万的开发者社区和托管数百万终端用户，每月百万人次通过 Authing 平台进行认证，并已经服务数十家付费企业客户，覆盖教育、人工智能、出版社、 物联网等多个行业。 "
    }, {
    "id": 25,
    "url": "/blog/a-intro-about-authing-to-everyone/",
    "title": "一份所有人都能理解的关于 Authing 的介绍",
    "body": "2020/02/03 - 我们加入了这场游戏，带着不同的视角。 Authing 解决什么问题？: 解决开发者的问题: 在程序开发的过程中，用户认证和权限处理是非常复杂的一个模块。涉及到很多枯燥，重复的工作，比如验证用户身份，验证权限，密码加密与校验，鉴权（这又涉及到安全）。 举个现实例子：比如你是一个办公自动化软件厂商，你新签了一个客户，对方是一个 5 万人的企业组织，你是否要在你的软件里新建 5 万个账户？ 你准备如何建？ 你是否在你的程序设计中考虑未来的这个场景？如果再复杂一点场景的呢（比如这 5 万人的组织，还需要和他们业务上下游供应商的软件系统打通身份认证进而数据共享，你准备通过哪一个协议，如何实现这个对接）？ 你是否需要有人来解决这些问题？10天？ 20 天？ 30 天？还是 60 天？它的成本是多少？可能存在的风险？ 解决企业管理者的问题: 你是一个企业管理者，你的公司可能采购了或使用了 2~3 套不同的软件供货商的产品。你的员工还要使用你供应链上下游供货厂商的软件系统，你的员工是否在这些不同的环境当中，一套密码走天下，或和他人共享账号？你是否可以知晓并管控这些风险？ 在这些不同网络边界环境中，你如何区分，分析，那些异常的登录，异常的访问？如何确保你业务数据的安全？ 是否可以通过这些登录的数据，不同应用间访问调用的授权记录，分析、识别你业务潜在的风险与变化。 当你的应用需要和你供应链上下游厂家的应用共享数据，你如何实现不同组织间、不同应用间的权限对接，身份追踪？你是否需要跨组织的身份识别，进而是身份授权（经理的权限和员工的权限的授权区别），你准备如何打通，如何处理不同组织间身份的识别与鉴权，进而实现数据共享，同时保证整个业务链更流畅，更安全？ 当你面对 2~3 个不同软件供货商也许还好，那当我们把这个数量放大到 8~10，每一个员工的入职，离职，职位变动是否都牵涉到账号的开通和权限管理，注销和变更。每一个软件系统，每一个不同员工，每一个不同身份变更，需要多少次操作？我想没有人会喜欢这个操作。 当你面对不止一家供货商的软件系统，面对他们各自不同的后端用户系统，鉴权管理，技术实现。你计划如何应付自如？ 解决终端用户的问题: 作为终端用户，你是否每天要面对不同的应用、 不同的系统、不同的账号？ 牢记不同的密码，不同的用户名？ 抑或一套账号密码走天下？如果走到哪里都可以让你刷脸支付，刷脸吃饭，刷脸解锁，听着是不是很美好？ 再进一步，你是否想更多保护自己的隐私，自由掌控你在这些不同系统上的数据，全部在你手里。就如你可以在微信里登录各种各样的小程序，你可以授权你的昵称，你的性别，你的头像，为啥不能再多授权一点呢？ 比如你的收货地址，你的简历，你的相册，你昨天写的一份文档，你在大学时代所有的照片。你修改了你的头像，你的昵称，你的收货地址，你的简历，所有这些小程序里面的读到的信息都改变了。你下架了你的简历，所有小程序-招聘类的 APP 都不再有你最新的简历，你开放了你的简历，所有照片类小程序都可以读到你的简历数据（至于每一个 APP 里如何呈现，组合这些数据是程序的事情）。 你想买一个北京市内环内，总价 800-900 万， 3 房 2 厅，100 平以上，楼层朝南，税费在 20 万以下的不动产，你只需要把这个需求写出来，开放读取权限，所有的房产类小程序可以自动搜索到你的需求，为你匹配，把结果发送给你，然后由你决定打电话，由谁帮你完成交易。而不是你去不同的网站注册账户，上传需求，一遍又一遍重复的劳动。 Authing 就是为解决上面的问题而生，从身份开始，从企业端开始。我们为企业提供一套效率工具，进而触达每一个人。 现实的世界是什么样子: 现实世界，我们的数字身份存在于一个虚拟的网络世界，为我们守护者不同应用的数据。在这个虚拟世界我们就是一串 0 和 1 。 在 WEB 最开始的阶段，每个人架起自己的网站，通过超文本向外界展示自己，分享自己，WEB 赋予了每一个个体通过互联网触达这个世界每一个角落的可能。后来世界发生了变化，人们发现可以通过 Web 做的更多，有了 CRM 系统，OA 系统，营销系统，论坛系统，各种各样的系统，通过数字世界的 0 和1 帮我们守护这些不同系统的数据，通过一个超链接分享我们的数据。再后来，当第一部 iPhone 被创造的时候，移动互联网来到了这个世界，随后是越来越多的 App ，我们生活在这些不同的 App ,在每一个 App 里面有一个我们的身份。 一开始足够多的 App 占据了我们的生活，到后来一些超级 App 逐渐占有我们访问量的 80% ，再后来 App 可以支持手机短信登录，可以支持使用其他超级 App 登录，超级 App 成为其他 App 的母体（如微信，支付宝）。总算为我们缓解了一下身份的问题。可是 App 却拒绝彼此之间互动，我们很难将 App-1 里面的数据分享到 App-2（想象一下早期微信拒绝 163 的音乐转发，包括现在也是，你必须通过浏览器中转，才能在微信里用支付宝转账）。我们也不可能使用搜索引擎整合不同 App 之间大量的数据。 这就是现实世界：每一个组织，每一个企业都在想怎么让我们留存在他们的平台，他们的城堡，他们的护城河之内（网络世界的我们就是 0 和 1）。 为什么是现在？: 云计算赋予了企业更多可能， SaaS 应用也逐渐成为应用软件新的主流打开方式。 不同的 SaaS 解决不同的问题，当我们越来越多的使用云，我们也将越来越多的面对不同的 SaaS 。 所以我们看到了 Okta , Auth0 , PingIdentity , Yufuid , AWS cognito 等等这些组织，在努力解决这些问题，身份与统一协作。 我们也加入了这场游戏，带着不同的视角：如何更好的共享数据。 为什么是我们？: 也可以是任何人，只是我们还没有看到和我们拥有一样观察的同类。 我们将如何做？: 我们从把 Authing 打造为中国版的 Auth0 开始，为企业提供一套效率工具，接管复杂的权限设计，认证，授权对接，进而触达每一个个体，通过守护他们的数据，让你、我、让每一个人可以授权更多。 Auth0 已被验证过的商业模式，详情为什么 Auth0 值十亿美金?，最起码在中国我们没看到这么一家企业类似，除了 Authing。更多了解：Auth0 和 Authing，谁是身份云的高脚杯？ 没讲太多技术，面对的问题，我想每一个人都感同身受。 关于 Authing: Authing 是中国领先的 IDaaS 服务提供商，对标美国独角兽 Auth0。创始团队来自字节跳动、百度、IBM、阿里云、滴滴出行等互联网企业。Authing 提供开发者友好、易拓展的身份认证和授权平台，赋能企业在云端管理身份，主要功能包括：单点登录、用户分析、扫码登录、多因素认证、行为审计、风险控制、跨平台设备管理、IoT 身份认证等；兼容国际各类标准协议：OAuth2. 0、OIDC、SAML、AD/LDAP、WS-Fed、JWT 等。 支持云交付和私有化部署方式，帮助企业和开发者千倍级提升生产效率。 "
    }, {
    "id": 26,
    "url": "/blog/solid-flemish/",
    "title": "论文推荐：通过让公民控制自己的数据简化政府流程",
    "body": "2020/01/29 - SoLiD 是一个令人兴奋的新项目，由万维网发明者 Tim Berners-Lee 爵士在麻省理工学院启动。 该项目旨在从根本上改变 Web 应用程序的中心化趋势， 它将真正地让数据所有权属于用户，并改善隐私问题。 SoLiD 是一个令人兴奋的新项目，由万维网发明者 Tim Berners-Lee 爵士在麻省理工学院启动。 该项目旨在从根本上改变 Web 应用程序的中心化趋势， 它将真正地让数据所有权属于用户，并改善隐私问题。 本文是 SoLiD 项目在比利时的实践经验，作者有 Web 创始人 Tim 爵士、SoLiD 的核心开发者 Euben Verborgh（编者最爱的一名 SoLiD 开发者）等。详见 [SoLid中文社区]: https://learnsolid. cn/，对「数据主权」主题感兴趣的读者可以加微信：jinjian0414 ，加入微信群讨论。 适合阅读本文的读者包括：  对新技术和自动化敏感、能感知技术趋势的开发者； 渴望提升国家治理水平的官员； 医疗和保险等民生行业的从业者； 渴望创新的企业家； 在寻找新方向、敢于承担巨大风险的投资者； 对新趋势好奇的早期尝鲜者；本文作者 Raf Buyle, Ruben Taelman, Katrien Mostaert, Geroen Joris2, Erik Mannens, Ruben Verborgh and Tim Berners-Lee 涉及机构：  imec IDLab - Ghent University, Ghent, Belgium ( raf. buyle@ugent. be ) Informatie Vlaanderen, Flemish Government, Brussels, Belgium Department of Computer Science - University of Oxford, Oxford, UK0. 概要: 政府为了提供更好的公共服务，通常会存储大量的个人信息，比如公民姓名、家庭住址、婚姻状况和职业等。同时由于政府由各种政府机构组成，因此经常存在多个数据副本。这对数据一致性、隐私性和访问控制提出了更高的要求，特别是在 GDPR 和 CCPA 等类似的法律出台后。为了解决这个问题，我们探索了一种基于名为「SoLiD」的技术生态，这种技术可以让公民在自己的数据存储柜中维护自己的数据。我们已经将 SoLiD 用于两个影响力很大的场景，在这两个场景中，公民的数据存储在个人数据库柜中，任何组织可以在得到公民授权的情况下访问公民的数据，同时公民可以选择授权哪些数据给访问者。我们发现 SoLiD 可以高效重塑公民与公民之间的关系、公民与数据的关系和公民与应用的关系。我们坚信这个实验可以加速公共行政管理效率和公民控制自己数据的进程。 Keywords: 个人数据、去中心化、GDPR、Solid、Linked Data。 1. 介绍: 随着《通用数据保护条例》（GDPR）的出台，欧盟委员会提供了一个旨在赋予个人数据控制权的法律。这个法律不一定会对数据存储商不利，如果合适的使用这项法律，GDPR 可以让以前复杂的数据数据流通变得简单。欧洲公司想要符合 GDPR 规范需要耗费巨大的成本和资源，而国际公司和跨国公司也必须尊重 GDPR 带给欧盟成员的权利。这造成了一些反作用，那些在欧洲且遵循 GDPR 的公司变得越来越不欢迎，反而那些非欧洲公司在遵循 GDPR 上有明显优势。 并非所有受 GDPR 约束的组织都有可疑或恶意的意图，这里面有很多组织在试图遵守法律时遇到了很大的困难。地方、地区和国家政府肯定会遇到此类问题。政府的机构层级复杂，每层都有历史性增长的数据需求和流程。因此，公民数据存在很多副本，这些副本导致的安全性和法律问题已经存在于很多部门。这些政府现在要求从技术上符合 GDPR 规范，以简化他们的数据管理成本。 当前，政府层级的数据处理面临的最大问题是：如何平滑的将数据从 A 迁移到 B。这不仅在不同领域之间带来了许多技术挑战，当政府开始“数据培训”时，这也成为一个复杂的法律问题，因为涉及到的服务器过多。如：数据经过 A，B，C 和 D 站，而 B 和 C 在法律上不允许看到 A 和 D 可以看到的所有数据。因此，存在复杂的过程来精确验证 B 和 C 的访问权限是什么，然后在将数据推送到 D 时重新整合它们的结果。一个明显的例子是低排放区（LEZ），LEZ 禁止在市中心或仅在特定条件下允许车辆行驶，因为它们散发出太多有害物质。在法兰德斯，车辆与自然人进入 LEZ 时，联邦信息检查车牌号与所有人是否进入到了指定区域；最终数据经过处理，并判断是否允许车辆在城市内通行。 「SoLiD」生态系统通过「公民自有数据存储柜（Personl Online Data，Pod）」 来解决上述问题，这样的好处是所有的公共和私人数据都存储在一个地方。每个机构都不需要在 A 和 D 之间移动数据，而是请求公民授权自己能查看哪些数据。这样，数据就不必到处移动，并且可以自动评估每个数据请求是否是 GDPR 合规的。在线上和线下控制我们的个人数据是一个趋势性主题，有大量研究在此领域。这里面的关键概念是人们可以选择将个人数据存储在何处，这些数据是去中心化存储的。与 SoLiD 技术相似的还有区块链技术，它通常也被认为是个人数据管理的解决方案。SoLiD 相较区块链的优势是天生是协议化的，不需要各方沟通就可以互相交换数据，而区块链不认识彼此各方达成的协议。区块链对于在没有中央银行或中央管理机构的情况下进行支付的情况下非常有效，比特币是一个成功的案例。区块链可以跨多个节点复制数据，如果你在不需要受信任的第三方时，可以计划使用区块链。如果你是核心参与者，或者各方之间相互信任， 那么你不需要区块链。而且，区块链的不变性意味着无法删除数据，这可能是一个挑战 GDPR 第 17 条赋予的人们删除其个人数据的权利。 在本文中，我们探讨了对个人数据进行控制的观点，并讨论了我们使用 SoLiD 实现的两个特定用例。SoLiD 提供了基于开放标准和基于 Web 的生态系统。根据 Harrison，Pardo＆Cook 的说法，生态系统是一个隐喻，通常用来表达参与者、组织、物质基础设施和象征性资源之间相互依存的社会系统，而这种生态必须在技术驱动的信息密集型社会系统中创建它们。数字生态系统的一个典型例子是开放数据生态系统。开放数据是指政府义务的在他们的网站上免费提供其非隐私敏感和非机密数据网络。开放数据重用依赖于数据提供者提供的数据和元数据，而提供者则依赖于重用者的反馈来增加数据质量。尽管开放数据生态系统中的所有参与者都相互依赖有效地发展自己的业务，公共行政部门和决策者最有可能引导这些开放的政府生态系统。Zuiderwijk，Janssen 和 Davis指出开放数据生态系统的挑战是相关的“政策，许可，技术，融资，组织，文化和法律框架，以及 ICT 基础设施” 。开放数据将“单向街道”重新连接为“双向通信”的生态系统，可能与使公民控制其个人数据的挑战同样困难。通过将 SoLiD 的方法应用于两种具有高影响力的场景，Flemish 政府的目标是建立能让公民控制自己数据的能力。 本文的结构如下：在下一节中，我们将介绍我们要解决的挑战。之后，我们在章节 3 中介绍有关 SoLiD 的基础知识；在第 4 节中，我们讨论了使用 SoLiD 解决挑战的方法， 然后在第 5 节中讨论我们的实现。最后，我们得出结论并在第 6 节中介绍我们的经验教训。 2. 挑战: 比利时北部联邦国家和地方政府旨在增强公民的能力，使其可以在公共服务、银行、健康保险和电信提供商等不同环境下在线重用其个人信息。政府通常是个人数据（例如住所、医疗信息等）的托管方，这些信息存储公共行政部门的各种信息系统这种。Flanders 的政府管理部门之间允许共享和重用数据，这样减轻了公民的管理行政负担，是欧洲实施“仅一次原则”的体现 。但是实际上，公共行政部门正在努力控制公民的数据。 第一个挑战是政府管理部门努力保留个人数据，例如：最新的电子邮件地址、电话号码或银行帐号。由于一些公民很少与政府联系，个人信息在各种信息系统中通常已经过时。 第二个挑战涉及允许公民在不同的环境中重用其数据，例如在申请新工作时授权自己的文凭。GDPR 法规 2016/679 声明： “为了确保自由给予同意，不得提供同意在特定情况下处理个人数据的有效法律依据 是数据主体和控制器之间的明显失衡，尤其是在 控权人是公共机构，因此不太可能自由同意在特定情况下的所有情况下都应考虑在内。”（欧洲委员会， 2016年，第43条）。 换句话说，政府与公民之间的关系通常被认为是不平衡的关系，因为政府拥有比公民更多的权力。因此，获得公民的同意后重用政府信息系统中管理的权威数据，不能认为是自由提供的。欧洲政府部门之间共享数据不是基于给定的同意，而是具有特定的合法依据。 因此，我们主要研究的问题是：政府程序如何实现通过使公民控制其个人数据来简化 GDPR 合规成本？这个研究问题有两个观点：一方面，公民如何与政府部门共享数据？另一方面，公民如何重用存储在政府信息中的数据（这些数据的用途各不一样）？ 该项目评估了 SoLiD 的去中心化原则来解决这些障碍。SoLiD 是一个生态系统，可让个人将数据存储在他们的Data Pod（数据柜）。这使用户可以真正控制其数据，因为他们可以选择在何处存储他们的数据以及谁可以访问。整套技术基于语义网技术（Linked Data）和去中心化，对于想让用户重新控制数据的政府部门和私人组织有很大价值。 3. SoLiD: SoLiD 是一个基于 Web 的生态系统，它通过提供个人数据柜将数据与应用程序分开。个人数据柜让他们可以存储任意数据，同时可以授权哪些人、哪些应用有哪些权限读写他们的个人数据柜。 图1 显示了 SoLiD 与当前应用程序体系结构的对比。其特点是不用依赖一些应用程序，公民可以控制自己的个人数据。应用程序需要从公民那里请求访问权限，以便能够对其数据进行操作。 重要的是，SoLiD 不是应用程序或平台，而是协议：开放的标准和约定。它基于现有的 Web 标准，包括 Linked Data 技术栈，任何人都可以实现他们。 图片 1. Current applications are a combination of app and data. Thereby, the app becomes a centralisation point, as all interactions with that data have to go through the app. By introducing the concept of a personal data pod, Solid pushes data out of applications, such that the same data can be managed with different applications. This removes the dependency on a centralised application, as data can be stored independently in a location of the citizen’s choice. Data Pod 是个人存储柜，可以存在于 Web 上的任何位置，例如你自己搭建的服务器，社区搭建的免费服务器或政府提供的存储空间。在 Pod 中，所有者拥有数据创建、编辑、和控制管理的权限。所有者可以决定授予哪些人拥有权限，例如允许家庭成员看到他们的假期照片或允许同事阅读会议笔记。而且，人员、组织和应用程序可以向 Pod 的公共收件箱发布请求以获取对个人数据的访问权限。人们至少拥有一个数据柜，但他们还可以拥有其他多个 Pod，例如用于家庭数据、工作数据和医疗数据等。 而典型的中心化应用程序要求用户将数据存储在应用程序，SoLiD 通过使数据个人化来扭转这一局面，并允许用户授权哪些应用程序可以用我的数据。虽然简单的应用程序只需要一个 Pod，但 SoLiD 的真正功能在于让应用程序组合来自多个 Pod 的数据，这减少了很多数据对齐会产生的成本。例如，SoLiD 上的社交网络应用程序可以将个人信息（例如帖子、朋友、评论和喜欢的信息）存储在个人数据柜中，而他们的可视化需要组合不同数据 Pod 的数据。这解决了两个基本问题，首先，数据不再需要在不同的应用程序中复制，因为应用程序将指向单个副本。二是，不再出现同步问题：因为只有一个副本数据，应用程序不会再有不同步的数据。 SoLiD 的巨大优势主要体现在以下特点上：: 1.  独立身份：: 用户选择他们的身份以及身份所处的位置。在 SoLiD 中，个人标识符（WebID）是一个像 URL 一样的唯一地址； 2. 控制数据：: 用户可以授予和撤消对任何人和应用的细粒度访问权限； 3. 随意切换应用程序：: 由于数据可以灵活被不同应用访问，避免了供应商锁定的危险，用户可以选择他们最喜欢的公司推出的产品。 为了我们的目的，SoLiD 精确地解决了上述“数据传输”问题。数据不再在不同的政府机构之间移动，每个政府机构都直接使用原始数据来源，即公民的数据柜。这解决了多个副本和同步的问题，以及 GDPR 问题，即哪个机构有权访问哪些公民的哪些数据。因为每个机构都单独对 Pod 进行请求，因此对 Pod 的读写是一个重要的话题，接下来我们会讨论这个问题。 4. 解决方案：使用 SoLiD 交换公民个人信息: 在本节中，我们解释了使用 SoLiD 在公民和政府之间共享数据的方法。我们首先会解释需求， 之后我们会讨论两种场景， 在这两个场景中：（1）公民的数据（例如：电子邮件地址、电话号码）存储在 Pod 中；（2）重用权威政府数据，例如文凭等信息。 4. 1 需求: 对于我们的用例，我们假设所有公民都可以使用全局唯一的统一资源标识符（URI）（称为WebID）来唯一标识。该 WebID 指向有关公民的更多详细信息的，尤其是指向个人数据柜（Pod）。此外，我们假设所有政府部门和组织都具有 WebID 和 Pod。所需的组件 Fig2 所示。通常，SoLiD Pod 具有公共收件箱，任何人都可以在其中发布消息。然后消息只能由所有者读取、修改和删除。我们假定所有 Pod 都满足此约定，因为我们使用了此约定来保证用户之间的通信。 4. 2 用例：公民共享个人信息: Flemish 政府开发了一种数字助理，可提供市民与不同政府部门互动。一个有用的例子是向公民提供有关公共服务状态的通知。由于大多数公民几乎没有与政府之间的互动，相比较与私营部门之间的互动， 联系信息以及有关其偏好的信息通常已经过时。用了 SoLiD 之后，角色互换了，市民的 Pod 成为主要联系信息和偏好的来源。该用例解决了第一个挑战， 避免了用户必须在各个公共和门户网站中保持其数据的最新状态。 我们使用电子邮件地址说明此用例，该用例适用于任何个人信息。 前提条件：公民爱丽丝（A）可以通过其 WebID 唯一标识，同时 A 在 SoLiD Server（S）上托管有一个个人在线数据存储（Pod）。同样，组织（O）具有一个WebID 和一个 Pod。 用例 1. 1：共享个人数据。A 使用安全的令牌访问向 O 请求身份验证，成功通过身份验证后，A 可以通过网页按钮授权的形式授予 O 访问其电子邮件地址的权限，成功后，O 可以从 A 的 Pod 中读取电子邮件地址。拓展功能：若 A 不再信任 O，A 可以撤回 O 对她电子邮件地址的访问权限。 用例 1. 2：管理个人数据。A 使用安全的另外访问 O 请求身份验证，身份验证成功后，A 可以在 O 提供的用户界面将其电子邮件地址添加到其自己的 Pod 中。扩展功能：A 可以修改或删除她的电子邮件地址。 用例 1. 3：请求访问个人数据。O 将「访问 A 的电子邮件地址」请求发布到 A 的公共收件箱。看到此请求后，A 授予 O 读取对她电子邮件地址的访问权限，并将通知发送到O 的公共收件箱。收到通知后， O 可以查看 A 的电子邮件地址。 4. 2 用例：公民授权权威个人信息: 政府的目标是使公民能够重用存储在不同政府级别的权威数据源中的个人信息。比如，在申请新工作时共享大学颁发的文凭。或者在申请贷款时获得有关其收入的信息（如 Fig3 所示）。该用例解决了上文提到的第二个挑战。首先，公民不同意政府与其他人共享他们的数据，因此我们将公民的学位信息存储在公民自己的 Pod 中。换句话说，在 GDPR 的上下文中，数据主体是数据的控制者。这种情况表明，SoLiD 重塑了公民、其权威数据以及应用程序之间的关系。如果公民拒绝授权，则政府可以像今天在税收领域一样行使这项权利。 前提条件：公民爱丽丝（A）拥有一个 WebID，同时有一个 Pod，托管在 SoLiD Server（S）上。同样，大学（U）具有一个 WebID 和一个 Pod。A 的雇主（E）也具有 WebID。 用例 2. 1：A 注册为 U 的学生，并且必须提供她的 WebID，这将使A 在大学毕业后收到证书。 用例 2. 2：A 保持对 U 的授权直到毕业。U 维护 A 的所有信息，直到 A 毕业。这些信息包括课程、年级、教师等。此类信息是不能公开访问的，只有 A 对此有读写权限。 用例 2. 3：A 大学毕业后向 U 索要证书。A 要求提供证书的（摘要）副本，以便她可以与第三方共享。U 会生成此证书的摘要，并将其发送到 A Pod 中的收件箱。该证书由 U 使用非对称加密进行数字签名。 用例 2. 4：共享文凭。现在 A 在她的收件箱中有她的文凭副本，她可以与任何人分享。例如，她可以将其发布到她的数据 Pod 中，然后授予其雇主 E 的 WebID 的读取权限。 用例 2. 5：检查文凭的有效性。如果 E 要检查文凭 A 的有效期，E 必须在该文凭上检查 U 的签名。E 通过从文凭中提取签名，确定权限（U）来完成此操作。这可以是 使用现有的文档签名机制（例如 XAdES）完成。 5. Flemish 公民的个人助理: 在本节中，我们将讨论结合 “Mijn Burgerprofiel” 的实施方法。Mijn Burgerprofiel 的意思是「我的公民资料」，他是 Flemish 公民的智能数字助手，通过该助手，公民可以看到其所有授权状态和数据。此外，欧洲还有一个标准的电子身份验证规范，名为：eIDAS。该规范减少了身份被滥用或改动的风险。用户可以使用以下方式通过“我的公民”个人资料访问个人数据： 1）通过智能卡读卡器或通过手机获取比利时电子身份证；2）在手机上安装应用程序。 我们在上一节详细介绍了第一个用例，即公民共享个人信息（例如，电子邮件地址）。如第 3 节所述，我们的应用程序和数据是分离的。因此，我们方法的实施还需要两个组件：（1）数据 Pod，（2）用于查看和使用数据的应用程序界面。 接下来，我们将讨论这两个组件。 5. 1 Data Pod 应用程序: 在我们的实施中，我们使用 Node Solid Server 5. 0. 1（NSS）创建和托管数据 Pod。如果用户已经有一个 Pod，则可以用来共享个人信息。NSS允许我们为任何公民和政府组织创建安全的数据柜。默认情况下，政府为所有公民提供数据 Pod。但是，如果公民渴望对 Pod 拥有更多控制，他们可以选择自己托管数据 Pod，例如在自己的服务器上运行 NSS。 5. 2 个人信息管理基础设施: 为了允许政府能方便的访问公民的特定信息，我们扩展了“我的公民资料”，所有 Flemish 公民都拥有一个资料。目前，这个信息集中存储在“我的公民资料”的数据库中。为了能和 SoLiD 和谐的工作，我们修改了“我的公民资料”，该修改版本不是将信息存储在每个公民的数据 Pod 中，而是存储在 Flemish 政府的服务器中，“我的公民资料”就像一个公民，也拥有一个WebID。 对于我们的用例，我们专注于存储和获取公民的电子邮件地址。为了达到这个目的，我们实现了三个组件：SoLid Linker（将原来的市民与 SoLiD 连接起来）、电子邮件提取器和电子邮件可视化工具。这些组件将在后面说明。 5. 3 SoLiD Linker: 在“我的公民个人资料”的个人资料设置中，我们添加了一个字段，人们可以将其帐户与任何 SoLiD WebID 关联起来，如 Fig4 所示。默认情况下，公民使用政府提供的默认 WebID。 5. 4 Email Extractor: 如果某个公民有一个有效的 SoLid WebID 链接到其“我的公民个人资料”帐户，则应用程序可以尝试通过跟踪文件中的链接来提取其电子邮件地址。公民的数据 Pod 中包含电子邮件地址。基于WebID，电子邮件提取器组件可以确定用户的 Pod。使用此 URL，提取程序将使用“我的公民个人资料” WebID 的身份验证令牌向 SoLiD Pod 发送 HTTP GET 请求。如果公民已授予“我的公民个人资料”对该文件的读取权限，则该文件的内容将被返回；否则将返回授权错误。如果没有遇到错误，则电子邮件提取器组件将返回公民的电子邮件地址。 5. 5 Email 可视化工具: 我们在“我的公民资料”概述页面上，添加了一个字段，该字段显示用户的电子邮件地址（如果用户有或用户授权后才显示）。该信息是从用户链接到的 WebID 中读取的，此信息始终即时提取，不会再存储在其他地方。这意味着当公民修改了该值，这个页面能立即显示更新后的值。该可视化工具可用于自动化流程，例如在即将举行的选举中发送提醒。 6. 总结: 在本文中，我们介绍了有关 SoLiD 在政府治理中的实施经验。Flemish 政府接受了我们对“我的公民资料”进行的修改，这样我们可以让其与 SoLiD 生态系统互操作，从而使公民可以控制其数据。我们解决了两个引人注目的挑战；首先，政府部门努力保持个人数据是最新的，其次是允许公民重复使用存储在其中的数据，这些数据存储在不同背景下的政府信息系统。该案例证明了 SoLiD 可以解决公民对数据的控制权问题。 未来研究的新途径包括如何保持对用户权威数据（如住所）最大程度的利用。这应确保公民共享的信息与私营部门的关系始终是最新的。另一个明显的点是，这项研究旨在告知用户同意重用数据是他们的天赋人权。这个概念称为 “知情同意”。此外，所有操作都应透明地记录在 SoLiD Pod 中，包括：访问数据、修改数据、授权同意和撤销权利，这与我们银行帐户中的财产相当。这种细粒度和结构化的日志还可以通过使用机器学习算法来检测异常和数据泄露。为了更完整，未来的研究应该关注于不同的挑战，如如何打造可持续的商业模式。 SoLiD 建立在现有 Web 标准和方法上（例如关联数据和去中心化，因此 SoLiD 可以被视为过程创新，而不是技术创新），因此与 SoLiD Pod 的集成非常简单。我们已经使用电子邮件地址说明了这种简单度，但目的是将其扩展到所有个人数据。 我们希望这个在 Flemish 地区的 SoLiD 试验可以加快解决政府在公共管理和私人组织中面临着的同样的复杂性问题，同时让用户重新控制自己的数据。 引用:  Belgisch Staatsblad. Wijzigingen met betrekking tot de onderzoeksmiddelen van de administratie. (2011). http://www. ejustice. just. fgov. be/cgi_loi/change_lg. pl?language=nl&amp;la=N&amp;table_name=wet&amp;cn=2011041406 Accessed 9 July 2019 Berners-Lee, T. ; Verborgh, R. Welcome to Solid. (2019). https://rubenverborgh. github. io/Solid-DeSemWeb-2018/#title Accessed 9 July 2019 Buyle, R. , Van Compernolle, M. , De Paepe, D. , Scheerlinck, J. , Mechant, P. , Mannens, E. ,&amp; Vanlishout, Z. Semantics in the wild: a digital assistant for Flemish citizens. In Proceedings of the 11th International Conference on Theory and Practice of Electronic Governance (pp. 1-6). ACM (2018). doi: https://doi. org/10. 1145/3209415. 3209421 Cruellas, J. C. , Karlinger, G. , Pinkas, D. , &amp; Ross, J. Xml advanced electronic signatures(xades). W3C Recommendation (2003). http://www. w3. org/TR/XAdES Accessed 9 July2019 Decker, C. , &amp; Wattenhofer, R. (2013, September). Information propagation in the bitcoinnetwork. In IEEE P2P 2013 Proceedings (pp. 1-10). IEEE.  de Montjoye, Y. A. , Wang, S. S. , Pentland, A. , Anh, D. T. T. , &amp; Datta, A. On the TrustedUse of Large-Scale Personal Data. IEEE Data Eng. Bull. , 35(4), 5-8 (2012) Esposito, C. , De Santis, A. , Tortora, G. , Chang, H. , &amp; Choo, K. K. R. (2018). Blockchain:A panacea for healthcare cloud-based data security and privacy?. IEEE Cloud Computing,5(1), 31-37.  European Commission. Regulation (EU) 2016/679 of the European Parliament and of theCouncil of 27 April 2016 on the protection of natural persons with regard to the processingof personal data and on the free movement of such data, and repealing Directive 95/46. Official Journal of the European Union (OJ), 59(1-88), 294 (2016) European Commission. Guidelines on Consent under Regulation 2016/679 Luxembourg:Publications Office (2018) https://ec. europa. eu/newsroom/article29/itemdetail. cfm?item_id=623051 Accessed 9 July 2019 European Commission. It’s your data – take control. Luxembourg: Publications Office(2018). https://ec. europa. eu/commission/sites/beta-political/files/data-protection-overviewcitizens_en. pdf Accessed 9 July 2019 Fatema, K. , Hadziselimovic, E. , Pandit, H. J. , Debruyne, C. , Lewis, D. , &amp; O’Sullivan, D. Compliance through Informed Consent: Semantic Based Consent Permission and DataManagement Model. In Proceedings of the 5th Workshop on Society, Privacy and the Semantic Web - Policy and Technology (PrivOn2017), Vienna, Austria (2017) Harrison, T. M. , Pardo, T. A. , &amp; Cook, M. Creating open government ecosystems: A research and development agenda. Future Internet, 4(4), 900-928. MDPI AG (2012). doi:https://doi. org/10. 3390/fi4040900 Janssen, M. , Charalabidis, Y. , &amp; Zuiderwijk, A. Benefits, adoption barriers and myths ofopen data and open government. Information systems management, 29(4), 258-268 (2012). doi: https://doi. org/10. 1080/10580530. 2012. 716740 Jia, J. , Jin, G. Z. , &amp; Wagman, L. The short-run effects of GDPR on technology venture investment (No. w25248). National Bureau of Economic Research (2018). doi:10. 3386/w25248 Mansour, E. , Sambra, A. V. , Hawke, S. , Zereba, M. , Capadisli, S. , Ghanem, A. , … &amp;Berners-Lee, T. A demonstration of the solid platform for social web applications. In Proceedings of the 25th International Conference Companion on World Wide Web (pp. 223-15226). International World Wide Web Conferences Steering Committee (2016). doi:https://doi. org/10. 1145/2872518. 2890529 Mun, M. , Hao, S. , Mishra, N. , Shilton, K. , Burke, J. , Estrin, D. , … &amp; Govindan, R. Personal data vaults: a locus of control for personal data streams. In Proceedings of the 6th International Conference on Emerging Networking Experiments and Technologies (p. 17). ACM (2010). doi: https://doi. org/10. 1145/1921168. 1921191 Narayanan, A. , Toubiana, V. , Barocas, S. , Nissenbaum, H. , &amp; Boneh, D. A critical look atdecentralized personal data architectures. arXiv preprint arXiv:1202. 4503 (2012) Pollock, R. (2011, March 11). Building the (Open) Data Ecosystem. http://blog. okfn. org/2011/03/31/building-the-open-data-ecosystem/ Accessed 9 July 2019 Solid. Welcome to Solid (2019). https://solid. inrupt. com/ Accessed 9 July 2019 Van Kleek, M. , &amp; OHara, K. The future of social is personal: The potential of the personaldata store. In Social Collective Intelligence (pp. 125-158). Springer, Cham (2014) Verborgh, R. Ruben Verborgh on data &amp; privacy. Imec Magazine (2019). https://www. imec-int. com/en/imec-magazine/imec-magazine-january-2019/back-to-thefuture-how-we-will-regain-control-of-our-personal-data Accessed 9 July 2019 Vescovi, M. , Perentis, C. , Leonardi, C. , Lepri, B. , &amp; Moiso, C. My data store: toward userawareness and control on personal data. In Proceedings of the 2014 ACM InternationalJoint Conference on Pervasive and Ubiquitous Computing: Adjunct Publication (pp. 179-182). ACM (2014). doi: http://dx. doi. org/10. 1145/2638728. 2638745 Whitley, E. A. Informational privacy, consent and the “control” of personal data. Information security technical report, 14(3), 154-159 (2009). doi:https://doi. org/10. 1016/j. istr. 2009. 10. 001 Yeung, C. M. A. , Liccardi, I. , Lu, K. , Seneviratne, O. , &amp; Berners-Lee, T. Decentralization:The future of online social networking. In W3C Workshop on the Future of Social Networking Position Papers (Vol. 2, pp. 2-7) (2009) Zuiderwijk, A. , Janssen, M. , &amp; Davis, C. Innovation with open data: Essential elements ofopen data ecosystems. Information Polity, 19(1, 2), 17-33 (2014) Zyskind, G. , &amp; Nathan, O. Decentralizing privacy: Using blockchain to protect personaldata. In 2015 IEEE Security and Privacy Workshops (pp. 180-184). IEEE (2015). doi:0. 1109/SPW. 2015. 27 本文译者：蒸汽记忆——Authing 身份云运营主体和 SoLiD 中文社区维护主体。原文地址：https://drive. verborgh. org/publications/buyle_egose_2019. pdf 关于 Authing: Authing 是中国领先的 IDaaS 服务提供商，对标美国独角兽 Auth0。创始团队来自字节跳动、百度、IBM、阿里云、滴滴出行等互联网企业。Authing 提供开发者友好、易拓展的身份认证和授权平台，赋能企业在云端管理身份，主要功能包括：单点登录、用户分析、扫码登录、多因素认证、行为审计、风险控制、跨平台设备管理、IoT 身份认证等；兼容国际各类标准协议：OAuth2. 0、OIDC、SAML、AD/LDAP、WS-Fed、JWT 等。 支持云交付和私有化部署方式，帮助企业和开发者千倍级提升生产效率。 Authing 自上线以来已经服务海内外超过 3000 名企业开发者、拥有约 50 万的开发者社区和托管数百万终端用户，每月百万人次通过 Authing 平台进行认证，并已经服务数十家付费企业客户，覆盖教育、人工智能、出版社、 物联网等多个行业。 "
    }, {
    "id": 27,
    "url": "/blog/RBAC%E5%AE%9E%E7%8E%B0%E5%9F%BA%E4%BA%8E%E8%A7%92%E8%89%B2%E7%9A%84%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/",
    "title": "RBAC 实现基于角色的访问控制",
    "body": "2020/01/17 - 基于角色的访问控制（Role-based access control，简称 RBAC），指的是通过用户的角色（Role）赋予其相关权限，这实现了细粒度的访问控制，并提供了一个相比直接授予单个用户权限，更简单、可控的管理方式。 一、认证 vs 授权？: 首先让我们用一句话区分认证（Authentication）和授权（Authorization）：  认证是识别请求方是谁的过程； 授权是知道了请求方是谁之后，判断其是否具备某些权限的过程；Authing 支持非常丰富的认证、授权手段：  认证手段有：传统密码、验证码登录、丰富的第三方登录（微信、小程序、微博、GitHub、支付宝、QQ 等，未来还会有更多），以及企业级的 LDAP、SAML、OIDC 等。 授权手段有：完整的 OAuth、OIDC 流程。对于授权流程，访问控制（Access Control）策略是非常重要的一环，目前 Authing 一共支持（或即将支持）三种访问控制手段：    老版本的用户角色（deprecated）     RBAC（基于角色的访问控制，2020/02/03 已经上线）     ABAC（基于属性的访问控制，未来即将支持）  二、什么是 RBAC ?: 基于角色的访问控制（Role-based access control，简称 RBAC），指的是通过用户的角色（Role）赋予其相关权限，这实现了细粒度的访问控制，并提供了一个相比直接授予单个用户权限，更简单、可控的管理方式。 当使用 RBAC 时，通过分析系统用户的实际情况，基于共同的职责和需求，将他们分配给不同的角色。然后可以授予每个用户一个或多个角色，每个角色具有一个或多个权限，这种 用户-角色、角色-权限 间的关系，让我们可以不用再单独管理单个用户，用户从具备的角色里面继承所需的权限，从而使得用户赋权这件事变得更加简单。 举一个公司内所有在职员工具备登录公司邮箱的权限的场景，如果应用 RBAC，就可以赋予所有在职员工 employee 角色，employee 角色具备 email:login 权限，如此所有员工就具备了登录公司邮箱的权限。如果有员工离职，只需要将其移出 employee 角色，而不需单独收回权限。本质上，一个角色（Role）就是一组权限（Permission）的集合。使用角色添加、删除、调整权限，相比单独赋予单个用户权限更加简单。当你的用户基数不断增长时，角色会变得尤为有用。 在规划访问控制策略时，最佳实践是给予用户完成工作必须的最小权限。 三、使用 RBAC 的优势:  系统性、可重复性的权限指派 更方便的用户权限审计，快速定位问题 快速地添加、修改角色，甚至可以调用 API 实现 减少授予用户权限时发生错误的可能性 引入第三方用户/新用户/未登录用户时，赋予他们预先配置好的角色，比如 guest 分组四、下面是 Authing 目前所支持或即将上线的相关 Feature：:       Feature   Authing 支持情况   备注         角色               创建/修改/删除 角色   In future release           分页查询   YES           通过名称、描述搜索角色   YES           角色能被授予给分组   YES           角色嵌套、分层   In future release           角色通过 namespace、多租户管理   In future release           查询角色具备的所有权限   YES           查询角色中包含的所有用户   YES                           用户               创建/修改/删除 用户   YES           分页查询   YES           通过昵称、邮箱搜索用户   YES           查看最近注册、登录的用户   YES           通过第三方应用查找用户   In future release           通过 lucence 语法搜索用户   In future release           用户可以拥有一个或多个角色   YES   最多 50 个       用户能在一个或多个分组里   YES   最多 50 个       查看一个用户具备的所有角色   YES           查看一个用户所在的所有分组   YES           查看一个用户所具备的所有权限   YES           通过 JSON 导入/导出用户   YES           自定义密码加密函数   YES                           权限               创建/修改/删除 权限   YES           分页查询   YES           通过名称、描述搜索权限   In future release           能直接赋予用户权限   To be determined           能授权给一个或多个角色   YES           查询所有具有某个权限的用户   In future release           查询所有具有某个权限的角色   In future release           查询所有具有某个权限的分组   In future release                           分组               分页查询   YES           创建/修改/删除 分组   YES           通过名称、描述搜索分组   In future release           直接从第三方用户目录导入（如 AD, LDAP, SAML）   In future release           分组嵌套、分层   In future release           查看分组的子分组   In future release           分组通过 namespace、多租户管理   In future release           查看一个分组具备的所有用户   YES           查看一个分组具备的所有角色   YES           查看一个分组具备的所有权限   YES           配置               自定义授权流程策略（authorization policies）   In future release           自定义是否将权限加入 Token   In future release   默认为否       自定义是否将角色加入 Token   In future release   默认为否       自定义是否将分组加入 Token   In future release   默认为否      YES ：当前支持。     In future release ：已加入未来规划，不久后将会支持。     To be determined ：还在设计是否需要添加此功能。  五、RBAC 最佳实践：分组管理用户: 除了直接赋予用户某个角色，作为 RBAC 的最佳实践，我们还可以通过分组管理用户，将一个分组和一组角色绑定，在此分组内的所有用户就会继承这些角色，并自动具备了这些角色包含的权限。这些概念之间的关系为：Permission &lt;-&gt; Roles &lt;-&gt; Groups &lt;-&gt; Users，如下图所示：    分组：Employee, Contractor     角色：Vacation Requester, Invoice Submitter, Express Submitter     权限：Read vacation requests, Create vacation requests 等  用分组管理用户、分组包含一组权限，这也是我们推荐使用的方式。 分组和角色的区别 分组(Group)和角色(Role)有什么区别？    角色是一组权限的集合。     分组侧重于管理用户，一个分组通常拥有多个角色，分组内的用户会继承分组内所有角色的所有权限。  常见的 Group 和 Role 示例：    Group      admin: 系统管理员，通常包含系统维护者。   employee: 正式雇员。   employer: 面试官。   hr   intern: 实习生   ops_engineer: 运维工程师      Role      Invoice Submitter: 具备发票报销的相关权限。   Vacation Requester: 具备申请假期的相关权限。   Corporation Email User: 具备使用公司邮箱的的相关权限。   Production Server Operator: 具备线上服务器的操作权限。   HR App User: 具备使用 HR 系统的相关权限。   举例来说：可以这样建立 Role 和 Group 之间的关系：  intern 具备 Corporation Email User 这个角色，但是不具备 Vacation Requester 和 Invoice Submitter 这两个角色。 employee 拥有发票报销和申请假期角色，但是不具备线上服务器的操作权限。 ops_engineer 拥有发票报销、申请假期、线上服务器的角色。我们推荐使用分组（Group）管理用户，用 Role（角色） 管理权限，不要直接赋予单个用户某个权限。如果是某个用户临时需要具备某个角色，可以临时授予，结束之后再收回。 关于 Authing: Authing 是中国领先的 IDaaS 服务提供商，对标美国独角兽 Auth0。创始团队来自字节跳动、百度、IBM、阿里云、滴滴出行等互联网企业。Authing 提供开发者友好、易拓展的身份认证和授权平台，赋能企业在云端管理身份，主要功能包括：单点登录、用户分析、扫码登录、多因素认证、行为审计、风险控制、跨平台设备管理、IoT 身份认证等；兼容国际各类标准协议：OAuth2. 0、OIDC、SAML、AD/LDAP、WS-Fed、JWT 等。 支持云交付和私有化部署方式，帮助企业和开发者千倍级提升生产效率。 Authing 自上线以来已经服务海内外超过 3000 名企业开发者、拥有约 50 万的开发者社区和托管数百万终端用户，每月百万人次通过 Authing 平台进行认证，并已经服务数十家付费企业客户，覆盖教育、人工智能、出版社、 物联网等多个行业。 相关阅读:  Authing 的故事：我为什么开发 Authing？ 如何在远程办公中保持高效的研发效率？ 一份普通人能理解的关于 Authing 的介绍 Authing 是什么以及为什么需要 Authing？ 为什么身份认证值得上云？ Authing @ 2019 总结 Authing 开发资源最全合集"
    }, {
    "id": 28,
    "url": "/blog/%E4%BD%BF%E7%94%A8Authing%E4%B8%8EAWS%E6%9C%8D%E5%8A%A1%E9%9B%86%E6%88%90/",
    "title": "使用 Authing 集成 AWS 服务",
    "body": "2019/12/20 - Authing 是一个开发者友好、拓展性极高的身份认证云服务，每月有超过 100 万次用户被 Authing 认证和授权。本次分享将介绍如何企业常见的认证授权场景，可以满足中国本地用户对于 Cognito User Pool 的需求，并且提供本地化的服务。同时本文将讲解 Authing 如何与 AWS 各类服务集成，如 Cognito Identity Pool, IAM, S3, Lambda, AD 等等。 Cognito Identity Pool: Cognito User Pool 负责认证。终端用户可以通过 user pool 完成注册登录流程。 Cognito Identity Pool 负责授权（访问控制），将使用 AWS 资源的权利授权给终端用户。 Amazon Web Services(AWS) 虽然作为市场份额全球第一的云计算厂商，其产品也不是完美无缺的，Cognito （AWS 的身份认证解决方案）及其附带的中文文档就是一个反面教材，其难用程度令人发指。当然，除了不易用之外，还有访问速度缓慢，不适用于中国市场等问题存在。 而国产的 Authing 可以解决使用 Cognito 的诸多问题，使用 Authing User Pool， 可以替代 Cognito User Pool，构建起国内用户与 AWS 资源之间的桥梁。 在创建 AWS Identity Pool 时，可以配置自定义 Authentication providers，这里我们将 Developer provider name 设置为 . authing. cn 格式：  整个流程中一共有三方参与：终端用户、Authing 、AWS，具体过程如下：  终端用户使用 Authing 用户池完成认证 Authing 开发者在服务端调用 AWS 的 GetOpenIdTokenForDeveloperIdentity 接口，获得 IdentityId 和 Token。 终端用户调用 GetCredentialsForIdentity 使用 token 换取访问 AWS 资源所需的 credentials。GetOpenIdTokenForDeveloperIdentity 需要以下参数：  IdentityPoolId：你的 AWS Identity Pool ID。 Logins：一组 provider name 到 provider tokens 的映射，provider token 可以任意可以区分用户的字符串，比如 Authing 用户在用户池内的唯一 ID。 Logins : {   &lt;authing-userpool-id&gt;. authing. cn :  5ccb24701bbaf00d50xxxxxxx  // Authing 用户池 ID}我们能从请求返回数据中 获得 IdentityId 和 Token。这样，我们就在 Authing 用户池用户 和 Cognito Identity ID 之间构建起了联系。接着可以使用 GetCredentialsForIdentity 获取 credentials，从而访问相关资源。 IAM: IAM(Identity and Access Management) 管理 Users、Groups、 Roles 对 AWS 资源的访问权限，通过给 Role 添加相关权限，达到使用相关 AWS 资源的目的。 例如，新建 Cognito Identity Pool 的时候，会默认创建两个 role： 可以给此 role 添加相关权限，比如 通过集成 Authing 与 Cognito Identity Pool，我们在 Authing User ID 与 Cognito Identity ID 之间构建起了映射关系。而每个 Identity ID，可以拥有不同的 Role。不同的 Role，具备不同的 AWS 资源访问权限。这也就将 Authing 和 AWS 的各种服务结合了起来。 S3（Simple Storage Service）:  在线 Demo：https://sample. authing. cn/aws-demo/  Github Repo：https://github. com/Authing/aws-s3 下面举一个具体的例子：用户使用 Authing 登录之后，会得到一个唯一的 Authing User ID，通过 GetOpenIdTokenForDeveloperIdentity，将 Authing User ID 与 Cognito Identity ID 对应起来。 在 aws console 配置 role permissions 和 bucket policy，实现每个 Authing 用户能且仅能对 users/ 目录的文件进行增删改查操作： Bucket Policy 如下： {   Version :  2012-10-17 ,   Id :  Policy1576670578319 ,   Statement : [    {       Sid :  ListYourObjects ,       Effect :  Allow ,       Principal :  * ,       Action :  s3:ListBucket ,       Resource :  arn:aws-cn:s3:::authing-aws-demo ,       Condition : {         StringLike : {           s3:prefix :  users/${cognito-identity. amazonaws. com:sub}         }      }    },    {       Sid :  ReadWriteDeleteYourObjects ,       Effect :  Allow ,       Principal :  * ,       Action : [         s3:GetObject ,         s3:PutObject ,         s3:DeleteObject       ],       Resource : [         arn:aws-cn:s3:::authing-aws-demo/users/${cognito-identity. amazonaws. com:sub} ,         arn:aws-cn:s3:::authing-aws-demo/users/${cognito-identity. amazonaws. com:sub}/*       ]    }  ]}${cognito-identity. amazonaws. com:sub} 会被替换成当前请求用户的 Cognito Identity Id。Statement ListYourObjects 让用户具备遍历 users/${cognito-identity. amazonaws. com:sub} 的权利，Statement ReadWriteDeleteYourObjects 让用户可以操作 users/${cognito-identity. amazonaws. com:sub} 下面的文件。 Role Permission 同理： 实现效果如下： Lambda:  在线 Demo：https://sample. authing. cn/aws/Github Repo：https://github. com/Authing/authing-lambda Authing 非常适合用作 serverless 函数计算的身份认证层，开发者可以在 Authing 控制台（第三方登录 -&gt; OIDC 应用）创建 OIDC 应用： 然后在前端用几行代码即可实现一个具备标准 OIDC 认证流程的表单： const authing = new AuthingSSO({  appId:  5dfa6fd7673d4xxxxxxxxxxxx , // OIDC 应用的 ID  appDomain:  aws-demo. authing. cn });const res = await authing. trackSession();if (!res. session) { // 未登录  authing. login() // 唤起下面显示的登录表单} else {  const userInfo = res. userInfo;}生成的表单如下： 可以通过以下网址体验：https://aws-demo. authing. cn/ 用户使用 Authing 成功登录之后，会在 authorization 请求头中带上 token，开发者只需要在 lambda 函数中对这个 token 进行验证即可。 Authing 提供丰富的检验 token 的手段供开发者选择：文档地址：https://learn. authing. cn/authing/advanced/authentication/verify-jwt-token  使用 Authing 提供的 SDKimport Authing from 'authing-js-sdk'(async () =&gt; {  const authing = await new Authing({    clientId: 'your_client_id',    secret: 'your_client_secret'  });  const result = await authing. checkLoginStatus('USER_JWT_TOKEN');})()若 Token 合法，则返回数据为：{ status: true, code: 200, message: '已登录', token: {  . . . // Token 数据 }}若 Token 不合法，message 会提示相关错误信息。我们还提供了所有的错误代码列表：https://learn. authing. cn/authing/advanced/error-code 。 如果你想 reduce package size，也可以直接构造 GraphQL 请求： import axios from 'axios'axios({ url:  https://users. authing. cn/graphql , method: 'POST', data: {  operationName: 'checkLoginStatus',  query: `query checkLoginStatus($token: String) {     checkLoginStatus(token: $token) {      status      code      message      token {       data {        email        id        clientId        unionid       }       iat       exp      }     }    }`,  variables: {   token: 'USER_JWT_TOKEN', // 这里传入 request 携带的 token  } },}). then((res) =&gt; { const d = res. data; if (d. errors) {  throw d. errors[0]; } return d. data. checkLoginStatus;});. then((loginStatus) =&gt; { // handle login status}). catch((error) =&gt; { // handle error}); 使用 OIDC 密钥自己检验：传入 jwt. verify 函数的第二个参数就是 OIDC 应用的密钥。if (event. authorizationToken) {  // remove  bearer   from token  const token = event. authorizationToken. substring(7);  try {    let decoded = jwt. verify(token, '02128f34e11b11xxxxxxxxxxxxxx'),     expired = (Date. parse(new Date()) / 1000) &gt; decoded. exp    if (expired) {     cb('Unauthorized, Login information has expired. ');    }else {     cb(null, generatePolicy('user', 'Allow', event. methodArn));    }   } catch (error) {    cb('Unauthorized');   } } else {  cb('Unauthorized'); } 使用 OIDC 应用的 rest 接口https://oauth. authing. cn/oauth/oidc/validate_access_tokenGET 请求参数：access_token，必填。返回的 Response 示例： {   state : 1,   isRevoked : false,   isDeleted : false,   _id :  yokj1gN8kCBixIhc6KEj7SNsMcJ ,   id :  yokj1gN8kCBixIhc6KEj7SNsMcJ ,   accessToken :  eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9. eyJqdGkiOiJkVlJmenZEbHZQRG50dG9LWnJ1WkciLCJzdWIiOiI1Y2U1M2FlYTlmODUyNTdkZDEzMmQ3NDkiLCJpc3MiOiJodHRwczovL29hdXRoLmF1dGhpbmcuY24vb2F1dGgvb2lkYyIsImlhdCI6MTU2OTU4MDMwOCwiZXhwIjoxNTY5NTgzOTA1LCJzY29wZSI6Im9wZW5pZCBwcm9maWxlIiwiYXVkIjxxxxxxxxxxxxxx ,   accessTokenExpiresAt :  2019-09-27T11:31:45. 000Z ,   scope :  openid profile ,   appId :  5d01e389985f81c6xxxxxxxxxxxxx ,   userOrClientId :  5ce53aea9f8525xxxxxxxxx ,   when :  2019-09-27T10:31:48. 000Z ,   iss :  https://oauth. authing. cn/oauth/oidc ,   sub :  5ce53aea9f85257dd13xxxxxxxx ,   aud :  5d01e389985f81c6c1xxxxxxxxx ,   exp : 1569583905000,   iat : 1569580308000,   user_id :  5ce53aea9f85257xxxxxxxxx ,   issued_to :  https://sso. authing. cn ,   audience :  5d01e389985f81c6xxxxxxx ,   expires_in : 3360,   access_type :  offline }开发者可以通过验证结果的不同，进行相应的业务逻辑处理。如在这个示例中，未登录下 private 接口的 http status code 为 401： 登录之后成功返回数据： AD: Authing 为每个用户池自动创建了一个 LDAP 服务，访问 Authing LDAP 服务器需要使用 Authing 的应用密钥 (Secret)，认证命令如下所示： $ ldapsearch -H ldap://ldap. authing. cn:1389 -x -D  ou=users,o=AUTHING_CLIENT_ID,dc=authing,dc=cn  -w  AUTHING_CLIEENT_SECRET  -LLL -b  ou=users,o=AUTHING_CLIENT_ID,dc=authing,dc=cn 具体文档可见：https://learn. authing. cn/authing/advanced/ldap-idp。 通过 Active Directory Connector，AWS 开发者可以直接复用 Authing 的 LDAP-IdP。 其他 AWS 资源: 在上面的 Cognito Identity Pool 一节中，我们实现了 Authing User ID 与 Cognito Identity ID 的一一对应的关系，这样 Authing 就具备了使用所有 aws 相关资源的能力，开发者可以参考我们前面给的示例。 "
    }, {
    "id": 29,
    "url": "/blog/%E4%B8%87%E7%BB%B4%E7%BD%91%E4%B9%8B%E7%88%B6%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%BB%E6%9D%83%E9%9D%A9%E5%91%BD/",
    "title": "Web 全栈大会：万维网之父的数据主权革命",
    "body": "2019/11/20 - Web 给予了每个人建立自己博客和网站的自由，每个人都可以在自己的网站或其他人的网站内分享他们的知识、见解和故事。Web 就相当于一个人的精神世界，Web 是从生活中来的，但是却高于生活。 Web 全栈大会：万维网之父的数据主权革命大家好，今天我和大家分享一下由万维网之父发起的一场数据主权革命。什么叫数据主权？很容易理解，现在我们的数据是把持在巨头手里的，你的微信通讯录和聊天记录都无法导出，不管是从人权角度还是从法理角度，这些数据应该都是属于你的，但是你没有控制权，SoLiD 要做的核心的一件事就是让这些数据归于用户控制。它带来了一种全新的开发范式，这个范式是啥我们接下来会有介绍。那么什么是革命？革谁的命？也非常清晰，就是革那些体大不尊的巨头的命。  本文整理自蒸汽记忆创始人谢扬在 2019 年 11 月 16 日在成都 Web 全栈大会上的演讲，内容有删改。完整PPT 可从 Github 上查看：https://leinue. github. io/webfullstack-2019/index. html 那么在开始之前呢，我先按照惯例自我介绍下。我目前在创业，我们公司的名字叫做蒸汽记忆，取自工业革命的开始，我们想做提高社会的生产力的事情，并将全球的公开信息变成知识图谱。我们的使命是在一个身份下互联全人类的文化基因，构建全球互联的生产力平台。同时，我是 SoLiD 中文网的发起人，SoLiD 就是今天要讲的主题。在职业经历上，我是一名 Web 全栈开发者，其次也是知识图谱研究者。在创业之前，我曾经任职好东西传送门的 CTO，当时主要负责知识推荐和舆情分析等工作。在字节跳动时主要负责一款日活过亿的 Serverless 产品的研发和产品设计工作。 最后，我还是一名共产主义者。 那么下面，我们就开始进入 SoLiD 和数据主权革命的主题了。 在正式介绍 SoLiD 之前，我先介绍下 SoLiD 的发起人，万维网之父 Tim。他最大的贡献是制定了 HTML 语言和建立了 W3C 万维网联盟。这里我也推荐大家看一本书来更好的理解万维网之父建立 Web 的一个初衷，这本书的名字叫：《编织万维网 —— 万维网之父谈万维网的原初构想》。这本书呢，就介绍了万维网是怎么从一个实验室项目推广到全世界的。为什么我们现在要看这本书？因为现在就是一个巨头垄断的时代，万维网和互联网已经偏离了原本的设计，我们要回顾这些创作者的初心是啥，同时我们年轻一代的人也要从中发现新的机会。另外今年是互联网的五十周年，也是万维网的三十周年，那么再过三十年和五十年，互联网会变成什么样？这值得每个人去思考，尤其是开发者，互联网的建造者，命运是在你们手中的。Tim 对我们整个互联网的发展有着举重若轻的作用，假如没有 Tim，那么就现在的 Web，那么今天的大会也就没有了。 好，这是对 Tim 的一个介绍。 这句话是 2012 年伦敦奥运会的时候 Tim 发的一个 Twitter，This is for Everyone。这个意思呢，就是说，Web 作为一个有统一规范的生态，是对每个人都开放的，每个人都能从中平等的获取信息，这也是 Web 被创建的一个初衷。 那么再看这张图，主要就是现在的互联网巨头们。大家可以看到图片中间是一个人，在聚光灯下，无论是 Youtube 还是 Googkle 都在围着他转，上面还有摄像头，这个人的所有信息都在这些互联网巨头手里一览无余。这就是我们目前 Web 的一个现状 —— 巨头控制几乎所有的东西。 那么 SoLiD，今天我们这场分享的主角，就是用来重塑现有的互联网的一个有力工具。用 SoLiD，我们将重构人与数据和人与应用之间的关系。这个理解起来很简单，我们现在所有的应用和数据都是一种耦合关系，Google 有 Google 的数据库，Facebook 有 Facebook 的数据库，那么在 SoLiD 的设计中，Google 或者 Facebook 应用本身和数据应该是分离的关系，Google 可以读取 Facebook 的数据库，Facebook 也可以读取 Google 的数据库，而所有这些数据，都是由用户去控制，去授权的。有了 SoLiD，我们的 Web 会有一个新面貌出现。 首先我们来回顾下 Web 的原初构想。这里我想举一个我自己的例子，我在小学三年级第一次拥有了自己的电脑，相比周围的朋友同学是比较晚的，那么在这个时候我还是处于一种打游戏的阶段，电脑只是我的一个玩具。到了初中的时候，也就是 08 年 09 年，此时我发现了编程这件事情，让我非常的着迷。我从来没有攒过计算机硬件设备，我做的第一件比较专业的和计算机相关的事情是破解了家里的 ADSL，然后用 Discuz 搭建了一个网站。我记得我那个时候特别喜欢上微机课，每到微机课的时候，我都会在学校的电脑教室里打开我的网站，这个网站是一个 IP，然后向同学炫耀：「快看，这是我做的网站，这个服务器还是我家里的电脑！」此后，我还搭建了我的个人博客，从 09 年一直写博客到 19 年，整整十年。到了我高中的时候，也就是 12 年 13 年的时候，移动互联网开始逐渐的火热起来，此时很多事情就变得越来越奇怪了，大家开始讲流量生意，讲用户数据变现，互联网让我越来越陌生了。讲这么一个故事想说的是，Web 是一个非常公平的平台，连一个初中生都能在此基础上进行各种创新，这得益于统一的 W3C 标准和繁荣的生态。这非常符合 Web 在诞生之日就有的一个定位。 在十年前，是一个个人站长的黄金年代。我们当时做个人博客，个人博客里面链接了其他更多的个人博客，每个人都可以在不同的网站里面发表不同的评论，每个人都不需要作出任何妥协就可以发表自己的声音。Web 最重要的一个发明，超链接技术，现在已经被各大 APP 进行了无限度的分割。这里我一定要吐槽一下微信公众号不能插入超链接，腾讯这种吃相难看的绥靖政策，严重背离了 Web 的初衷，他们不是历史的推手，而是历史的倒退者。 Web 给予了每个人建立自己博客和网站的自由，每个人都可以在自己的网站或其他人的网站内分享他们的知识、见解和故事。Web 就相当于一个人的精神世界，Web 是从生活中来的，但是却高于生活。 而那些更好的帮助人与人之间进行连接的企业，也获得了很大成功，比如 flickr，last. fm 等。 正因为 Web 的自由性和无门槛，才促进了全球的创新。每个人都可以通过 Web 将自己的伟大想法告诉全世界。而开发者开发 Web 应用不需要得到任何人的许可，可以随时随地发布自己的创意。在这里，我还要吐槽微信小程序，微信小程序有两个非常大的缺点，一是严格的审核，这点我们都理解它最本质的原因。这种严格的审核，阻碍了大量优质的个人开发者上线优质的应用；二是其自创的语法，已经偏离 W3C 体系，他造了另外一个平行世界，加重了世界的熵。 小程序把本来一种开放的生态，变成了一种围墙，这是历史的倒退。 Web 的无门槛进入带来了大量创新，比如亚马逊、Twitter 等，这些大家都很清楚了。 诚然，这些大型企业给予了普通用户非常多的便利，但是我们的数据却都掌握在巨头手中。以前很多人写博客，现在很多人只写微博、发朋友圈。不错，我们拥有了很好的用户体验，但是我们丧失了对数据的控制权。我举个例子来说明我们为什么需要数据的控制权，假如你有一个知乎账号，有几十万粉丝，某一天因为某些事情被知乎封掉了账号，此时你所有的粉丝关系都因为知乎的单方面封禁而丢失了，粉丝其实是你生产的数据，但是却不被你掌控。最好的处理方式是，知乎只是被我授权了我的粉丝关系的一个应用，他封禁的只是我对他平台的使用权，但是我的粉丝关系其实还存在我这边，我还可以授权给微博、微信等。说到粉丝关系，就会有另外一个概念，粉丝是为了什么？是为了推送，因此 SoLiD 也有一个 websocket 推送规范，这些推送可以推送给你的好友列表，不依赖任何应用程序。 另外一个问题就是隐私泄漏问题，2018 年 Facebook 剑桥分析事件泄漏了 5000 万用户数据，最近 Facebook 又泄漏了 7000 页的用户数据使用条款，该条款说明了 Facebook 如何挟持用户数据杀死竞争对手。在今年年初，杭州一家爬虫公司被封，该爬虫公司爬取了中国八亿人的简历，每年获利上亿。我自己也有亲身经历，最近有猎头找到我，我问她怎么找到我的，她说在某网站上看到我的简历，但是我从未用过那个网站。 尤其是各种各样的小程序，我们认为这严重损害了 Web 的通用性，主要在于他们在商业载体下的封闭性。 大家也可以看看这张图，图里面各大社交公司筑起了自己的高墙，在不同的社交网络中切换时极其复杂。而上面西装革履的大公司资本力量，淡然的看着这一切，这就是我们 Web 的现状。 在这样一个巨头把持数据的中心化时代，严重伤害了多元性、创新性和选择性。 这里我想问大家一个问题，如果你只能创建一个应用，那么你会选择做 weixin. com 还是 identity-provider. org? 我猜大多数人会选择做 weixin. com，这里面理由非常多，更大，更全，普通用户更容易感知等。如果是我，我会选择做 identity-provider. org，这是一种范式的转变，变成了以用户身份为中心，然后围绕用户身份做一系列的创新。身份是一个非常复杂的事情，做得好很不容易。 我拒绝开发小程序应用，因为他太封闭了。 下面我们来详细讲一下基于 SoLiD 的开发范式转变以及 SoLiD 如何重塑互联网用户和互联网数据之间的关系。 SoLiD 的核心可以归纳为三点，第一点：你拥有你的数据。你可以自由决定你的数据存储到哪里以及怎么导出。这些数据，不限于你的通讯录，你的日程表，你的聊天数据，你喜欢的文章，你点赞的评论等等。这些数据都是归你所有的。你会有一个叫做 Pod 的东西，你可以将其理解为一种可编程的网盘，所有的应用程序读写都会在你的网盘里进行。在 A 应用中存储的数据，B 应用也可以访问，你不需要手动同步，因为这些数据会永远跟着你。 那么第二点，就是你控制你的数据。你可以决定你的数据有哪些服务商可以读写，以及什么时候不能读写。可以把这点理解成支付宝或者微信支付的免密支付。你可以授权滴滴打车之后自动扣款，你也可以将自动扣款能取消，你就将数据看成你的个人财产就好。 第三个就是使用 SoLiD 登录，也就是用户在 SoLiD 生态中唯一的身份。通过这个身份，你可以直接登录任意支持 SoLiD 的应用，并且可以将这个账号背后的数据授权给任何你想授权的应用。 以上三点就是 SoLiD 的核心价值。 如果要更好的理解 SoLiD，还需要理解四个核心概念。 我们知道，SoLiD 的英文全称是 Social Linked Data，所以我们需要理解什么是 Social，为什么 SoLiD 会有社交的想法？以及什么是 Linked Data，为什么数据需要互联？ 那么理解 SoLiD 之前，我们先理解下什么是 PoD，PoD 的全称是 Personal Online Data，也就是个人在线数据的意思，在 SoLiD 中就是存储数据的地方，你可以将 PoD 理解为一个个人网盘。 那么这个个人网盘可以存储任何东西，结构化的，非结构化的，都可以存储。什么叫结构化的，比如，我喜欢的文章，我点赞的朋友圈，我的好友关系，这些都是结构化的。那么非结构化的，就是我的图片、我的笔记等等。 所有应用的数据读写，都是在每个用户的 PoD 中进行，同时每个人都有一个 WebID，这个 WebID 后面关联着你的所有数据。 WebID 也是一个规范，这里就不展开了，展开的话就没完没了，大家可以简单把他理解为一个唯一性 ID。 那么第二个需要理解的，就是本体。前面我也简单的介绍了一下。这里我再稍微提一点。大家看上面的图，首先看我们这个蝙蝠侠，他有头罩，有披风，还有腰带、鞋子等等。那么这些名词，都叫做本体，本体定义了头罩只能叫头罩，而不能叫帽子。再看海绵宝宝，他有皮肤，有眼珠有裤子有斑点，大家还可以看到斑点在皮肤上，那么在这种关系也叫做本体。除了在这种关系，还有像拥有啦，上面啦等等。最右边的呢，是达尔文 core，他是一个植物的本体，植物的本体是有限的一个集合，所以很多人拿它来做研究。 第三个，就是 SoLiD 全称中的 Social 的含义。我们都知道，微信的用户是没有办法和 QQ 的通讯录统一的，你需要重复添加，那么 SoLiD 就定义了一种开放的社交关系图谱，叫做 FOAF，全称是 Friend of a friend，也就是朋友的朋友。比如我认识 A，A 认识 B，那么我就有可能会认识 B。这也是一种三元组的关系集合。大家经常用的企查查其实就是一种 FOAF。SoLiD 是一个以用户和个体为中心的一个生态，所以其必不可少的描述了一种社交关系。FOAF 也是 W3C 的一个标准，他描述了社交关系里的所有本体，SoLiD 直接拿来用了。 了解完社交之后，我们再看最后一个点，Linked Data。大家这么来看 Linked Data 就很好理解。刚才说的 FOAF 是用来描述人的，那么人背后需要的数据，就是通过 Linked Data 来描述的。Linked Data 是语义网技术的一个集合，所谓 RDF、OWL 等一系列变体。 SoLiD 带来的东西除了刚才讲的核心价值之外，还有有开发范式的变化。在以前，我们开发一个应用需要自己搭数据库，运维服务器，然后做用户系统，再将用户 ID 与数据关联。有了 SoLiD 之后，这些全都不用做了，SoLiD 会变成互联网上缺失的身份层和数据传输存储层。 首先第一点，就是数据存储方式的变化。大家可以看到右边的这张图，这张图是假设一个人在阅读一篇文章，那么在阅读这篇文章的时候，这篇文章的标题、作者、头像以及内容，不是从一个中心化服务器中读取的，而是从这个作者的 PoD 中读取的。同时，当我喜欢这篇文章，并且点了个赞的时候，这个点赞的记录是存在我自己的 POD 里面的，这就是与传统软件开发最根本的区别。 讲完数据写入之后，我们来看一下数据读取。还是看这张图，左边是 Facebook、Linkedin 这种数据和应用紧耦合的关系，右边是 SoLiD 架构下的结构图，大家可以清晰的看到，不管是图片管理软件，还是社交应用的 feed 流，还是日程管理软件，都是从用户自己的 PoD 中去读取的。 这就是 SoLiD 带来的，数据读取和写入的这样一个变化。 那么最后一个范式的变化就是创新者入局的变化。因为 SoLiD 带来的数据确权，使数据可以重复利用，在 A 应用上生产的数据，在 B 应用上也可以使用，应用间可以无缝互联，这让数据不再是创新壁垒，壁垒在于谁能够提供更好的服务以及谁能够取得用户的信任。 任何一家初创公司都可以快速重复利用现有非隐私数据时，我相信市场的创新活力会有更大的激发。 SoLiD 给我们带来的，不仅是一个开源软件，也不仅仅是一个在此开源软件上进行商业化的公司，而是一个通用的生态，生态里的应用都遵循着同样的范式。同时也是一场革命，这场革命不仅带来了全新的应用开发范式，还将从根本上解决用户数据的所有权问题。 搭建 SoLiD 的服务器非常容易，SoLiD 的服务器主要承担着 SoLiD Pod 的托管作用和一个 HTTP Server 的作用，此 HTTP Server 基于 RESTful 对外提供服务。大家可以把 SoLiD 服务器想象成一个能聚合全球计算能力的 Linux 计算机，这台计算机的计算能力由浏览器承担，数据库能力由整个 Web 承担，聚合查询的时候使用 SPARQL 或 GraphQL 进行查询。如果想要写入文件等非结构化数据，只需要使用符合 RESTful 规范的 POST、PUT、GET 等请求方式进行请求就可以执行创建文件夹、增加文件、删除文件、修改文件等操作。 同时 SoLiD 还有 WAC（Web Access Control） 这样一个控制权限的协议，可以进行粒度很细的权限分配操作，其控制的粒度和 Linux 一样细。 基于 SoLiD 的应用，不是说数据在硬件层面被用户所控制，而是从逻辑角度来看，是由用户控制的。这个意思就是说，SoLiD 服务器不是一定要放到用户自己家里，他可能还在云上，或者其他免费的社区版本。 下面再谈一谈 SoLiD 的设计原则，主要就是五个原则：Open、Transparent、Accountable、Sovereign 和 User Centric。SoLiD 是开源的，其不受任何政府、组织控制；SoLiD 整个研发流程是透明的，每个人都可以 Reivew 所有的 Pull Request 和代码；SoLiD 是负责任的，其平台设计的目的就是让用户拥有自己的数据，平台本身并不拥有；SoLiD 是为了主权所设计的，赋能用户的优先级永远是最高的；SoLiD 也是以用户为中心的，它的整个生态从开始设计时就是以隐私为核心。 聊完了 SoLiD 的一些基础后，我们再从开发者角度看看 SoLiD 整个项目的易用性。使用 SoLiD 开发后，应用从只有一个后端变成拥有多个后端。 在传统的中心化模型中，App 有一个后端，从一个后端中读取多个数据。但在 SoLiD 这种去中心化的模型中，应用 X 和应用 Y 从不同的 Data Pod 中读写数据，每一个 Pod 中都存着不同人的数据，同时 Pod 与 Pod 之间还可以做很多交互。 假如有很多 Pod，那么就会产生 Pod 的互操作性问题，比如如何在多个不同的 Pod 之间做联合查询。在传统的数据库模型中，可以用 Join 等关键词在不同的表中做联合查询，那么 Pod 之间的联合查询，也同样可以做到，只不过 Pod 之间的查询是基于网络的，而不是在内存中。 SoLiD 使用 JSON-LD 来对不同的数据片段进行互联。 JSON-LD 是一种简化的 RDF 表示语言，以下是 JSON-LD 和 Turtle 的区别： 可以看到，JSON-LD 比 Turtle 简单易懂的多。 以上就是 SoLiD 开发体验的介绍，总结下来就是一句话：「从学术化到工程化」。 聊完开发者体验，我们再来看一看数据民主之路的必然趋势。我们认为互联网是人类社会发展的一个缩影，数据民主是必由之路。我们先看人类社会的一个发展，从一开始的采集社会，人类产生了各个部族群落，此时相对于个人博客和网站的开垦期；再到农业革命，产生了帝国番邦，对应了如今美国的 FLAG、中国的 BATTMD；后来，人类发生了工业革命，这是一场影响深远的革命，不仅改善了人类的生活条件，还产生了一些其他政治上的影响。而如今，互联网的生产力还远远未得到释放，云计算、AI 和区块链都还处于一个很早期的阶段，如果到了某一天，AI 的机器智能大幅提高，能够辅助人类做决策之时，就是互联网数据主权革命将要开始的时候。因为那时，你的数据就是你的思想，就是你的生命，你自然是不想让任何人来控制你身体的某一部分。 最后，我们聊一聊 SoLiD 可能带来的几个大的商业机会。 第一个机会就是身份提供商，身份是一个从计算机存在以来就有的问题，大家可能觉得他被解决的很好了，其实没有被解决好。现在无论是互联网还是工业互联网，抑或是企业内部的环境，所有的身份实现都是不标准的，混乱的，这种混乱每年带来数百亿人民币的浪费。如果谁能推动身份标准化同时能有成熟的产品推向市场，这是一个巨大的机会。为什么要切中身份？因为在 SoLiD 里，所有事情都是围绕身份来的，只有身份这个基础设施做好了，才有后面的一切。 第二个机会是「个人数据管理平台」。那么什么是「个人数据管理平台」呢，这个也很容易理解，既然你的所有数据都存在 POD 中，那么肯定需要一个集中化的软件来做所有结构化数据和非结构化数据的管理和控制，这种软件的开发难度是非常大的，因为要兼容所有数据类型，你可以把他理解为更普适化的 Excel。这里我要介绍一类产品，我们叫他模块化生产力软件。模块化生产力软件最重要的一个特点是「用文档来表示所有信息」。说到文档，你们最先想到什么？是 Word 对吧。事实上，计算机文档的结构从上世纪 70 年代到现在都没有任何变化。但是世界上的所有其他软件都发生了变化，不管是手机还是电脑。 换句话说，模块化生产力软件将有可能颠覆 Office 的竞争格局。 另外一个就是为什么我们要用文档来表示所有信息，因为世界上所有的软件内部的信息组成都是文档。人类历史的开端就是人类学会了在石头上写文档。计算机出现后，人类进入了电子文档时代，这让知识开始在全球范围内快速传播。即使是微信的聊天框、微博的 feed 流，或者是抖音的视频，都是文档的一种表现形式。 另外一个关键词是「模块化」，为什么要叫他模块化呢？这里我要引入一个新概念，叫做「文档即应用」，就是你所写的文档，将会变成一个可执行的应用，你可以任意修改任何应用的任意信息和界面布局。 那么当这类软件成熟起来之后，将可以用来管理 SoLiD 里面所有的个人数据。目前这类软件我最看好的是 coda. io coda. io。他为什么好？我也举个简单的例子，大家都知道 Excel 严格意义上来讲可以做任何事情，那么为什么还会有 odoo 这类 erp 软件或者 salesforce 这类 crm 软件出来呢？很简单，因为企业的业务流程，用 excel 很难实现一个用户体验良好的自动化，这类软件的意义就在于将流程自动化出来。但是他们本身的数据控制没有 excel 那么自由。coda，就是将 excel 对数据的控制自由和业务流程的自定义自由很好的结合了起来。 我写过一篇文章，叫 「文档将重塑全球生产力」，在微信公众号和搜狗上都能搜到，这篇文章有更多关于模块化生产力软件的介绍，大家有兴趣的话可以搜索看一看。 那么最后一个，就是「以身份为中心的计算平台」。怎么理解呢？就是做一个操作系统，但是这个操作系统不再以管理计算机资源为中心，而是以用户和服务为中心。 可以简单理解为在这个操作系统内有一个 ID，然后可以登录操作系统内 App Store 的所有应用程序，同时这些应用程序之间的数据都是可以互联的，这时候才会产生真正的个人助理，这才是真正的互联网。 做这么一个计算平台本身，难度不大。真正的难度在于如何推广出去。首先，我们都十分确定这绝对是未来的一个发展趋势，那么是现在做还是将来做？是我们做还是其他人做，这是非常值得思考的一个问题。 我们能想到的一些 Marketing 策略就是首先针对三大运营商的高端人群，同时对隐私十分关注的一群人，卖下一代黑莓手机，这些资源是我们目前能接触到的资源。有了这种下一代黑莓手机，那么无论是像 maskbook 这种应用还是其他的区块链类隐私应用，才有推向市场的可能性。  本文整理自蒸汽记忆创始人谢扬在 2019 年 11 月 16 日在成都 Web 全栈大会上的演讲，内容有删改。完整 PPT 可从 Github 上查看：https://leinue. github. io/webfullstack-2019/index. html "
    }, {
    "id": 30,
    "url": "/blog/%E8%BA%AB%E4%BB%BD%E4%B8%8A%E4%BA%91-or-%E8%87%AA%E5%BB%BA-%E8%BF%99%E9%87%8C%E6%9C%89-20-%E4%B8%AA%E9%97%AE%E9%A2%98%E5%80%BC%E5%BE%97%E4%BD%A0%E6%80%9D%E8%80%83/",
    "title": "身份上云 or 自建？这里有 20 个问题值得你思考",
    "body": "2019/10/27 - 身份管理自从计算机问世以来就存在，很多人觉得身份管理很简单，其实难度远超你的想象。 一、为什么要自建身份管理？: 自计算机问世以来，身份管理一直是软件的主要组成部分：打孔机和早期操作系统都受到用户名/密码身份验认证的保护。拥有如此悠久的历史，你会认为身份管理是一个已经被妥善解决的问题。 自建身份管理一般在以下场景有充足的理由：  你正在做一些简单的事情：没有敏感信息或隐私问题，并且你的安全性要求不高，你的用户数量不多，同时用户类型比较单一，只有几个应用程序； 你是一位经验丰富的开发人员，并且在顶尖团队中工作，多年来一直为应用程序，网站，API 和服务构建身份认证； 某天你的预算减少了，这时你必须选择一些方案来为组织的大战略省钱；坦白说，如果你只有一个简单的 Web 应用，只需要一两个社交应用提供一键登录，并且不需要「用户名 - 密码」或其他更细致的用来登录的功能，那么自建就很容易。你可以在 Github 上找到大量开源框架来解决此类问题。 二、为什么要购买身份管理服务？: 我们经常听到客户的研发团队这么评价 Authing：  我们自己就能做，为什么要用你们的，而且还要付钱？ 接下来让我们深入研究这个问题。 1、专业的人做专业的事: 实现一套身份管理看上去似乎很简单。但是失败是很可怕的，一旦出现了问题，你的品牌就会受到严重损害。面对持续的黑客攻击，和无休止的漏洞，你是否能准确知道自己的工作足够好到可以保护用户隐私和企业资产？ 2、投入产出比: 自建身份管理并不是免费的！将资源到投入身份管理研发时会产生高昂的的机会成本。身份认证真的是你想要做的吗？假如你做一款应用，会自己写一套 RDBMS(关系数据库管理系统) 吗？身份管理就像 RDBMS，当你可以花合理的钱将非核心的繁重工作委派给专业人士时，为什么还要自建身份管理等基础设施呢？身份泄漏产生的成本可能高达数百万美元，你能否认身份安全没有价值吗？在评估购买身份管理服务的投资回报率时，请考虑这些因素。 3、复杂性: 你的产品在前期肯定是简单的，但是，一旦你的产品成功推向市场，你开始需要支持更广泛的身份提供商。你可能还有合作伙伴，你可能还会推出移动 APP 和 API 让其他人调用，这样你的受众群体才能扩大。如果你在欧洲，你还会面临 GDPR 的监管（中国也即将出台相关法律）。这时身份管理开始变的复杂，维护自己的身份管理系统成本会比你预期要高的多。 4、测验: 上面的几个问题可能已经引发了你的思考。有些你可能不在意，有些你可能在工作中已经遇到。但是，我们邀请你根据目前的状态和未来几个月或几年的发展方向回答以下 20 个问题并切实考虑它们。 1）用户相关的问题:  你是否考虑过如何实现「用户管理」？是自助管理还是集中管理？用户体验会是什么样？ 你有用户使用多个「身份提供商」登录你的应用吗？你如何判定他们是一个人？ 你是否有多个服务或软件需要认证？如果有，他们使用了同一个技术栈还是多个技术栈？（不同的技术栈会加大研发成本） 你是否需要统计信息来查看用户的增长情况、设备情况、IP 地理位置和认证情况？如果需要，你计划如何收集、分析和可视化这些数据？ 你如何记录并解决用户身份认证过程中出现的异常事件（忘记密码、无法登录、认证失败、过期等）？2）应用服务相关的问题:  你如何在漏洞被曝出之前及时发现漏洞？发现漏洞后如何通过补丁快速修复漏洞？ 你如何处理在不同「身份提供商」之间认证时产生的「标准不兼容」问题？当这些身份提供商之间都使用了不同的技术栈之后，你将作何处理？ 你的 DevOps 团队能否在开发身份认证基础设施上保持专业、领先地位和最佳实践？ 你有 MFA（多因素认证）策略吗？你打算怎么跨平台的实现 MFA？你是否希望你的用户能在 iOS 或 Android 设备上使用 FaceID 或指纹来进行身份认证？ 你是否考虑过用户存储的可伸缩性、性能、查询和可用性要求？在流量过大的情况下你如何保证登录系统的 99. 999% 可用？3）身份提供商（IDP）相关的问题:  你在迁移老应用进更现代的身份管理系统时，如何让用户不重置密码无缝迁移？ 你的一个 B2B 客户需要 SSO，你可以在内网中或防火墙后面与 Active Directory 做联合认证吗？ 不同的 SAML IdP 有多种格式存储和传递声明 —— 你是否有一种简单的方法让声明完全自定义化？ OpenID Connect 是流行的身份认证新标准：基于 REST / JSON 和 OAuth 2. 0。但是其魔鬼般的实施细节，你计划如何在不同的后端语言和客户端之间实现它？4）安全与合规问题:  身份系统是黑客攻击的首要目标。你是否考虑过实施暴力保护？比如 API 网关上的 DDoS 预防和缓解？ 你是否打算让第三方安全顾问来进行独立的渗透测试，代码审查和体系结构审查以验证安全性和最佳实践？ 在身份实施过程中产生的安全漏洞报告你计划如何解决？ 你是否需要上下文逐步身份认证（Contextual Step-up Authentication）？例如 IP 白名单或 Active Directory 成员身份？你是否需要多种密码加密算法？无密码身份认证对你的用户是否有效或存在意义？5）时间与成本问题:  你需要雇佣多少人，包括 IT，研发人员和外包服务（例如咨询专业知识）？这些人很难找到，雇用起来也很昂贵。你将从何处获得这些人才，费用是多少？ 你预计的上线日期是什么时候？你的 IAM 解决方案需要多少时间和多少次迭代？ Forrester Consulting 的研究报告指出，使用身份管理服务可以产生 548％ 的投资回报率和 370 万美元的费用节省。 使用 Authing 可以一劳永逸的解决上述 20 个问题，任何想做计算机软件的企业或个人，只需要接入 Authing 的云服务，就可以以极低的成本，快速解决那些需要耗费数百万元人民币才能解决的问题。身份的复杂性和混乱性，造成了每年数十亿的浪费，因为其表面的简单，导致了缺乏系统的标准，每家厂商都会自己搞一套自己的标准，这些混乱的标准既养活了一群人，也加重了这群人的开发负担。 身份这件事，听上去是老故事，看上去很简单，但其从未得到很好的解决，这就是 Authing 存在的意义。 "
    }, {
    "id": 31,
    "url": "/blog/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%89%80%E6%9C%89%E8%BD%AF%E4%BB%B6%E9%83%BD%E5%BA%94%E8%AF%A5%E4%BD%BF%E7%94%A8%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%E6%9D%A5%E7%AE%A1%E7%90%86%E7%94%A8%E6%88%B7/",
    "title": "为什么所有软件都应该使用单点登录来管理用户？",
    "body": "2019/10/25 - 单点登录（Single Sign On），简称为 SSO，是目前比较流行的企业业务整合的解决方案之一。SSO 的定义是在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统。 一、什么是单点登录？: 单点登录（Single Sign On），简称为 SSO，是目前比较流行的企业业务整合的解决方案之一。SSO 的定义是在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统。 二、使用 SSO 带来的「业务优势」: 1）提高用户的效率: 用户不再被多次登录困扰，也不需要记住多个 ID 和密码。另外，用户忘记密码并求助于支持人员的情况也会减少。 2）提高开发人员的效率: SSO 为开发人员提供了一个通用的身份验证框架。实际上，如果 SSO 机制是独立的，那么开发人员就完全不需要为身份验证操心。他们可以假设，只要对应用程序的请求附带一个用户名，身份验证就已经完成了。 3）简化管理: 如果应用程序加入了单点登录协议，管理用户帐号的负担就会减轻。简化的程度取决于应用程序，因为 SSO 只处理身份验证。所以，应用程序可能仍然需要设置用户的属性（比如访问特权）。 这些都属于业务上的优势，除了业务上的优势外，还有软件架构层面的优势。 三、使用 SSO 带来的「软件架构层面的优势」: 1）向下兼容: 单点登录是一种比普通的账号密码登录更加规范化的解决方案，如果有一天你的业务扩大，想要聚合所有平台的用户，那么提前用上了单点登录的你会使整个过程变得非常容易。有太多前期的用户系统做的很不规范，系统壮大后需要投入大量人力物力来进行迁移的案例出现。造成软件前期不使用单点登录的主要原因是单点登录的复杂性，如果单点登录的复杂性和实施成本能被降低，那么我相信很多人都愿意直接使用。 再类比一下，使用单点登录对你的系统向下兼容就好像 C++ 可以兼容 C 语言一样，你在用 C++ 时，使用面向对象编程的同时，不会耽误你面向过程编程。相反，如果你使用了 C 语言，在理论上你当然也可以面向对象编程，只不过过程过于复杂，异常痛苦，甚至不符合 C 语言的设计思想。为什么要将不合适的东西强行扭成合适的呢？这就是单点登录相较于普通登录方式最本质的区别。 教科书为了让你快速上手，所以选择 C 语言开始；PHP 为了让你快速上手，选择让你学习最简单的单向「用户名 - 密码」登录开始。但是我们都知道，软件最好从一开始就使用面向对象编程，那么任何的互联网应用，从一开始就使用「单点登录」也是同样的道理。 2）简化迁移迁出流程: 假设你的软件从一开始就没有考虑过使用单点登录，那么当你的业务拓展成功并且有多个平台后，多平台用户的 Merge 就会变成很大的一个难点，比如如何确定注册到 A 平台的邮箱和 B 平台的邮箱是同一个、用户的密码如何重置、如何确定 Merge 完成后的用户信息没有任何损失等等。 如果你从一开始就使用了单点登录，那么这些问题都将不复存在。将用户从平台中迁移出来将像导出 Excel 到 CSV 一样简单。 3）强化管理和安全流程: 进行身份认证的目的是为了授权用户可访问哪些资源，单点登录都有十分规范化的权限授权系统，RBAC 是业内比较认可的授权管理方案。单点登录系统一般都自带开发者友好和组织友好的 RBAC 方案，可以让开发者快速实现中心化授权体系。 除此之外，用户的历史活动为判定可信度提供了丰富的分析素材。系统可以通过挖掘用户的历史操作构建其行为基线，然后通过比较当前操作和其行为基线来计算用户的信任评分。 通过比较当前用户的地理位置坐标可以发现是否有异常，比如一个用户的设备在一个较小的时间窗口内突然出现在某个用户不可能达到的坐标；再比如用户有多个设备，但其报告了不一样的地理位置。但是必须注意，地理位置是存在偏差的，所以地理位置的权重不应该过高，而是作为一种参考。 成熟的单点登录系统都会提供这些功能，除此之外还有可定制的加密算法、用户密码泄漏检测等多维化功能，保障整个系统的管理安全和流程安全。 四、如何低成本的实现单点登录 ？: 前面我们讲了为什么所有软件都应该使用单点登录来管理用户，那么如何最低成本的实现单点登录呢？这里就要介绍下 Authing 了。 Authing 是一款身份认证云，提供了开发者优先和极易拓展的开发平台，简化了身份管理的流程，使用 Authing 可以用极短的时间和极低的成本实现单点登录（用户量数十万的应用从迁移进 Authing 到上线到生产环境只需要两天），如果你对此感兴趣，可以查看这篇文章：用 Authing 10 分钟实现单点登录。 最后，希望这篇文章能对你的下一次软件开发有帮助～ "
    }, {
    "id": 32,
    "url": "/blog/%E5%B0%86%E5%86%85%E5%AE%B9%E7%9C%8B%E4%BD%9C%E6%96%B0%E7%9A%84%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BDCaaS/",
    "title": "将内容看作新的基础设施：Content as a Service",
    "body": "2019/10/15 - 内容是每家企业的必争之地，根据 CMI 的数据报告，88% 的 B2B 企业每天至少产生一篇内容。内容正在成为新的基础设施，Content as a Service 可以被简单理解为一种 CMS（Content Management Systen，内容管理系统），但是和传统的 CMS （如 Wordpress、Drupal 等）完全不同。传统 CMS 聚焦于内容管理和创建网站（比如 Wordpress 提供的大量网站模版），而 CaaS 只聚焦于内容的生产，并以 API （应用程序编程接口）的形式向外提供服务，这些 API 可被二次编程，从而用于打印机、移动应用或者其他设备上。 在这篇文章中，你将了解到什么是 CaaS 以及为什么内容是一种新的基础设施。在你想要使用 CaaS 时，本文可作为对比 CMS 和 CaaS 优劣的参考文章。我们还会罗列一些 CaaS 的使用场景，帮助你更好的了解 CaaS。 内容是新的基础设施: 互联网上的所有应用都是信息管理软件，这些软件在本质上是由一张张互相联系的表组成的（如果你不理解这句话，那么你可以将一个网站想象成三张 Excel 表，一张表存储网站用户，一张表存储网站内容，还有一张表存储网站分类）。当你使用一个传统 CMS 时，你可以创建一些分类，并在分类上面撰写文章，这样的操作在网站时代是比较友好的，因为每个用户都只有一个平台 —— 那就是浏览器，这种方式在浏览器上分发非常容易。 进入移动时代后就不一样了，一家公司至少拥有三个平台（Web、iOS、Android），针对这些平台，每家企业都需要定制自己的 CMS，他们可能是在 Wordpress 上做深度定制，也可能是自己开发。做的多了之后，大家会发现，每家公司都在做同样的事情 —— 写管理界面、建表、写 API，这些界面可能是与公司业务高度结合的，比如头条 APP 的后台与微信公众号的后台肯定是不一样的。但细细研究却会发现，其本质就是五个事情：增删改查和联表。 于是有人做了一种名为「Headless CMS」的平台出来，这种平台可以在线设计表和表的字段（和 想象下 Excel 的建表，写字段，但是用起来要比 Excel 简单很多），然后系统会根据设计好的表和字段自动生成立马可以使用的 API，这些 API 符合一种名为 RESTful 的规范，这种规范是开发者们共同遵守的一种规范，只要看到这个规范，开发者就知道该如何使用这些 API。知道如何使用之后，开发者就可以将这些内容用于实际的应用中（也就是展示给终端用户看），可能是抖音，也可能是微博（这些本质上都是信息管理软件）。 这么做带来的好处是，假如一款产品上线后，产品经理想要新上一个「用户反馈功能」，在没有 Headless CMS 的时候需要开发者在数据库中建一个新的表，然后用一上午的时间调通 API 和图片上传功能，最后再做个界面。有了 Headless CMS 之后就不得了了，产品经理想要用户反馈什么内容直接在后台建好字段，然后 API 就自动生成了，开发者省去了建表、建字段、调 API 的时间，直接进入界面开发了。如果产品经理想修改需求，自己就能直接改，这样不但大幅提升了工作效率，还减少了很多产品经理与程序员之间由于需求变更带来的巨大摩擦，因此世界更加美好了。 这类 Headless CMS 正在开发者圈子中流行开来，开发者开始主动将这类软件用于公司业务中。Headless CMS 翻译成中文就是无头 CMS，简单来说就是不管界面生成的 CMS，他使用了一种名为「RESTful API」的规范对外提供服务，开发者根据这套规范可以做任何应用。 一旦标准化，就会变成基础设施，内容正在这条路上。 什么是 CaaS: CaaS 是内容基础设施的云上版本，他提供云上的 Headless CMS，并提供公网可用的 API 让开发者可以直接使用，开发者省去了部署运维的精力开销。除此之外，其还有 Headless CMS 不具备的高性能高可用优势。大部分 Headless CMS 是开源的，只能处理百万级别的数据，对于千万或亿级的数据，仍需要做不少优化工作，而 CaaS 将这些也省去了，这就是云计算的好处，标准化一切可以标准化的东西。 企业对于 CaaS 的担忧主要还是安全和隐私问题，也就是大家经常听到的对云计算的质疑 —— 「凭什么我把数据、代码和业务给你还要给你钱」。 对于中国的企业来说可能还有合规问题。如果在中国做 CaaS，必须投入大量资金和人力到内容审查上。 如果一个 CaaS 能做到垄断做成寡头，那么未来的一个最大的可能就是开放版的微信公众号。通过其 CaaS 平台分发出去的内容不仅有社会大众的娱乐内容，还有很多专业知识，而所有这些内容都是开放可检索的 —— 如果说中国互联网最大的遗憾是什么，那就是大量优质内容无法通过搜索引擎检索，中国只是个互闭网。 CaaS 相比 CMS 的优势: CaaS 相比 CMS 有非常多的优势。  结构化的内容。CaaS 可以让内容管理者从「管理页面」的思维转向「管理内容」，这将让我们互联网上的内容变得更加专业和优质。 代码结构优化。传统 CMS 的内容和界面都是耦合十分严重的，像 Wordpress 使用了非常多的自定义指令去表示网页内的信息，从开发者的角度来说，这点是无法忍受的。CaaS 允许内容代码和界面彻底分离，这对开发效率来说会有更大幅的提升，并且符合现代开发框架。 内容和展示分离。传统 CMS 由于其界面布局等原因会制约内容的发展，有了 CaaS 之后作者只用关心内容而不必关心界面设计，只需要生产优质内容。 云原生应用。CaaS 是一种云原生应用，也是 SaaS 的一种，云服务提供商会为你安装、维护和做自动伸缩、性能优化等工作，你需要做的只是将内容迁移到 CaaS 和使用。 个性化。使用 CaaS 可以随心所欲的定义你想要的表和字段，并且有可以立即投入生产环境的接口使用。这在做一些 A/B 测时会非常有用，因为所有的修改都不需要改动底层的数据库或代码结构。CaaS 的使用场景: 总的来说，CaaS 的主要特性就是自由和灵活，以下是依据这些特性的典型使用场景（其实 CaaS 的应用场景非常广泛，几乎所有信息系统都可以用 CaaS 完成，以下只是抛砖引玉）：  多渠道分发。这里的多渠道分发主要是指分发到不同的内容平台上，可能是三端相同的应用，也可能是三端不同的应用。通过 CaaS 的开放 API 特性，作者只需要写一次，就可以重用这些内容，并分发给所有兼容了这些 API 的网站。 移动应用内容分发。很多移动应用都直接内嵌网页来展示内容，而 CaaS 的 API 允许移动应用在很方便的进行内容展示（传统的 CMS 没有结构化的 API 可用）。 移动应用后端。移动应用本质上也是信息管理软件，使用 CaaS 管理移动应用的业务逻辑是个不错的解决方案，CaaS 是个成熟的方案，比自己写要容易且稳定很多。 与身份认证云配套使用。使用身份认证云（如 Authing. cn）的用户往往有自定义字段和内容管理的需求，这些在业务层面的功能身份认证云是不提供的，那么 CaaS 便成为了拓展这些字段的一个良好补充。我们所知道的案例是，将 Authing. cn 配置进 Strapi(一款 CaaS 产品)，登录 Strapi 时使用 Authing 登录，然后携带 Authing 的 Token 访问 Strapi 的资源并进行授权认证。 个人博客。与传统 CMS 一样，CaaS 也可以作博客，不过需要创作者懂一些编程能力。如果懂编程，CaaS 是个更容易实现个人博客的方案。一个优秀 CaaS 应该具有的功能特性: 作者角度:  体验良好的编辑器。有类似石墨文档或 Notion 的文档编辑体验，让作者尽可能舒适的创作内容。 简单符合直觉的建表及字段配置。让内容创作者可以很容易管理、修改和与团队协作。开发者角度:  支持 CRUD 的自动生成并符合 RESTful 规范。 支持每个 API 逻辑的增加和修改。 开发者可以很方便的无限制的拓展 API 的业务逻辑。 支持拓展计算能力。 支持函数计算，让开发者可以无限制的拓展平台能力。 支持数据的授权以及标准认真协议（OAuth 2. 0 或 OIDC）。 能基于 RBAC 或 WAC 对数据进行细粒度授权，同时支持 OAuth 2. 0 或 OIDC 协议，能兼容各类身份提供商的登录认证，并能使用身份提供商的 Token 授权资源访问。 高可用高性能。 低时延，快速响应以及完善的日志记录和错误监控。如何开始使用 CaaS:  如果你是 JavaScript 开发者，我们建议到 Github 上搜索 Strapi 使用； 如果你是其他语言开发者，请到 Google 上搜索 Headless CMS 寻找你想要的语言使用； 如果你是非工程人员，请到 Google 上搜索 Content as a Service 找到最适合你的在线 CaaS 使用。"
    }, {
    "id": 33,
    "url": "/blog/%E5%87%BD%E6%95%B0%E8%AE%A1%E7%AE%97%E5%9C%A8%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81%E4%BA%91%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/",
    "title": "函数计算在身份认证云中的应用场景",
    "body": "2019/08/16 - Authing 用来做用户验证，函数计算用来处理具体的逻辑，非常完美的搭配。 越来越多的企业接受身份认证上云后，Authing 也承接了越来越多「用户迁移」需求，在用户迁移的过程中，最重要的一点是「终端用户必须无感知」，而无感知主要有以下两点要求：  用户不需要修改密码； 完成切换后，用户的所有数据都能正常访问且具备相应的访问权限；在一个用户系统中，用户的密码通常情况下都会加密存储在数据库中，这个加密算法一般是不可逆的，同时可以由一个函数完成，因此将函数计算应用在身份认证云中就能满足第一个要求。 首先我们看一下什么是函数计算：  通过函数计算，您无需管理服务器等基础设施，只需编写代码并上传。函数计算会为您准备好计算资源，以弹性、可靠的方式运行您的代码，并提供日志查询、性能监控、报警等功能。借助于函数计算，您可以快速构建任何类型的应用和服务，无需管理和运维。而且，您只需要为代码实际运行所消耗的资源付费，代码未运行则不产生费用。阿里云 - 函数计算简单来说，函数计算让程序员不需要再管理服务器，只需要上传代码，后台的云就可以帮你自动按需分配资源，这将极大释放程序员的生产力。 函数计算非常适合解决身份认证云中自定义密码加密的问题，以下是应用了函数计算后，用户注册的流程图： 以下是用户登录的流程图： 以上流程图是一个简化版，只展示了几个比较核心的步骤。 从开发者的角度来说，我们希望开发者只需要上传一个 index. js 文件就可以自定义密码的加密方式。如果开发者需要引入第三方包，那么仅需要将引入的 node_modules 打包为 . zip 上传即可。上传完成后，Authing 会取得一个可通过 HTTP 调用的网址，此网址不会公布给任何第三方，同时每个网址都会有独特的验证方式，最大限度的保证安全。 在 Authing 控制台中依次点击基础配置 -&gt; 密码管理即可自定义密码加密方法 其他场景除了自定义密码加密外，函数计算可以很好的和 Authing 配合，帮助开发者在后端十分容易的完成用户 Token 的验证。此外，在实际场景下，若开发者接受全部上云，完全可以基于 Authing + 函数计算完成所有业务流程：Authing 用来做用户验证，函数计算用来处理具体的逻辑，非常完美的搭配。 "
    }, {
    "id": 34,
    "url": "/blog/%E8%B5%B0%E8%BF%9B%E8%BA%AB%E4%BB%BD%E7%AE%A1%E7%90%86/",
    "title": "走进身份管理",
    "body": "2019/06/09 - IAM/IDaaS（身份访问管理/身份认证即服务），通常代表一个服务或平台，该平台可通过用户角色或权限控制，识别个体身份，进而控制其对系统资源的访问，守护个体和组织的数据。 身份管理对于企业安全很重要，通过统一登录系统可显著提高企业效率，主要从以下两个层面：  用户不需要记忆和维护不同的用户名密码； 保护公司及其用户免受数据泄露风险；据一份 2015 年市场调研数据，数据泄露的造成的损失成本，平均为 3000 万元人民币。通过多因素身份认证、弱密码监测、大数据分析等安全技术，一个优秀的身份管理系统可以提供非常安全的的对这些资源的保护，同时还可以促进企业数据共享，提升企业效率。 身份管理解决方案可以为所有类型的企业带来显著价值。除此之外，还可以提供 B2B、B2C、B2E、IoT 不同场景下的特殊用例。  B2B：企业之间提供联合身份管理，例如允许企业使用其现有用户系统，无缝对接采购的第三方 SaaS 应用，对接供应链上下游的合作伙伴业务系统。 B2C：企业通过微信、微博、QQ、163、Github 等为消费者提供社交认证 （或其他更多第三方身份提供商）。 B2E：企业为其员工提供单点登录，简化管理，杜绝隐患； IoT：物联网设备之间的互联互通；数字环境的发展和变化异常迅速，个人智能手机和平板电脑无处不在，越来越多企业已经逐渐走向数字化和云计算。 随着数字化和云计算的进程，企业信息安全的维度和边界，越来越立体，越来越复杂，从时间上，也不再是 8 小时的，而是 7*24 全年 365 天不停止服务，同时也不再有物理地点的限制。企业的需求是在各种设备、平台、场景下保护身份安全的同时又要使数据易于共享。 过去几年，身份管理概念，如多因素身份验证（MFA），无密码和单一来源验证在解决现代分布式环境的身份管理问题时，已经走到了时代前沿。 多因素身份验证利用单独的身份验证阶段来提供两个（或更多）登录步骤。无密码可以使用 SMS、邮件验证码、指纹识别、人脸识别等生物识别技术来验证用户身份。  推动 IAM/IDaaS 普及的一个趋势是基于云的应用程序（SaaS）越来越多。 云服务提供商比如阿里云和 Amazon Web Services（AWS），利用远程服务器来对用户提供计算能力和存储能力。而 IAM/IDaaS 是使用 SaaS 的重要组成部分。 IAM/IDaaS 对受限资源的访问限制，提供了监测和保障安全的方法。 推动 IAM 进入市场的另一个关键需求是用户需要能够从任何地方、任何设备中访问应用程序。 随着个人计算的扩展，企业需要为他们的用户提供安全的访问能力，以便在所有不同的登录环境下确认用户身份，保证业务数据安全。从自主开发 到 IDaaS 满足你的需求所有使用场景:  你需要基于标准的解决方案来完成身份证，例如 OpenID Connect，SAML，WS-Federation 或 OAuth； 你的用户可以通过各种身份提供商（如：微信、QQ）进行身份认证，但缺少平台或完整的服务来整合他们这些身份账户间的关联； 你的应用程序分布在不同的域，并要求用户在每个域上的登录，彼此独立； 你需要让最优秀的开发人员构建核心业务应用程序，而不是花时间在构建和维护身份管理和身份认证上； 你的公司遇到过任何类型的数据泄露，或者您担心数据泄露。 你被要求实现一个行业标准认证，而你从未考虑过这些问题，或有这方面的经验。B2B:  你的合作伙伴要求使用他们的企业用户登录您的系统。 - 你需要除了支持用户名/密码选项外，还支持企业级联合登陆，以及许多其他类型的身份认证程序（如 Active Directory、LDAP、SAML）。你不愿意将用户管理委派给 IT 服务部门。B2C:  你的主要用户数据来源于直接询问用户的表单或调查。 能够轻松提取有关你的用户的第三方数据，将有助于您更好地了解你的客户，进而通过销售和有针对性的营销来增加收入。 如果你向消费者销售产品，你没有提供简单的一键登陆，来支持不同的社交身份注册，意味着客户的流失。 在用户数量增加时，你面临着性能问题。B2E:  你需要为员工管理不同的授权和访问级别。 当员工加入或离开你的组织时，你需要能够轻松配置和取消用户访问权限。购买一个身份管理解决方案的商业考虑有许多令人信服的理由，选择购买身份管理解决方案，无论 B2B，B2C 或 B2E 场景。 一些原因如下： 所有用户场景:  降低成本：实施第三方身份管理解决方案非常简单，启用强大功能就像部署一台交换机一样简单。 成百上千有价值的开发时间可以重新聚焦在业务逻辑编写而不是花费时间构建身份认证系统。 很多用于身份系统安全性的测试时间可以用在核心应用程序的开发工作。集成和映射不同的身份来源，非常耗时而且痛苦。 通过 IAM 解决方案，这些工作已经提前完成，并为流行的开发堆栈提供 SDK，进一步减少集成所需的额外编码。 公司的研发团队可以专注于配置而不是通过开发和定制一套 IAM 软件解决这些问题。 提高安全性：使用第三方身份管理解决方案存储数据可增强安全性。IAM 解决方案遵循安全合规性策略和安全认证。 IAM 解决方案承担保护用户数据安全存储和传输的职责。 此外，IAM解决方案还提供统一认证，以避免用户因必须记住多个登录凭据，而重复使用相同密码的不良做法。B2B:  增加企业灵活性：身份管理解决方案提供强大的企业联合认证。支持各种企业连接，例如Microsoft Active Directory，LDAP，ADFS，SAML，第三方 Apps 等。还提供单点登录功能，解决了用户要记住其他用户名或密码的烦恼， 这提高了访问的便利性，从而减少客户流失。 减少销售或雇员入职周期：联合身份允许不同公司使用自己的用户系统或服务，同时确保满足安全要求。 这促进更快的销售循环和客户转化。无需向客户介绍新的，不熟悉的登录方式或让他们记住另一个密码。 他们可以使用其现有企业用户系统进行单点登录。（比如一个支持各种标准用户认证协议的 SaaS 软件商，和不支持的 SaaS 软件商，前者更有竞争力。）B2C:  增加消费者的转化率：通过为客户提供统一，用户友好的身份系统，无论任何浏览器或设备，都可以为终端用户提供跨所有应用程序一致，无差别的注册和登录体验。 身份管理解决方案可以收集有关用户在不同身份平台的更多数据。 从而公司可以利用这些数据来有效推动市场和销售机会。 IAM 解决方案提供直观的登录界面，以优化注册和登录，可以减少设计需求和营销资源。 支持不同第三方登陆方案，可以分散尽可能多的身份验证请求，从而保持应用的高性能和可用性。B2E:  单点登录（SSO）：IAM 解决方案提供单点登录，允许用户仅通过一次登陆，使用多个第三方系统。 无论是云还是本地应用程序，SSO 都允许用户登录一次，并访问任何应用程序，而不会第二次提示凭据。SSO可用于登陆企业内部的 ERP，CRM，OA，Office 365 等应用程序。 管理授权级别：身份管理解决方案提供了轻松的方法控制用户的不同访问级别。 当员工加入公司或晋升时，可以轻松在一处分配和更改不同应用的权限。企业也可以在员工离职时，轻松取消，撤销所有不同平台的访问权限。评估一个 IAM 解决方案的关键要点选择身份管理解决方案时，你应该仔细考虑几个因素：  部署方式：你的身份管理解决方案应该可以选择部署到云，或你自己的数据中心。 易于集成：使用 IAM 解决方案的众多优势之一是缩短开发时间。寻找能够提供多样 SDK，完善文档，配置和启用简单，强大 API 和功能的解决方案厂商。 支持多样身份提供方案：良好的身份管理解决方案应该支持几乎所有流行的身份来源。 这包括Microsoft Active Directory，ADFS，LDAP，Office 365，Apps 和 SAML 解决方案。 对于消费者，还包括对任何自定义数据库的支持，社交身份提供商（如微博、QQ、微信等）和无密码解决方案，如短信，电子邮件，和 Touch ID 等的支持。 可扩展性：你的业务会持续增长，因此你的身份管理也应该持续增长。 你的 IAM 应该允许你轻松自定义身份认证和授权方式。理想情况下，你应该能在控制面板中根据需要自定义产品，而无需联系支持人员或购买插件。 你的 IAM 解决方案还应该允许你扩展其功能，例如导入/导出用户数据，与其他应用程序轻松集成，授权或执行自定义脚本以扩展基本产品的功能。 一流的安全功能：你的 IAM 提供商应由国际安全专家进行评审，并遵守 SAML，OAuth，WS-Federation 等标准，以及 OpenID Connect，SOC2，HIPAA 等。检查重要功能以防范攻击威胁和数据泄漏，例如弱密码检测和防暴力破解。 易于迁移：应支持移入和移出身份管理解决方案而不受限制。确保供应商阻止将用户迁移出系统。该解决方案还应支持连接到你已使用的任何用户系统，并且不应该要求用户在迁移到新解决方案时手动重置其密码。 安全专家/客户服务的快速支持：你的 IAM 客户支持团队应该拥有一个专家团队随时准备每天 24 小时协助应对任何挑战。 该团队还应包括高级开发人员 ，以及在实施 IAM 解决方案方面拥有丰富的实践经验的工程师团队。总结总之，你选择的 IAM 解决方案应能将身份管理系统从风险点和业务障碍，转变为一个正向的，能够促进业务增长的重要功能。 使用 Authing，你可以在几天内实施 IAM，以及利用最简单，最全面，最现代化和可扩展的 IAM 解决方案，提升企业效率。 Authing 可以帮助你管理用户的身份。作为安全专家，我们构建了一个身份即服务（IDaaS）平台，该平台的设计考虑了最先进的安全性。 Authing 的企业身份管理平台为客户提供了许多功能和优势，包括：  能够配置和实现需要的企业联合登录和单点登录； 强大的配置平台，最大限度的减少编码难度； Authing 支持的企业级认证包括 Active Directory，LDAP，ADFS，SAML，OIDC 等。 Authing 支持与所有主要社交软件登陆，包括 QQ，微信，GITHUB 等等。 Authing 提供传统的用户名和密码验证之外还增强的安全功能（如多因素身份验证），密码检测，强力攻击保护和异常检测。 无需强制密码重置，用户可以轻松地从现有系统迁移。 Authing 提供了审计和查看基于身份的分析的方法，以确保组织合规和增加销售机会。 公司可以使用细粒度权限和强大的自定义角色功能轻松管理用户访问规则。 Authing 的委派管理允许公司管理细粒度访问，资源可见性，和外部员工管理。 使用 Authing ，开发人员只需不到半个小时即可设置健壮且可自定义的，支持主流技术堆栈的身份管理系统。如想获得更多的身份管理资讯请访问： https://authing. cn，微信公众号： Authing。 "
    }, {
    "id": 35,
    "url": "/blog/Authing%E6%94%AF%E6%8C%81Webhook/",
    "title": "Authing 支持 Webhook",
    "body": "2019/06/04 - Webhooks 允许你对用户注册、登录等行为进行监听，从而对其做一些自定义处理。 使用 Webhook 的方法是在 Authing 平台中配置 HTTP URL，当你的用户登录、注册、修改密码后，都会给远程 HTTP URL 发送一个 POST 请求。 使用 Webhook 的方法是在 Authing 平台中配置 HTTP URL，当你的用户登录、注册、修改密码后，都会给远程 HTTP URL 发送一个 POST 请求。 配置 Webhook: 点击页面的「添加」按钮即可开始配置，如下图所示： 参数解释: 管理 Webhook: 在创建完 Webhook 之后可以看到详细的事件记录： 刚创建好的 Hook 请求事件都为空，这时你可以点击「测试」触发一个「测试事件」 测试成功后你将看到详细的请求信息和返回信息。 调试 Webhook: 调试 Webhook 的方法如下图所示： 点击后将发送一个 Post 请求到配置好的 HTTP URL 中。 请求数据为： {  description :  A test from Authing Webhook }支持的事件: 事件列表: 请求类型: 指定发起 Webhook 请求时 Request body 的数据格式，可选值有 application/json 和 application/x-www-form-urlencoded 附带的数据: 每一个事件都会携带一些特定的请求参数。 Request headers: 我们会在 HTTP POST 头中携带一些自定义头信息，如下表所示： Request body: 请求体中也会携带一些特定参数 Request 示例: headers {  Accept :  application/json, text/plain, */* ,  Content-Type :  application/json; charset=UTF-8 ,  User-Agent :  authing-hook ,  X-Authing-Token :   ,  X-Authing-Event :  login ,  Content-Length : 337}Login Event Body {  success : 1,  message :  密码修改成功 ,  executed_at : 1559453952531,  params : {    _id :  5cf3608753c403913e81f74b ,    password :  +5NllFUKNK/AgyJPd7QNfO7kH1x8J9L7S65NQh/n5TzgcwaveLg= ,    registerInClient :  59f86b4832eb28071bdd9214  },  emit_by : {    _id :  5c00a5fbec1083000f5b27d4 ,    username :   ,    email :  xieyang@dodora. cn ,    phone :    }}Register Event Body {  success : 1,  message :  注册成功 ,  executedAt : 1559453155297,  params : {    _id :  590cd6b4832eb28071bdd9251     email :  example@example. com ,    password :  30f049f7ae9386d2ac2c203f5c4319a5 ,    registerInClient :  59f86b4832eb28071bdd9214 ,    username :  username ,    registerMethod :  default:username-password ,    nickname :   ,    emailVerified : true }}Change-password Event body {  success : 1,  message :  注册成功 ,  executedAt : 1559453831284,  params : {    __v : 0,    email :  example@example2. com ,    registerInClient :  59f86b4832eb28071bdd9214 ,    salt :  fhnli5d0ahoi ,    _id :  5cf3608753c403913e81f74b ,    updatedAt :   ,    country :   ,    postalCode :   ,    region :   ,    locality :   ,    streetAddress :   ,    formatted :   ,    address :   ,    locale :   ,    zoneinfo :   ,    birthdate :   ,    gender :   ,    website :   ,    preferredUsername :   ,    profile :   ,    middleName :   ,    familyName :   ,    givenName :   ,    name :   ,    phoneCode :   ,    oauth :   ,    isDeleted : false,    blocked : false,    signedUp :  2019-06-02T05:37:11. 257Z ,    lastLogin :  2019-06-02T05:37:11. 257Z ,    registerMethod :  default:username-password ,    loginsCount : 0,    password :  bdcff42caccb7e2a889bfb490d91e67c ,    browser :   ,    photo :  https://usercontents. authing. cn/authing-avatar. png ,    company :   ,    nickname :   ,    username :  example2 ,    phoneVerfified : false,    emailVerified : true,    phone :    },  emit_by : {    _id :  5c00a5fbec1083000f5b27d4 ,    username :  root ,    email :  xieyang@dodora. cn ,    phone :    }}"
    }, {
    "id": 36,
    "url": "/blog/%E5%A6%82%E4%BD%95%E5%9C%A8%E8%BF%9C%E7%A8%8B%E5%8A%9E%E5%85%AC%E4%B8%AD%E4%BF%9D%E6%8C%81%E9%AB%98%E6%95%88%E7%9A%84%E7%A0%94%E5%8F%91%E6%95%88%E7%8E%87/",
    "title": "如何在远程办公中保持高效的研发效率",
    "body": "2019/02/02 - 开发者群体是个与其他工种不同的群体，他们热爱创造，工作是为了满足自己的创造欲，是完全自驱的；而优秀的开发者，完全不受地理位置限制。 这就是我们要建设分布式研发团队的原因 —— 一个多样化的团队是更好的团队。 我们成功建设了一个分布在中国五个省市的高效研发团队，我们构建的产品，服务全球七个国家和地区的用户。当来自各个地区，拥有不同背景的人联合起来后，极大的拓展了我们的力量。本篇文章将总结我们在建设一个分布式研发团队时所面临的问题和解决方案。 分布式研发团队相比坐在一个办公室里的团队，存在着更多问题，比如工作时间不重叠、团队融合和激励，但实践来看，最需要解决的是以下三个问题：  协作问题； 项目管理问题； 价值观和文化的传递问题；协作问题: 当你和同事坐在同一间办公室时，吼一嗓子就能得到回应。但在一个分布式团队中，经常会出现消息未读、电话没人接的情况，分布式协作是一个自由的环境，这种情况是允许出现的。当然，这种事情并不说明项目会得到延期，因为某个模块的开发者会在其他时间完成该做的事情。但这样的情况往往会使得不到回应的人抓狂，软件系统变复杂后，模块之间往往相互关联，如果没有得到及时回应有可能会导致工程出现问题。 沟通上的另一个问题是团队之间可能没有见过，不过这在开发者群体中不是什么大问题，开发者已经习惯了在 Github 上向陌生人提 Issues 或者帮助陌生人修复 BUG。 从实践中来看，协作主要包含两点：沟通和信息同步。为了保证高效的分布式协作，我们制定了以下基本的协作原则：  由一个人来起草月计划，其他人一起做修改和补充，周计划围绕月计划进行； 每周一上午一次视频周会，同步上周的进展和本周的计划； 每个人以去中心化的方式（非项目组织者统一指挥）制定自己的计划，每个计划必须激进（猛跳能够到的目标）和有明确的 Deadline； 产品开发允许延期和变动，若有延期或变动，在群内同步原因和后续计划，做到每件事必有 Deadline； 内部测试不追求完美，若有可预览的进展，及时在群内同步并请大家测试（我们没有专门的 QA，遵循的原则是由非模块开发者来进行测试）； 使用高效的工具做即时推送，对信息进行最大限度的同步；这需要给每个人一点时间来适应，一旦适应好之后，协作效率会和和同事在一间办公室一样甚至更高。 项目管理问题: 分布式协作另一个大的问题是项目管理，我们由开发者自己决定每月每周每天要做什么，并按计划进行，这一点基本上没有什么问题，参与分布式协作的人必须是能够自我管理的人。出问题的环节也不在这里，而是需求质量。 我们出现过至少两次需求不合理导致返工的问题，这对开发者本人和项目本身都是很大的损耗，每当出现这种情况时，团队便会出现抱怨的声音。这类问题往往有如下几种场景：  产品经理在提需求时没有想清楚，开发者 review 时也没有思考完全，做了一半后发现技术上是不符合逻辑的； 开发者在写方案时没有将方案对齐到具体的参数、返回结果和报错信息，同时也没有其他人及时留意到这个问题，导致实际使用时需要进行二次修改；这个问题的解决方案也很简单粗暴，就是由每一个干系人仔细讨论，因此我们制定了一个流程：  模块负责人在可以在线编写和协作的文档中起草方案； 相关干系人在文档中评论，提出问题和疑惑，将解决方案对齐； 所有疑问和边缘条件都解决后，我们将所有需求细化到任务管理工具上并开始开发；这个流程虽然看上去多了些扯皮的工作，但是能显著提高需求质量。 项目管理上另外一个很重要的点是使用「高效的生产力工具」。你可能会想「生产力工具」本来就是高效的，前面再加个「高效」，是不是重复了。其实不然，生产力工具很多，选择最好用的工具将事半功倍 ——工欲善其事，必先利其器。 我们核心只使用了两款工具：  Tower —— 用来做具体的项目执行； Lark 飞书 —— 用来做即时沟通、文档协作和 ChatOps；除了这两款，还有邮箱用来和海外用户交流、Git 用来管理代码，不过这属于基础工具了。 工具链保持简洁很重要。**前段时间，我们在 Tower、倍洽、企业微信、Notion、石墨和Google Docs **之间到处切换，直到有一天团队再也受不了，我们争执了一番后将即时沟通、文档协作和 ChatOps 换到了 Lark 上，Tower 不变依然用来做项目执行。我们本有换掉 Tower 的打算，不过鉴于更换成本，我们还是选择了留在 Tower 上，想换掉 Tower 的原因是 Tower 不提供 API 让我们能在群聊内即时将任务同步到看板中，它只能单向推送，这不符合 ChatOps 的设计理念，有时也会耽误我们的生产效率，因为我们还要在网页和聊天窗口中切换。 Lark 的 Notice Bot 很有用，我们的 ChatOps 都是依赖 Lark 的 Notice Bot，我们在内部打造了一个「推送」的世界。 Git 消息推送 响应时间过长或服务不可用推送 用户反馈推送 小程序反馈推送 SDK 需求推送 这些都属于一个研发团队中比较基础的操作，但当你处于一个分布式协作团队中时，因为看不到彼此在干什么，因此当所有信息即时推送、即时同步时，会让团队每个人都有安全感。我们的研发团队是一个紧密型小组，我们紧密合作，构建并交付解决方案。这种推送让分散的小组对他们正在构建的东西、什么能提高效率有清晰的认识，并具有主人翁精神，这让它非常适合于团队的分布式性质。 价值观和文化的传递问题: 最后一个问题是价值观和文化的传递问题，这是最难的问题。无论是沟通问题还是项目管理问题都能用流程和工具来解决，而价值观光和文化只靠这些是不够的。 首先说一下我们团队的组建过程，早期的开发者是大学同学，后来有从用户转化过来的开发者，我们的用户爱我们的产品，从用户变成了这款产品的创造者和维护者。此外，所有不涉及商业核心的代码，我们都是开源的，由此也吸引了一批开发者为我们维护各语言的 SDK。 当然，我们还是要依靠一些现代工具。 首先是视频会议，我们使用的 Lark 会同步每个人的日历（我们希望每个人都能将自己的日程信息化，这样会非常便于管理），这样会议协调会很容易，同时我们保证每次会议大家都能露脸，这让每个人都能见到其他人的神情、动作，虽然隔着屏幕，也比看着聊天框里的文字和表情要亲近一些。 除了这样的工具外，就是每天的具体细节。尊重和信任是对人最大的激励、鼓励每个人分享的团队文化才是正向的。同时还要鼓励每个人把自己的能力贡献给项目和组织，并获得事业上的发展。鼓励每个人互帮互助，没有等级，团队的工程师可以直接开喷领导者（我不是说开喷是好事，而是允许这种情况发生）。 这些都是通过线上交流获得的，线下活动也是必不可少的。比如每个月邀请大家聚到一起娱乐、一起喝酒、一起打游戏、每个节日互送礼物。 总之，让大家成功，让项目成功，是构建组织文化和价值观的根本目标。 最后，请允许我介绍下我们在做的事情: 我们的组织名称叫「蒸汽记忆」，英文名为 Steamory，这个名字是「Steam」 + 「Memeory」的合成词。我们在开发下一代云原生操作系统，我们的计算平台以用户身份为中心，旨在让用户拥有自己的数据，控制自己的数据，同时数据可以在多个平台重复流转使用。我们计划中的三大产品线为「身份认证云」、「开放关联数据云」和配套的「开发者工具」。 目前已经上线的产品为「身份认证云」，开发者遍布全球七个国家和地区，客户覆盖教育、出版社、知识图谱、聊天机器人、金融、云计算、物联网和营销自动化等多个领域。 "
    }, {
    "id": 37,
    "url": "/blog/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81%E5%80%BC%E5%BE%97%E4%B8%8A%E4%BA%91/",
    "title": "为什么身份认证值得上云",
    "body": "2018/09/15 - 身份认证云本质上是一种“无服务器”应用，今天，我们就来讨论下这种模式的优点和缺点。如果没有权衡利弊，你或许不会使用身份认证云或其他“无服务器应用”。 先看一下“无服务器架构”的介绍： 无服务器架构是包含 BaaS （后端即服务）和 FaaS （函数即服务）的程序开发 /部署方案（但未来远不止如此）。这类结构消除了对传统服务器的管理需求，使用无服务器架构可以显著降低运营成本、复杂性和开发时间。相应的代价是对供应商有更强的依赖性。 身份认证云是无服务器架构的一个分支，使用身份认证云和使用无服务器架构拥有一样的好处。 减少管理成本: 身份认证云本质上是一种外包解决方案，这种方案就是向某人付费以管理身份认证这个过程。由于一个服务同时被上千人使用，所以会产生一种规模经济效应：你所需支付的费用非常少，因为和其他人共享了基础设施（硬件、网络）。 除了与他人共享基础设施外，你还可以省掉大量的人工成本，不必开发基础设施，从而快速进入核心业务的开发。 如果说 PaaS 是为你解决了硬件和资源层的抽象，那么 Serverless 则是为你解决了软件层的抽象，这样你可以更加专注于市场和产品。 减少开发成本: 身份认证虽然听上去很简单，但他包括了注册、登录、密码管理、非法探测以及其他登录方式（如 OAuth，小程序扫码），而这些功能在大多数应用中都是相似的。Authing 便是应此而生的，我们希望将现成的身份认证功能集成到应用程序中，而不用每次开一个新项目都去重复开发相似的功能，这不仅浪费资源还浪费时间。 另一个例子是 BaaS 数据库，如 Firebase。这源于一些团队发现客户端与数据库的连接完全可以从业务中剥离出来。BaaS 不仅消除了大部分数据库管理开销，也提供了 ACL 访问权限机制，这样能保证足够的安全性。 不可否认的是，没有一家公司仅能靠自己的代码开发出成功的产品。将自己的非核心业务通过云的方式托管到第三方服务上，不失为一个好的选择。 减少伸缩成本: 无服务器或 FaaS 最大的优势是其无限弹性拓展能力，而这带给你的最大好处是只需要支付所需的计算费用，不用支付为保障弹性伸缩而配置的其他计算资源。假设你在推广一个 APP，当峰值来临的时候，登录接口挂掉，新用户无法注册，这会对你的业务造成致命的打击。而使用 Authing 这种身份认证云的时候，你则完全不用操心，因为系统会在峰值时自动伸缩。 上图的红线是你在自己做弹性伸缩时所需要的服务器数量，蓝线是使用 Authing 时所需要的服务器数量，线的高度越低，所需支付的费用就越少。比起闲置的红线，蓝线明显更加绿色节能，这对厂商和消费者来说都是好事。  大公司的服务器集群利用率仅有 5%-15%。——福布斯 而使用无服务器应用后能显著提高资源利用率。 友好强大的管理界面: 合格的的无服务器应用都会配备强大的管理界面，这些界面能让你更容易的管理数据，拥有这些也不需要编写任何代码。 说完了优点，让我们看看缺点。 缺少控制权: 任何云服务，都有系统停机、成本变化、功能丧失或强制升级等问题（ Authing 自然不会例外），用户在这种情况下只能十分被动的接受。如果处理不及时，可能会造成一定损失。 多租户问题: 多租户问题指所有的认证请求都在同一批机器上，可能会引发由于交叉验证而产生的 BUG，这可能会间接影响到其他用户。这些 BUG 包括：安全问题（如一个客户能看到另一个客户的数据）、稳定性问题（一个客户产生的数据错误引发另一个客户的数据发生错误）和性能问题（一个高负载客户导致其他人减速）。 强依赖性: 一旦你长时间使用 Authing，你可能会对 Authing 产生依赖，这时你在升级设计或架构时可能会遇到一些麻烦。 总结: 尽管身份认证云如今还不完美（因为他正处于一个青少年时期），但他的魅力已经开始展现。未来几年一定还会取得其他有趣进展，总有一天身份认证上云将会进入我们的架构工具包。 "
    }];

var idx = lunr(function () {
    this.ref('id')
    this.field('title')
    this.field('body')

    documents.forEach(function (doc) {
        this.add(doc)
    }, this)
});


    
function lunr_search(term) {
    $('#lunrsearchresults').show( 1000 );
    $( "body" ).addClass( "modal-open" );
    
    document.getElementById('lunrsearchresults').innerHTML = '<div id="resultsmodal" class="modal fade show d-block"  tabindex="-1" role="dialog" aria-labelledby="resultsmodal"> <div class="modal-dialog shadow-lg" role="document"> <div class="modal-content"> <div class="modal-header" id="modtit"> <button type="button" class="close" id="btnx" data-dismiss="modal" aria-label="Close"> &times; </button> </div> <div class="modal-body"> <ul class="mb-0"> </ul>    </div> <div class="modal-footer"><button id="btnx" type="button" class="btn btn-secondary btn-sm" data-dismiss="modal">Close</button></div></div> </div></div>';
    if(term) {
        document.getElementById('modtit').innerHTML = "<h5 class='modal-title'>Search results for '" + term + "'</h5>" + document.getElementById('modtit').innerHTML;
        //put results on the screen.
        var results = idx.search(term);
        if(results.length>0){
            //console.log(idx.search(term));
            //if results
            for (var i = 0; i < results.length; i++) {
                // more statements
                var ref = results[i]['ref'];
                var url = documents[ref]['url'];
                var title = documents[ref]['title'];
                var body = documents[ref]['body'].substring(0,160)+'...';
                document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML = document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML + "<li class='lunrsearchresult'><a href='" + url + "'><span class='title'>" + title + "</span><br /><small><span class='body'>"+ body +"</span><br /><span class='url'>"+ url +"</span></small></a></li>";
            }
        } else {
            document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML = "<li class='lunrsearchresult'>Sorry, no results found. Close & try a different search!</li>";
        }
    }
    return false;
}
</script>
<style>
    .lunrsearchresult .title {color: #d9230f;}
    .lunrsearchresult .url {color: silver;}
    .lunrsearchresult a {display: block; color: #777;}
    .lunrsearchresult a:hover, .lunrsearchresult a:focus {text-decoration: none;}
    .lunrsearchresult a:hover .title {text-decoration: underline;}
</style>




<form class="bd-search hidden-sm-down" onSubmit="return lunr_search(document.getElementById('lunrsearch').value);">
<input type="text" class="form-control text-small"  id="lunrsearch" name="q" value="" placeholder="搜点什么吧..."> 
</form>
            </ul>
        </div>
    </div>
    </nav>

    <!-- Search Results -->
    <div id="lunrsearchresults">
        <ul class="mb-0"></ul>
    </div>

    <!-- Content -->
    <main role="main" class="site-content">
        <div class="container">
<h4 class="font-weight-bold spanborder"><span>Authors</span></h4>
    <div class="row gap-y listrecent listrecent listauthor">
    
        <div class="col-lg-6 mb-4">
            <div class="p-4 border rounded">
            <div class="row">
            <div class="col-md-3 mb-4 mb-md-0"><img alt="谢扬" src="/blog//assets/images/ivy.jpg" class="rounded-circle" height="80" width="80"></div>
            <div class="col-md-9">
            <a href="/blog/author-谢扬">
            <h4 class="text-dark mb-0"> 谢扬 </h4>
            <small class="d-inline-block mt-1 mb-3 font-weight-normal">(View Posts)</small>
            <div class="excerpt">Working for computer technologies that can give new possibilities to science, engineering and art, while benefiting hundreds of millions of people.</div>
            </a>
            <div class="icon-block mt-3 d-flex justify-content-between">  
            <div>
            <a target="_blank" href="http://ivydom.com"><i class="fab fa-twitter text-muted" aria-hidden="true"></i></a>  &nbsp;
            <a target="_blank" href="http://ivydom.com"><i class="fa fa-globe text-muted" aria-hidden="true"></i></a> &nbsp;
            </div>
            </div>
            </div>
            </div>
            </div>
        </div>
    
        <div class="col-lg-6 mb-4">
            <div class="p-4 border rounded">
            <div class="row">
            <div class="col-md-3 mb-4 mb-md-0"><img alt="廖长江" src="/blog//assets/images/cj.png" class="rounded-circle" height="80" width="80"></div>
            <div class="col-md-9">
            <a href="/blog/author-廖长江">
            <h4 class="text-dark mb-0"> 廖长江 </h4>
            <small class="d-inline-block mt-1 mb-3 font-weight-normal">(View Posts)</small>
            <div class="excerpt">Web fullstack developer.</div>
            </a>
            <div class="icon-block mt-3 d-flex justify-content-between">  
            <div>
            <a target="_blank" href="https://www.zhihu.com/people/lcj1024"><i class="fab fa-twitter text-muted" aria-hidden="true"></i></a>  &nbsp;
            <a target="_blank" href="https://www.zhihu.com/people/lcj1024"><i class="fa fa-globe text-muted" aria-hidden="true"></i></a> &nbsp;
            </div>
            </div>
            </div>
            </div>
            </div>
        </div>
    
        <div class="col-lg-6 mb-4">
            <div class="p-4 border rounded">
            <div class="row">
            <div class="col-md-3 mb-4 mb-md-0"><img alt="杜新帅" src="/blog//assets/images/duxinshuai.png" class="rounded-circle" height="80" width="80"></div>
            <div class="col-md-9">
            <a href="/blog/author-杜新帅">
            <h4 class="text-dark mb-0"> 杜新帅 </h4>
            <small class="d-inline-block mt-1 mb-3 font-weight-normal">(View Posts)</small>
            <div class="excerpt">Blogger, love to explore new ideas and write on my morning coffee!</div>
            </a>
            <div class="icon-block mt-3 d-flex justify-content-between">  
            <div>
            <a target="_blank" href="https://twitter.com/wowthemesnet"><i class="fab fa-twitter text-muted" aria-hidden="true"></i></a>  &nbsp;
            <a target="_blank" href="https://www.wowthemes.net"><i class="fa fa-globe text-muted" aria-hidden="true"></i></a> &nbsp;
            </div>
            </div>
            </div>
            </div>
            </div>
        </div>
    
        <div class="col-lg-6 mb-4">
            <div class="p-4 border rounded">
            <div class="row">
            <div class="col-md-3 mb-4 mb-md-0"><img alt="叶祖伟" src="/blog//assets/images/yelexin.svg" class="rounded-circle" height="80" width="80"></div>
            <div class="col-md-9">
            <a href="/blog/author-叶祖伟">
            <h4 class="text-dark mb-0"> 叶祖伟 </h4>
            <small class="d-inline-block mt-1 mb-3 font-weight-normal">(View Posts)</small>
            <div class="excerpt">Fullstack developer who plays music.</div>
            </a>
            <div class="icon-block mt-3 d-flex justify-content-between">  
            <div>
            <a target="_blank" href=""><i class="fab fa-twitter text-muted" aria-hidden="true"></i></a>  &nbsp;
            <a target="_blank" href="https://yelexin.cn"><i class="fa fa-globe text-muted" aria-hidden="true"></i></a> &nbsp;
            </div>
            </div>
            </div>
            </div>
            </div>
        </div>
    
        <div class="col-lg-6 mb-4">
            <div class="p-4 border rounded">
            <div class="row">
            <div class="col-md-3 mb-4 mb-md-0"><img alt="晋剑" src="/blog//assets/images/jackjin.png" class="rounded-circle" height="80" width="80"></div>
            <div class="col-md-9">
            <a href="/blog/author-晋剑">
            <h4 class="text-dark mb-0"> 晋剑 </h4>
            <small class="d-inline-block mt-1 mb-3 font-weight-normal">(View Posts)</small>
            <div class="excerpt">不骑单车好多年 ;-)</div>
            </a>
            <div class="icon-block mt-3 d-flex justify-content-between">  
            <div>
            <a target="_blank" href="https://twitter.com/JinJian5"><i class="fab fa-twitter text-muted" aria-hidden="true"></i></a>  &nbsp;
            <a target="_blank" href="https://www.jackjin.io"><i class="fa fa-globe text-muted" aria-hidden="true"></i></a> &nbsp;
            </div>
            </div>
            </div>
            </div>
            </div>
        </div>
    
    </div>
</div>
    </main>


    <!-- Scripts: popper, bootstrap, theme, lunr -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.6/umd/popper.min.js" integrity="sha384-wHAiFfRlMFy6i5SRaxvfOCifBUQy1xHdJ/yoi7FRNXMRBu5WHdZYu1hA6ZOblgut" crossorigin="anonymous"></script>

    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.2.1/js/bootstrap.min.js" integrity="sha384-B0UglyR+jN6CkvvICOB2joaf5I4l3gm9GU6Hc1og6Ls7i6U/mkkaduKaBhlAXv9k" crossorigin="anonymous"></script>

    <script src="/blog/assets/js/theme.js"></script>


    <!-- Footer -->
    <footer class="bg-white border-top p-3 text-muted small">
        <div class="container">
        <div class="row align-items-center justify-content-between">
            <div>
                <span class="navbar-brand mr-2 mb-0">
                    <img src="https://usercontents.authing.cn/logo/authing@256x78.png" style="height:34px">
                </span>
                <span>Copyright © Authing.cn <script>document.write(new Date().getFullYear())</script>.</span>

                <!--  Github Repo Star Btn-->
                <a class="text-dark ml-1" target="_blank" href="https://github.com/authing/meme"><i class="fab fa-github"></i> Fork on Github</a>

            </div>
            <div>
                Powered by <a target="_blank" class="text-dark font-weight-bold" href="https://authing.cn/"> Authing</a></a>.
            </div>
        </div>
        <div class="row">
            <span>责任主体：北京蒸汽记忆科技有限公司</span>
            <span style="display:inline-block;margin-left:6px;margin-right:6px"> | </span>
            <span>ICP 备案号： 京ICP备19051205号-1</span>
        </div>
        </div>
    </footer>

    <!-- All this area goes before </body> closing tag --> 
<script type="text/javascript" src="https://s4.cnzz.com/z_stat.php?id=1278621246&web_id=1278621246"></script>

</body>

</html>
